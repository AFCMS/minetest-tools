[{"prefix":"features","token":"minetest","detail":"minetest.features","kind":5,"desc":"","body":"features"},{"prefix":"settings","token":"minetest","detail":"minetest.settings","kind":5,"desc":"  main config file (`minetest.conf`).","body":"settings"},{"prefix":"registered_items","token":"minetest","detail":"minetest.registered_items","kind":5,"desc":"    * Map of registered items, indexed by name","body":"registered_items"},{"prefix":"registered_nodes","token":"minetest","detail":"minetest.registered_nodes","kind":5,"desc":"    * Map of registered node definitions, indexed by name","body":"registered_nodes"},{"prefix":"registered_craftitems","token":"minetest","detail":"minetest.registered_craftitems","kind":5,"desc":"    * Map of registered craft item definitions, indexed by name","body":"registered_craftitems"},{"prefix":"registered_tools","token":"minetest","detail":"minetest.registered_tools","kind":5,"desc":"    * Map of registered tool definitions, indexed by name","body":"registered_tools"},{"prefix":"registered_entities","token":"minetest","detail":"minetest.registered_entities","kind":5,"desc":"    * Map of registered entity prototypes, indexed by name","body":"registered_entities"},{"prefix":"object_refs","token":"minetest","detail":"minetest.object_refs","kind":5,"desc":"    * Map of object references, indexed by active object id","body":"object_refs"},{"prefix":"luaentities","token":"minetest","detail":"minetest.luaentities","kind":5,"desc":"    * Map of Lua entities, indexed by active object id","body":"luaentities"},{"prefix":"registered_abms","token":"minetest","detail":"minetest.registered_abms","kind":5,"desc":"    * List of ABM definitions","body":"registered_abms"},{"prefix":"registered_lbms","token":"minetest","detail":"minetest.registered_lbms","kind":5,"desc":"    * List of LBM definitions","body":"registered_lbms"},{"prefix":"registered_aliases","token":"minetest","detail":"minetest.registered_aliases","kind":5,"desc":"    * Map of registered aliases, indexed by name","body":"registered_aliases"},{"prefix":"registered_ores","token":"minetest","detail":"minetest.registered_ores","kind":5,"desc":"    * Map of registered ore definitions, indexed by the `name` field.","body":"registered_ores"},{"prefix":"registered_biomes","token":"minetest","detail":"minetest.registered_biomes","kind":5,"desc":"    * Map of registered biome definitions, indexed by the `name` field.","body":"registered_biomes"},{"prefix":"registered_decorations","token":"minetest","detail":"minetest.registered_decorations","kind":5,"desc":"    * Map of registered decoration definitions, indexed by the `name` field.","body":"registered_decorations"},{"prefix":"registered_schematics","token":"minetest","detail":"minetest.registered_schematics","kind":5,"desc":"    * Map of registered schematic definitions, indexed by the `name` field.","body":"registered_schematics"},{"prefix":"registered_chatcommands","token":"minetest","detail":"minetest.registered_chatcommands","kind":5,"desc":"    * Map of registered chat command definitions, indexed by name","body":"registered_chatcommands"},{"prefix":"registered_privileges","token":"minetest","detail":"minetest.registered_privileges","kind":5,"desc":"    * Map of registered privilege definitions, indexed by name","body":"registered_privileges"},{"prefix":"formspec_version","token":"","detail":"formspec_version[version]","kind":13,"desc":"* Set the formspec version to a certain number. If not specified,","body":"formspec_version[${1:version}]"},{"prefix":"size","token":"","detail":"size[W,H,fixed_size]","kind":13,"desc":"* Define the size of the menu in inventory slots\n* `fixed_size`: `true`/`false` (optional)\n* deprecated: `invsize[<W>,<H>;]`","body":"size[${1:W},${2:H},${3:fixed_size}]"},{"prefix":"position","token":"","detail":"position[X,Y]","kind":13,"desc":"* Must be used after `size` element.\n* Defines the position on the game window of the formspec's `anchor` point.\n* For X and Y, 0.0 and 1.0 represent opposite edges of the game window,","body":"position[${1:X},${2:Y}]"},{"prefix":"anchor","token":"","detail":"anchor[X,Y]","kind":13,"desc":"* Must be used after both `size` and `position` (if present) elements.\n* Defines the location of the anchor point within the formspec.\n* For X and Y, 0.0 and 1.0 represent opposite edges of the formspec,","body":"anchor[${1:X},${2:Y}]"},{"prefix":"no_prepend","token":"","detail":"no_prepend[]","kind":13,"desc":"* Must be used after the `size`, `position`, and `anchor` elements (if present).\n* Disables player:set_formspec_prepend() from applying to this formspec.","body":"no_prepend[]"},{"prefix":"real_coordinates","token":"","detail":"real_coordinates[bool]","kind":13,"desc":"* INFORMATION: Enable it automatically using `formspec_version` version 2 or newer.\n* When set to true, all following formspec elements will use the new coordinate system.\n* If used immediately after `size`, `position`, `anchor`, and `no_prepend` elements","body":"real_coordinates[${1:bool}]"},{"prefix":"container","token":"","detail":"container[X,Y]","kind":13,"desc":"* Start of a container block, moves all physical elements in the container by","body":"container[${1:X},${2:Y}]"},{"prefix":"container_end","token":"","detail":"container_end[]","kind":13,"desc":"* End of a container, following elements are no longer relative to this","body":"container_end[]"},{"prefix":"list","token":"","detail":"list[inventory location;list name;X,Y;W,H;]","kind":13,"desc":"* Show an inventory list if it has been sent to the client. Nothing will","body":"list[${1:inventory location};${2:list name};${3:X},${4:Y};${5:W},${6:H};]"},{"prefix":"list","token":"","detail":"list[inventory location;list name;X,Y;W,H;starting item index]","kind":13,"desc":"* Show an inventory list if it has been sent to the client. Nothing will","body":"list[${1:inventory location};${2:list name};${3:X},${4:Y};${5:W},${6:H};${7:starting item index}]"},{"prefix":"listring","token":"","detail":"listring[inventory location;list name]","kind":13,"desc":"* Allows to create a ring of inventory lists\n* Shift-clicking on items in one element of the ring","body":"listring[${1:inventory location};${2:list name}]"},{"prefix":"listring","token":"","detail":"listring[]","kind":13,"desc":"* Shorthand for doing `listring[<inventory location>;<list name>]`","body":"listring[]"},{"prefix":"listcolors","token":"","detail":"listcolors[slot_bg_normal;slot_bg_hover]","kind":13,"desc":"* Sets background color of slots as `ColorString`\n* Sets background color of slots on mouse hovering","body":"listcolors[${1:slot_bg_normal};${2:slot_bg_hover}]"},{"prefix":"listcolors","token":"","detail":"listcolors[slot_bg_normal;slot_bg_hover;slot_border]","kind":13,"desc":"* Sets background color of slots as `ColorString`\n* Sets background color of slots on mouse hovering\n* Sets color of slots border","body":"listcolors[${1:slot_bg_normal};${2:slot_bg_hover};${3:slot_border}]"},{"prefix":"listcolors","token":"","detail":"listcolors[slot_bg_normal;slot_bg_hover;slot_border;tooltip_bgcolor;tooltip_fontcolor]","kind":13,"desc":"* Sets background color of slots as `ColorString`\n* Sets background color of slots on mouse hovering\n* Sets color of slots border\n* Sets default background color of tooltips\n* Sets default font color of tooltips","body":"listcolors[${1:slot_bg_normal};${2:slot_bg_hover};${3:slot_border};${4:tooltip_bgcolor};${5:tooltip_fontcolor}]"},{"prefix":"tooltip","token":"","detail":"tooltip[gui_element_name;tooltip_text;bgcolor;fontcolor]","kind":13,"desc":"* Adds tooltip for an element\n* `<bgcolor>` tooltip background color as `ColorString` (optional)\n* `<fontcolor>` tooltip font color as `ColorString` (optional)","body":"tooltip[${1:gui_element_name};${2:tooltip_text};${3:bgcolor};${4:fontcolor}]"},{"prefix":"tooltip","token":"","detail":"tooltip[X,Y;W,H;tooltip_text;bgcolor;fontcolor]","kind":13,"desc":"* Adds tooltip for an area. Other tooltips will take priority when present.\n* `<bgcolor>` tooltip background color as `ColorString` (optional)\n* `<fontcolor>` tooltip font color as `ColorString` (optional)","body":"tooltip[${1:X},${2:Y};${3:W},${4:H};${5:tooltip_text};${6:bgcolor};${7:fontcolor}]"},{"prefix":"image","token":"","detail":"image[X,Y;W,H;texture name]","kind":13,"desc":"* Show an image","body":"image[${1:X},${2:Y};${3:W},${4:H};${5:texture name}]"},{"prefix":"item_image","token":"","detail":"item_image[X,Y;W,H;item name]","kind":13,"desc":"* Show an inventory image of registered item/node","body":"item_image[${1:X},${2:Y};${3:W},${4:H};${5:item name}]"},{"prefix":"bgcolor","token":"","detail":"bgcolor[color;fullscreen]","kind":13,"desc":"* Sets background color of formspec as `ColorString`\n* If `true`, a fullscreen background is drawn and the color is ignored","body":"bgcolor[${1:color};${2:fullscreen}]"},{"prefix":"background","token":"","detail":"background[X,Y;W,H;texture name]","kind":13,"desc":"* Example for formspec 8x4 in 16x resolution: image shall be sized","body":"background[${1:X},${2:Y};${3:W},${4:H};${5:texture name}]"},{"prefix":"background","token":"","detail":"background[X,Y;W,H;texture name;auto_clip]","kind":13,"desc":"* Example for formspec 8x4 in 16x resolution:","body":"background[${1:X},${2:Y};${3:W},${4:H};${5:texture name};${6:auto_clip}]"},{"prefix":"background9","token":"","detail":"background9[X,Y;W,H;texture name;auto_clip;middle]","kind":13,"desc":"* 9-sliced background. See https://en.wikipedia.org/wiki/9-slice_scaling\n* Middle is a rect which defines the middle of the 9-slice.","body":"background9[${1:X},${2:Y};${3:W},${4:H};${5:texture name};${6:auto_clip};${7:middle}]"},{"prefix":"pwdfield","token":"","detail":"pwdfield[X,Y;W,H;name;label]","kind":13,"desc":"* Textual password style field; will be sent to server when a button is clicked\n* When enter is pressed in field, fields.key_enter_field will be sent with the","body":"pwdfield[${1:X},${2:Y};${3:W},${4:H};${5:name};${6:label}]"},{"prefix":"field","token":"","detail":"field[X,Y;W,H;name;label;default]","kind":13,"desc":"* Textual field; will be sent to server when a button is clicked\n* When enter is pressed in field, `fields.key_enter_field` will be sent with","body":"field[${1:X},${2:Y};${3:W},${4:H};${5:name};${6:label};${7:default}]"},{"prefix":"field","token":"","detail":"field[name;label;default]","kind":13,"desc":"* As above, but without position/size units\n* When enter is pressed in field, `fields.key_enter_field` will be sent with","body":"field[${1:name};${2:label};${3:default}]"},{"prefix":"field_close_on_enter","token":"","detail":"field_close_on_enter[name;close_on_enter]","kind":13,"desc":"* <name> is the name of the field\n* if <close_on_enter> is false, pressing enter in the field will submit the","body":"field_close_on_enter[${1:name};${2:close_on_enter}]"},{"prefix":"textarea","token":"","detail":"textarea[X,Y;W,H;name;label;default]","kind":13,"desc":"* Same as fields above, but with multi-line input\n* If the text overflows, a vertical scrollbar is added.\n* If the name is empty, the textarea is read-only and","body":"textarea[${1:X},${2:Y};${3:W},${4:H};${5:name};${6:label};${7:default}]"},{"prefix":"label","token":"","detail":"label[X,Y;label]","kind":13,"desc":"* The label formspec element displays the text set in `label`","body":"label[${1:X},${2:Y};${3:label}]"},{"prefix":"vertlabel","token":"","detail":"vertlabel[X,Y;label]","kind":13,"desc":"* Textual label drawn vertically\n* `label` is the text on the label\n* **Note**: If the new coordinate system is enabled, vertlabels are","body":"vertlabel[${1:X},${2:Y};${3:label}]"},{"prefix":"button","token":"","detail":"button[X,Y;W,H;name;label]","kind":13,"desc":"* Clickable button. When clicked, fields will be sent.\n* With the old coordinate system, buttons are a set height, but will be vertically","body":"button[${1:X},${2:Y};${3:W},${4:H};${5:name};${6:label}]"},{"prefix":"image_button","token":"","detail":"image_button[X,Y;W,H;texture name;name;label]","kind":13,"desc":"* `texture name` is the filename of an image\n* **Note**: Height is supported on both the old and new coordinate systems","body":"image_button[${1:X},${2:Y};${3:W},${4:H};${5:texture name};${6:name};${7:label}]"},{"prefix":"image_button","token":"","detail":"image_button[X,Y;W,H;texture name;name;label;noclip;drawborder;pressed texture name]","kind":13,"desc":"* `texture name` is the filename of an image\n* `noclip=true` means the image button doesn't need to be within specified","body":"image_button[${1:X},${2:Y};${3:W},${4:H};${5:texture name};${6:name};${7:label};${8:noclip};${9:drawborder};${10:pressed texture name}]"},{"prefix":"item_image_button","token":"","detail":"item_image_button[X,Y;W,H;item name;name;label]","kind":13,"desc":"* `item name` is the registered name of an item/node\n* The item description will be used as the tooltip. This can be overridden with","body":"item_image_button[${1:X},${2:Y};${3:W},${4:H};${5:item name};${6:name};${7:label}]"},{"prefix":"button_exit","token":"","detail":"button_exit[X,Y;W,H;name;label]","kind":13,"desc":"* When clicked, fields will be sent and the form will quit.\n* Same as `button` in all other respects.","body":"button_exit[${1:X},${2:Y};${3:W},${4:H};${5:name};${6:label}]"},{"prefix":"image_button_exit","token":"","detail":"image_button_exit[X,Y;W,H;texture name;name;label]","kind":13,"desc":"* When clicked, fields will be sent and the form will quit.\n* Same as `image_button` in all other respects.","body":"image_button_exit[${1:X},${2:Y};${3:W},${4:H};${5:texture name};${6:name};${7:label}]"},{"prefix":"textlist","token":"","detail":"textlist[X,Y;W,H;name;listelem 1,listelem 2,...,listelem n]","kind":13,"desc":"* Scrollable item list showing arbitrary text elements\n* `name` fieldname sent to server on doubleclick value is current selected","body":"textlist[${1:X},${2:Y};${3:W},${4:H};${5:name};${6:listelem 1},${7:listelem 2},...,${8:listelem n}]"},{"prefix":"textlist","token":"","detail":"textlist[X,Y;W,H;name;listelem 1,listelem 2,...,listelem n;selected idx;transparent]","kind":13,"desc":"* Scrollable itemlist showing arbitrary text elements\n* `name` fieldname sent to server on doubleclick value is current selected","body":"textlist[${1:X},${2:Y};${3:W},${4:H};${5:name};${6:listelem 1},${7:listelem 2},...,${8:listelem n};${9:selected idx};${10:transparent}]"},{"prefix":"tabheader","token":"","detail":"tabheader[X,Y;name;caption 1,caption 2,...,caption n;current_tab;transparent;draw_border]","kind":13,"desc":"* Show a tab**header** at specific position (ignores formsize)\n* `X` and `Y`: position of the tabheader\n* *Note*: Width and height are automatically chosen with this syntax\n* `name` fieldname data is transferred to Lua\n* `caption 1`...: name shown on top of tab\n* `current_tab`: index of selected tab 1...\n* `transparent` (optional): show transparent\n* `draw_border` (optional): draw border","body":"tabheader[${1:X},${2:Y};${3:name};${4:caption 1},${5:caption 2},...,${6:caption n};${7:current_tab};${8:transparent};${9:draw_border}]"},{"prefix":"tabheader","token":"","detail":"tabheader[X,Y;H;name;caption 1,caption 2,...,caption n;current_tab;transparent;draw_border]","kind":13,"desc":"* Show a tab**header** at specific position (ignores formsize)\n* **Important note**: This syntax for tabheaders can only be used with the","body":"tabheader[${1:X},${2:Y};${3:H};${4:name};${5:caption 1},${6:caption 2},...,${7:caption n};${8:current_tab};${9:transparent};${10:draw_border}]"},{"prefix":"tabheader","token":"","detail":"tabheader[X,Y;W,H;name;caption 1,caption 2,...,caption n;current_tab;transparent;draw_border]","kind":13,"desc":"* Show a tab**header** at specific position (ignores formsize)\n* **Important note**: This syntax for tabheaders can only be used with the","body":"tabheader[${1:X},${2:Y};${3:W},${4:H};${5:name};${6:caption 1},${7:caption 2},...,${8:caption n};${9:current_tab};${10:transparent};${11:draw_border}]"},{"prefix":"box","token":"","detail":"box[X,Y;W,H;color]","kind":13,"desc":"* Simple colored box\n* `color` is color specified as a `ColorString`.","body":"box[${1:X},${2:Y};${3:W},${4:H};${5:color}]"},{"prefix":"dropdown","token":"","detail":"dropdown[X,Y;W;name;item 1,item 2, ...,item n;selected idx]","kind":13,"desc":"* Show a dropdown field\n* **Important note**: There are two different operation modes:","body":"dropdown[${1:X},${2:Y};${3:W};${4:name};${5:item 1},${6:item 2}, ...,${7:item n};${8:selected idx}]"},{"prefix":"dropdown","token":"","detail":"dropdown[X,Y;W,H;name;item 1,item 2, ...,item n;selected idx]","kind":13,"desc":"* Show a dropdown field\n* **Important note**: This syntax for dropdowns can only be used with the","body":"dropdown[${1:X},${2:Y};${3:W},${4:H};${5:name};${6:item 1},${7:item 2}, ...,${8:item n};${9:selected idx}]"},{"prefix":"checkbox","token":"","detail":"checkbox[X,Y;name;label;selected]","kind":13,"desc":"* Show a checkbox\n* `name` fieldname data is transferred to Lua\n* `label` to be shown left of checkbox\n* `selected` (optional): `true`/`false`\n* **Note**: If the new coordinate system is enabled, checkboxes are","body":"checkbox[${1:X},${2:Y};${3:name};${4:label};${5:selected}]"},{"prefix":"scrollbar","token":"","detail":"scrollbar[X,Y;W,H;orientation;name;value]","kind":13,"desc":"* Show a scrollbar\n* There are two ways to use it:","body":"scrollbar[${1:X},${2:Y};${3:W},${4:H};${5:orientation};${6:name};${7:value}]"},{"prefix":"table","token":"","detail":"table[X,Y;W,H;name;cell 1,cell 2,...,cell n;selected idx]","kind":13,"desc":"* Show scrollable table using options defined by the previous `tableoptions[]`\n* Displays cells as defined by the previous `tablecolumns[]`\n* `name`: fieldname sent to server on row select or doubleclick\n* `cell 1`...`cell n`: cell contents given in row-major order\n* `selected idx`: index of row to be selected within table (first row = `1`)\n* See also `minetest.explode_table_event`","body":"table[${1:X},${2:Y};${3:W},${4:H};${5:name};${6:cell 1},${7:cell 2},...,${8:cell n};${9:selected idx}]"},{"prefix":"tableoptions","token":"","detail":"tableoptions[opt 1;opt 2;...]","kind":13,"desc":"* Sets options for `table[]`\n* `color=#RRGGBB`","body":"tableoptions[${1:opt 1};${2:opt 2};...]"},{"prefix":"tablecolumns","token":"","detail":"tablecolumns[type 1,opt 1a,opt 1b,...;type 2,opt 2a,opt 2b;...]","kind":13,"desc":"* Sets columns for `table[]`\n* Types: `text`, `image`, `color`, `indent`, `tree`","body":"tablecolumns[${1:type 1},${2:opt 1a},${3:opt 1b},...;${4:type 2},${5:opt 2a},${6:opt 2b};...]"},{"prefix":"style","token":"","detail":"style[name;prop1;prop2;...]","kind":13,"desc":"* Set the style for the named element `name`.\n* Note: this **must** be before the element is defined.\n* See [Styling Formspecs].","body":"style[${1:name};${2:prop1};${3:prop2};...]"},{"prefix":"style_type","token":"","detail":"style_type[type;prop1;prop2;...]","kind":13,"desc":"* Sets the style for all elements of type `type` which appear after this element.\n* See [Styling Formspecs].","body":"style_type[${1:type};${2:prop1};${3:prop2};...]"},{"prefix":"combine","token":"[","detail":"combine","kind":13,"desc":"Creates a texture of size `<w>` times `<h>` and blits the listed files to their\nspecified coordinates.","body":"combine:${1:w}x${2:h}:${3:x1},${4:y1}=${5:file1}:${6:x2},${7:y2}=${8:file2}:..."},{"prefix":"resize","token":"[","detail":"resize","kind":13,"desc":"Resizes the texture to the given dimensions.","body":"resize:${1:w}x${2:h}"},{"prefix":"opacity","token":"[","detail":"opacity","kind":13,"desc":"Makes the base image transparent according to the given ratio.","body":"opacity:${1:r}"},{"prefix":"invert","token":"[","detail":"invert","kind":13,"desc":"Inverts the given channels of the base image.\nMode may contain the characters \"r\", \"g\", \"b\", \"a\".\nOnly the channels that are mentioned in the mode string will be inverted.","body":"invert:${1:mode}"},{"prefix":"brighten","token":"[","detail":"brighten","kind":13,"desc":"Brightens the texture.","body":"brighten"},{"prefix":"noalpha","token":"[","detail":"noalpha","kind":13,"desc":"Makes the texture completely opaque.","body":"noalpha"},{"prefix":"makealpha","token":"[","detail":"makealpha","kind":13,"desc":"Convert one color to transparency.","body":"makealpha:${1:r},${2:g},${3:b}"},{"prefix":"transform<t>","token":"[","detail":"transform<t>","kind":13,"desc":"Rotates and/or flips the image.","body":"transform${1:t}"},{"prefix":"inventorycube{<top>{<left>{<right>","token":"[","detail":"inventorycube{<top>{<left>{<right>","kind":13,"desc":"Escaping does not apply here and `^` is replaced by `&` in texture names\ninstead.","body":"inventorycube{${1:top}{${2:left}{${3:right}"},{"prefix":"lowpart","token":"[","detail":"lowpart","kind":13,"desc":"Blit the lower `<percent>`% part of `<file>` on the texture.","body":"lowpart:${1:percent}:${2:file}"},{"prefix":"verticalframe","token":"[","detail":"verticalframe","kind":13,"desc":"Crops the texture to a frame of a vertical animation.","body":"verticalframe:${1:t}:${2:n}"},{"prefix":"mask","token":"[","detail":"mask","kind":13,"desc":"Apply a mask to the base image.","body":"mask:${1:file}"},{"prefix":"sheet","token":"[","detail":"sheet","kind":13,"desc":"Retrieves a tile at position x,y from the base image\nwhich it assumes to be a tilesheet with dimensions w,h.","body":"sheet:${1:w}x${2:h}:${3:x},${4:y}"},{"prefix":"colorize","token":"[","detail":"colorize","kind":13,"desc":"Colorize the textures with the given color.","body":"colorize:${1:color}:${2:ratio}"},{"prefix":"multiply","token":"[","detail":"multiply","kind":13,"desc":"Multiplies texture colors with the given color.","body":"multiply:${1:color}"},{"prefix":"get_color_escape_sequence","token":"minetest","detail":"minetest.get_color_escape_sequence(color)","kind":2,"desc":"    * `color` is a ColorString\n    * The escape sequence sets the text color to `color`","body":"get_color_escape_sequence(${1:color})"},{"prefix":"colorize","token":"minetest","detail":"minetest.colorize(color, message)","kind":2,"desc":"    * Equivalent to:\n      `minetest.get_color_escape_sequence(color) ..\n      message ..\n      minetest.get_color_escape_sequence(\"#ffffff\")`","body":"colorize(${1:color}, ${2:message})"},{"prefix":"get_background_escape_sequence","token":"minetest","detail":"minetest.get_background_escape_sequence(color)","kind":2,"desc":"    * `color` is a ColorString\n    * The escape sequence sets the background of the whole text element to\n      `color`. Only defined for item descriptions and tooltips.","body":"get_background_escape_sequence(${1:color})"},{"prefix":"strip_foreground_colors","token":"minetest","detail":"minetest.strip_foreground_colors(str)","kind":2,"desc":"    * Removes foreground colors added by `get_color_escape_sequence`.","body":"strip_foreground_colors(${1:str})"},{"prefix":"strip_background_colors","token":"minetest","detail":"minetest.strip_background_colors(str)","kind":2,"desc":"    * Removes background colors added by `get_background_escape_sequence`.","body":"strip_background_colors(${1:str})"},{"prefix":"strip_colors","token":"minetest","detail":"minetest.strip_colors(str)","kind":2,"desc":"    * Removes all color escape sequences.","body":"strip_colors(${1:str})"},{"prefix":"new","token":"vector","detail":"vector.new(a[, b, c])","kind":2,"desc":"    * Returns a vector.\n    * A copy of `a` if `a` is a vector.\n    * `{x = a, y = b, z = c}`, if all of `a`, `b`, `c` are defined numbers.","body":"new(${1:a}[, ${2:b}, ${3:c}])"},{"prefix":"direction","token":"vector","detail":"vector.direction(p1, p2)","kind":2,"desc":"    * Returns a vector of length 1 with direction `p1` to `p2`.\n    * If `p1` and `p2` are identical, returns `{x = 0, y = 0, z = 0}`.","body":"direction(${1:p1}, ${2:p2})"},{"prefix":"distance","token":"vector","detail":"vector.distance(p1, p2)","kind":2,"desc":"    * Returns zero or a positive number, the distance between `p1` and `p2`.","body":"distance(${1:p1}, ${2:p2})"},{"prefix":"length","token":"vector","detail":"vector.length(v)","kind":2,"desc":"    * Returns zero or a positive number, the length of vector `v`.","body":"length(${1:v})"},{"prefix":"normalize","token":"vector","detail":"vector.normalize(v)","kind":2,"desc":"    * Returns a vector of length 1 with direction of vector `v`.\n    * If `v` has zero length, returns `{x = 0, y = 0, z = 0}`.","body":"normalize(${1:v})"},{"prefix":"floor","token":"vector","detail":"vector.floor(v)","kind":2,"desc":"    * Returns a vector, each dimension rounded down.","body":"floor(${1:v})"},{"prefix":"round","token":"vector","detail":"vector.round(v)","kind":2,"desc":"    * Returns a vector, each dimension rounded to nearest integer.","body":"round(${1:v})"},{"prefix":"apply","token":"vector","detail":"vector.apply(v, func)","kind":2,"desc":"    * Returns a vector where the function `func` has been applied to each\n      component.","body":"apply(${1:v}, ${2:func})"},{"prefix":"equals","token":"vector","detail":"vector.equals(v1, v2)","kind":2,"desc":"    * Returns a boolean, `true` if the vectors are identical.","body":"equals(${1:v1}, ${2:v2})"},{"prefix":"sort","token":"vector","detail":"vector.sort(v1, v2)","kind":2,"desc":"    * Returns in order minp, maxp vectors of the cuboid defined by `v1`, `v2`.","body":"sort(${1:v1}, ${2:v2})"},{"prefix":"angle","token":"vector","detail":"vector.angle(v1, v2)","kind":2,"desc":"    * Returns the angle between `v1` and `v2` in radians.","body":"angle(${1:v1}, ${2:v2})"},{"prefix":"dot","token":"vector","detail":"vector.dot(v1, v2)","kind":2,"desc":"    * Returns the dot product of `v1` and `v2`","body":"dot(${1:v1}, ${2:v2})"},{"prefix":"cross","token":"vector","detail":"vector.cross(v1, v2)","kind":2,"desc":"    * Returns the cross product of `v1` and `v2`","body":"cross(${1:v1}, ${2:v2})"},{"prefix":"add","token":"vector","detail":"vector.add(v, x)","kind":2,"desc":"    * Returns a vector.\n    * If `x` is a vector: Returns the sum of `v` and `x`.\n    * If `x` is a number: Adds `x` to each component of `v`.","body":"add(${1:v}, ${2:x})"},{"prefix":"subtract","token":"vector","detail":"vector.subtract(v, x)","kind":2,"desc":"    * Returns a vector.\n    * If `x` is a vector: Returns the difference of `v` subtracted by `x`.\n    * If `x` is a number: Subtracts `x` from each component of `v`.","body":"subtract(${1:v}, ${2:x})"},{"prefix":"multiply","token":"vector","detail":"vector.multiply(v, x)","kind":2,"desc":"    * Returns a scaled vector or Schur product.","body":"multiply(${1:v}, ${2:x})"},{"prefix":"divide","token":"vector","detail":"vector.divide(v, x)","kind":2,"desc":"    * Returns a scaled vector or Schur quotient.","body":"divide(${1:v}, ${2:x})"},{"prefix":"dump2","detail":"dump2(obj, name, dumped)","kind":2,"desc":"returns a string which makes `obj`\n  human-readable, handles reference loops.\n    * `obj`: arbitrary variable\n    * `name`: string, default: `\"_\"`\n    * `dumped`: table, default: `{}`","body":"(${1:obj}, ${2:name}, ${3:dumped})"},{"prefix":"dump","detail":"dump(obj, dumped)","kind":2,"desc":"returns a string which makes `obj` human-readable\n    * `obj`: arbitrary variable\n    * `dumped`: table, default: `{}`","body":"(${1:obj}, ${2:dumped})"},{"prefix":"hypot","token":"math","detail":"math.hypot(x, y)","kind":2,"desc":"    * Get the hypotenuse of a triangle with legs x and y.\n      Useful for distance calculation.","body":"hypot(${1:x}, ${2:y})"},{"prefix":"sign","token":"math","detail":"math.sign(x, tolerance)","kind":2,"desc":"returns `-1`, `0` or `1`\n    * Get the sign of a number.\n    * tolerance: number, default: `0.0`\n    * If the absolute value of `x` is within the `tolerance` or `x` is NaN,\n      `0` is returned.","body":"sign(${1:x}, ${2:tolerance})"},{"prefix":"factorial","token":"math","detail":"math.factorial(x)","kind":2,"desc":"returns the factorial of `x`","body":"factorial(${1:x})"},{"prefix":"split","token":"string","detail":"string.split(str, separator, include_empty, max_splits, sep_is_pattern)","kind":2,"desc":"    * `separator`: string, default: `\",\"`\n    * `include_empty`: boolean, default: `false`\n    * `max_splits`: number, if it's negative, splits aren't limited,\n      default: `-1`\n    * `sep_is_pattern`: boolean, it specifies whether separator is a plain\n      string or a pattern (regex), default: `false`\n    * e.g. `\"a,b\":split\",\"` returns `{\"a\",\"b\"}`","body":"split(${1:str}, ${2:separator}, ${3:include_empty}, ${4:max_splits}, ${5:sep_is_pattern})"},{"prefix":"trim","token":":","detail":"string:trim()","kind":2,"desc":"returns the string without whitespace pre- and suffixes\n    * e.g. `\"\\n \\t\\tfoo bar\\t \":trim()` returns `\"foo bar\"`","body":":trim()"},{"prefix":"wrap_text","token":"minetest","detail":"minetest.wrap_text(str, limit, as_table)","kind":2,"desc":"returns a string or table\n    * Adds newlines to the string to keep it within the specified character\n      limit\n    * Note that the returned lines may be longer than the limit since it only\n      splits at word borders.\n    * `limit`: number, maximal amount of characters in one line\n    * `as_table`: boolean, if set to true, a table of lines instead of a string\n      is returned, default: `false`","body":"wrap_text(${1:str}, ${2:limit}, ${3:as_table})"},{"prefix":"pos_to_string","token":"minetest","detail":"minetest.pos_to_string(pos, decimal_places)","kind":2,"desc":"returns string `\\\"(X,Y,Z)\\\"`\n    * `pos`: table {x=X, y=Y, z=Z}\n    * Converts the position `pos` to a human-readable, printable string\n    * `decimal_places`: number, if specified, the x, y and z values of\n      the position are rounded to the given decimal place.","body":"pos_to_string(${1:pos}, ${2:decimal_places})"},{"prefix":"string_to_pos","token":"minetest","detail":"minetest.string_to_pos(string)","kind":2,"desc":"returns a position or `nil`\n    * Same but in reverse.\n    * If the string can't be parsed to a position, nothing is returned.","body":"string_to_pos(${1:string})"},{"prefix":"string_to_area","token":"minetest","detail":"minetest.string_to_area(\"(X1, Y1, Z1) (X2, Y2, Z2)\")","kind":2,"desc":"returns two positions\n    * Converts a string representing an area box into two positions","body":"string_to_area(\"(${1:X1}, ${2:Y1}, ${3:Z1})${4:}(${5:X2}, ${6:Y2}, ${7:Z2})\")"},{"prefix":"formspec_escape","token":"minetest","detail":"minetest.formspec_escape(string)","kind":2,"desc":"returns a string\n    * escapes the characters \"[\", \"]\", \"\\\", \",\" and \";\", which can not be used\n      in formspecs.","body":"formspec_escape(${1:string})"},{"prefix":"is_yes","token":"minetest","detail":"minetest.is_yes(arg)","kind":2,"desc":"    * returns true if passed 'y', 'yes', 'true' or a number that isn't zero.","body":"is_yes(${1:arg})"},{"prefix":"is_nan","token":"minetest","detail":"minetest.is_nan(arg)","kind":2,"desc":"    * returns true when the passed number represents NaN.","body":"is_nan(${1:arg})"},{"prefix":"get_us_time","token":"minetest","detail":"minetest.get_us_time()","kind":2,"desc":"    * returns time with microsecond precision. May not return wall time.","body":"get_us_time()"},{"prefix":"copy","token":"table","detail":"table.copy(table)","kind":2,"desc":"returns a table\n    * returns a deep copy of `table`","body":"copy(${1:table})"},{"prefix":"indexof","token":"table","detail":"table.indexof(list, val)","kind":2,"desc":"returns the smallest numerical index containing\n      the value `val` in the table `list`. Non-numerical indices are ignored.\n      If `val` could not be found, `-1` is returned. `list` must not have\n      negative indices.","body":"indexof(${1:list}, ${2:val})"},{"prefix":"insert_all","token":"table","detail":"table.insert_all(table, other_table)","kind":2,"desc":"    * Appends all values in `other_table` to `table` - uses `#table + 1` to\n      find new indices.","body":"insert_all(${1:table}, ${2:other_table})"},{"prefix":"pointed_thing_to_face_pos","token":"minetest","detail":"minetest.pointed_thing_to_face_pos(placer, pointed_thing)","kind":2,"desc":"returns a\n  position.\n    * returns the exact position on the surface of a pointed node","body":"pointed_thing_to_face_pos(${1:placer}, ${2:pointed_thing})"},{"prefix":"get_dig_params","token":"minetest","detail":"minetest.get_dig_params(groups, tool_capabilities)","kind":2,"desc":"Simulates a tool\n    that digs a node.\n    Returns a table with the following fields:\n    * `diggable`: `true` if node can be dug, `false` otherwise.\n    * `time`: Time it would take to dig the node.\n    * `wear`: How much wear would be added to the tool.\n    `time` and `wear` are meaningless if node's not diggable\n    Parameters:\n    * `groups`: Table of the node groups of the node that would be dug\n    * `tool_capabilities`: Tool capabilities table of the tool","body":"get_dig_params(${1:groups}, ${2:tool_capabilities})"},{"prefix":"get_hit_params","token":"minetest","detail":"minetest.get_hit_params(groups, tool_capabilities [, time_from_last_punch])","kind":2,"desc":"    Simulates an item that punches an object.\n    Returns a table with the following fields:\n    * `hp`: How much damage the punch would cause.\n    * `wear`: How much wear would be added to the tool.\n    Parameters:\n    * `groups`: Damage groups of the object\n    * `tool_capabilities`: Tool capabilities table of the item\n    * `time_from_last_punch`: time in seconds since last punch action","body":"get_hit_params(${1:groups}, ${2:tool_capabilities }[, ${3:time_from_last_punch}])"},{"prefix":"read_from_map","token":":","detail":"read_from_map(p1, p2)","kind":2,"desc":" Loads a chunk of map into the VoxelManip object\n  containing the region formed by `p1` and `p2`.\n    * returns actual emerged `pmin`, actual emerged `pmax`","body":"_from_map(${1:p1}, ${2:p2})"},{"prefix":"write_to_map","token":":","detail":"write_to_map([light])","kind":2,"desc":"Writes the data loaded from the `VoxelManip` back to\n  the map.\n    * **important**: data must be set using `VoxelManip:set_data()` before\n      calling this.\n    * if `light` is true, then lighting is automatically recalculated.\n      The default value is true.\n      If `light` is false, no light calculations happen, and you should correct\n      all modified blocks with `minetest.fix_light()` as soon as possible.\n      Keep in mind that modifying the map where light is incorrect can cause\n      more lighting bugs.","body":"_to_map([${1:light}])"},{"prefix":"get_node_at","token":":","detail":"get_node_at(pos)","kind":2,"desc":"Returns a `MapNode` table of the node currently loaded in\n  the `VoxelManip` at that position","body":"_node_at(${1:pos})"},{"prefix":"set_node_at","token":":","detail":"set_node_at(pos, node)","kind":2,"desc":"Sets a specific `MapNode` in the `VoxelManip` at\n  that position.","body":"_node_at(${1:pos}, ${2:node})"},{"prefix":"get_data","token":":","detail":"get_data([buffer])","kind":2,"desc":"Retrieves the node content data loaded into the\n  `VoxelManip` object.\n    * returns raw node data in the form of an array of node content IDs\n    * if the param `buffer` is present, this table will be used to store the\n      result instead.","body":"_data([${1:buffer}])"},{"prefix":"set_data","token":":","detail":"set_data(data)","kind":2,"desc":"Sets the data contents of the `VoxelManip` object","body":"_data(${1:data})"},{"prefix":"update_map","token":":","detail":"update_map()","kind":2,"desc":"Does nothing, kept for compatibility.","body":"_map()"},{"prefix":"set_lighting","token":":","detail":"set_lighting(light, [p1, p2])","kind":2,"desc":"Set the lighting within the `VoxelManip` to\n  a uniform value.\n    * `light` is a table, `{day=<0...15>, night=<0...15>}`\n    * To be used only by a `VoxelManip` object from\n      `minetest.get_mapgen_object`.\n    * (`p1`, `p2`) is the area in which lighting is set, defaults to the whole\n      area if left out.","body":"_lighting(${1:light}, ${2:}[${3:p1}, ${4:p2}])"},{"prefix":"get_light_data","token":":","detail":"get_light_data()","kind":2,"desc":"Gets the light data read into the `VoxelManip` object\n    * Returns an array (indices 1 to volume) of integers ranging from `0` to\n      `255`.\n    * Each value is the bitwise combination of day and night light values\n      (`0` to `15` each).\n    * `light = day + (night * 16)`","body":"_light_data()"},{"prefix":"set_light_data","token":":","detail":"set_light_data(light_data)","kind":2,"desc":"Sets the `param1` (light) contents of each node\n  in the `VoxelManip`.\n    * expects lighting data in the same format that `get_light_data()` returns","body":"_light_data(${1:light_data})"},{"prefix":"get_param2_data","token":":","detail":"get_param2_data([buffer])","kind":2,"desc":"Gets the raw `param2` data read into the\n  `VoxelManip` object.\n    * Returns an array (indices 1 to volume) of integers ranging from `0` to\n      `255`.\n    * If the param `buffer` is present, this table will be used to store the\n      result instead.","body":"_param2_data([${1:buffer}])"},{"prefix":"set_param2_data","token":":","detail":"set_param2_data(param2_data)","kind":2,"desc":"Sets the `param2` contents of each node in\n  the `VoxelManip`.","body":"_param2_data(${1:param2_data})"},{"prefix":"calc_lighting","token":":","detail":"calc_lighting([p1, p2], [propagate_shadow])","kind":2,"desc":" Calculate lighting within the\n  `VoxelManip`.\n    * To be used only by a `VoxelManip` object from\n      `minetest.get_mapgen_object`.\n    * (`p1`, `p2`) is the area in which lighting is set, defaults to the whole\n      area if left out or nil. For almost all uses these should be left out\n      or nil to use the default.\n    * `propagate_shadow` is an optional boolean deciding whether shadows in a\n      generated mapchunk above are propagated down into the mapchunk, defaults\n      to `true` if left out.","body":"_lighting([${1:p1}, ${2:p2}], ${3:}[${4:propagate_shadow}])"},{"prefix":"update_liquids","token":":","detail":"update_liquids()","kind":2,"desc":"Update liquid flow","body":"_liquids()"},{"prefix":"was_modified","token":":","detail":"was_modified()","kind":2,"desc":"Returns `true` or `false` if the data in the voxel\n  manipulator had been modified since the last read from map, due to a call to\n  `minetest.set_data()` on the loaded area elsewhere.","body":"_modified()"},{"prefix":"get_emerged_area","token":":","detail":"get_emerged_area()","kind":2,"desc":"Returns actual emerged minimum and maximum positions.","body":"_emerged_area()"},{"prefix":"on_activate","token":":","detail":"on_activate(self, staticdata, dtime_s)","kind":2,"desc":"    * Called when the object is instantiated.\n    * `dtime_s` is the time passed since the object was unloaded, which can be\n      used for updating the entity state.","body":"_activate(${1:self}, ${2:staticdata}, ${3:dtime_s})"},{"prefix":"on_step","token":":","detail":"on_step(self, dtime)","kind":2,"desc":"    * Called on every server tick, after movement and collision processing.\n      `dtime` is usually 0.1 seconds, as per the `dedicated_server_step` setting\n      in `minetest.conf`.","body":"_step(${1:self}, ${2:dtime})"},{"prefix":"on_punch","token":":","detail":"on_punch(self, puncher, time_from_last_punch, tool_capabilities, dir, damage)","kind":2,"desc":"    * Called when somebody punches the object.\n    * Note that you probably want to handle most punches using the automatic\n      armor group system.\n    * `puncher`: an `ObjectRef` (can be `nil`)\n    * `time_from_last_punch`: Meant for disallowing spamming of clicks\n      (can be `nil`).\n    * `tool_capabilities`: capability table of used tool (can be `nil`)\n    * `dir`: unit vector of direction of punch. Always defined. Points from the\n      puncher to the punched.\n    * `damage`: damage that will be done to entity.","body":"_punch(${1:self}, ${2:puncher}, ${3:time_from_last_punch}, ${4:tool_capabilities}, ${5:dir}, ${6:damage})"},{"prefix":"on_death","token":":","detail":"on_death(self, killer)","kind":2,"desc":"    * Called when the object dies.\n    * `killer`: an `ObjectRef` (can be `nil`)","body":"_death(${1:self}, ${2:killer})"},{"prefix":"on_rightclick","token":":","detail":"on_rightclick(self, clicker)","kind":2,"desc":"","body":"_rightclick(${1:self}, ${2:clicker})"},{"prefix":"on_attach_child","token":":","detail":"on_attach_child(self, child)","kind":2,"desc":"    * `child`: an `ObjectRef` of the child that attaches","body":"_attach_child(${1:self}, ${2:child})"},{"prefix":"on_detach_child","token":":","detail":"on_detach_child(self, child)","kind":2,"desc":"    * `child`: an `ObjectRef` of the child that detaches","body":"_detach_child(${1:self}, ${2:child})"},{"prefix":"on_detach","token":":","detail":"on_detach(self, parent)","kind":2,"desc":"    * `parent`: an `ObjectRef` (can be `nil`) from where it got detached\n    * This happens before the parent object is removed from the world","body":"_detach(${1:self}, ${2:parent})"},{"prefix":"get_staticdata","token":":","detail":"get_staticdata(self)","kind":2,"desc":"    * Should return a string that will be passed to `on_activate` when the\n      object is instantiated the next time.","body":"_staticdata(${1:self})"},{"prefix":"get_current_modname","token":"minetest","detail":"minetest.get_current_modname()","kind":2,"desc":"returns the currently loading mod's name,\n  when loading a mod.","body":"get_current_modname()"},{"prefix":"get_modpath","token":"minetest","detail":"minetest.get_modpath(modname)","kind":2,"desc":"returns e.g.\n  `\"/home/user/.minetest/usermods/modname\"`.\n    * Useful for loading additional `.lua` modules or static data from mod","body":"get_modpath(${1:modname})"},{"prefix":"get_modnames","token":"minetest","detail":"minetest.get_modnames()","kind":2,"desc":"returns a list of installed mods\n    * Return a list of installed mods, sorted alphabetically","body":"get_modnames()"},{"prefix":"get_worldpath","token":"minetest","detail":"minetest.get_worldpath()","kind":2,"desc":"returns e.g. `\\\"/home/user/.minetest/world\\\"`\n    * Useful for storing custom data","body":"get_worldpath()"},{"prefix":"is_singleplayer","token":"minetest","detail":"minetest.is_singleplayer()","kind":2,"desc":"* `minetest.features`: Table containing API feature flags","body":"is_singleplayer()"},{"prefix":"has_feature","token":"minetest","detail":"minetest.has_feature(arg)","kind":2,"desc":"returns `boolean, missing_features`\n    * `arg`: string or table in format `{foo=true, bar=true}`\n    * `missing_features`: `{foo=true, bar=true}`","body":"has_feature(${1:arg})"},{"prefix":"get_player_information","token":"minetest","detail":"minetest.get_player_information(player_name)","kind":2,"desc":"Table containing information\n  about a player. Example return value:","body":"get_player_information(${1:player_name})"},{"prefix":"mkdir","token":"minetest","detail":"minetest.mkdir(path)","kind":2,"desc":"returns success.\n    * Creates a directory specified by `path`, creating parent directories\n      if they don't exist.","body":"mkdir(${1:path})"},{"prefix":"get_dir_list","token":"minetest","detail":"minetest.get_dir_list(path, [is_dir])","kind":2,"desc":"returns list of entry names\n    * is_dir is one of:\n        * nil: return all entries,\n        * true: return only subdirectory names, or\n        * false: return only file names.","body":"get_dir_list(${1:path}, ${2:}[${3:is_dir}])"},{"prefix":"safe_file_write","token":"minetest","detail":"minetest.safe_file_write(path, content)","kind":2,"desc":"returns boolean indicating success\n    * Replaces contents of file at path with new contents in a safe (atomic)\n      way. Use this instead of below code when writing e.g. database files:\n      `local f = io.open(path, \"wb\"); f:write(content); f:close()`","body":"safe_file_write(${1:path}, ${2:content})"},{"prefix":"get_version","token":"minetest","detail":"minetest.get_version()","kind":2,"desc":"returns a table containing components of the\n   engine version.  Components:\n    * `project`: Name of the project, eg, \"Minetest\"\n    * `string`: Simple version, eg, \"1.2.3-dev\"\n    * `hash`: Full git version (only set if available),\n      eg, \"1.2.3-dev-01234567-dirty\".\n  Use this for informational purposes only. The information in the returned\n  table does not represent the capabilities of the engine, nor is it\n  reliable or verifiable. Compatible forks will have a different name and\n  version entirely. To check for the presence of engine features, test\n  whether the functions exported by the wanted features exist. For example:\n  `if minetest.check_for_falling then ... end`.","body":"get_version()"},{"prefix":"sha1","token":"minetest","detail":"minetest.sha1(data, [raw])","kind":2,"desc":"returns the sha1 hash of data\n    * `data`: string of data to hash\n    * `raw`: return raw bytes instead of hex digits, default: false","body":"sha1(${1:data}, ${2:}[${3:raw}])"},{"prefix":"debug","token":"minetest","detail":"minetest.debug(...)","kind":2,"desc":"    * Equivalent to `minetest.log(table.concat({...}, \"\\t\"))`","body":"debug(...)"},{"prefix":"log","token":"minetest","detail":"minetest.log([level,] text)","kind":2,"desc":"    * `level` is one of `\"none\"`, `\"error\"`, `\"warning\"`, `\"action\"`,\n      `\"info\"`, or `\"verbose\"`.  Default is `\"none\"`.","body":"log([${1:level}, ]${2:text})"},{"prefix":"register_node","token":"minetest","detail":"minetest.register_node(name, node definition)","kind":2,"desc":"","body":"register_node(${1:name}, ${2:node definition})"},{"prefix":"register_craftitem","token":"minetest","detail":"minetest.register_craftitem(name, item definition)","kind":2,"desc":"","body":"register_craftitem(${1:name}, ${2:item definition})"},{"prefix":"register_tool","token":"minetest","detail":"minetest.register_tool(name, item definition)","kind":2,"desc":"","body":"register_tool(${1:name}, ${2:item definition})"},{"prefix":"override_item","token":"minetest","detail":"minetest.override_item(name, redefinition)","kind":2,"desc":"    * Overrides fields of an item registered with register_node/tool/craftitem.\n    * Note: Item must already be defined, (opt)depend on the mod defining it.\n    * Example: `minetest.override_item(\"default:mese\",\n      {light_source=minetest.LIGHT_MAX})`","body":"override_item(${1:name}, ${2:redefinition})"},{"prefix":"unregister_item","token":"minetest","detail":"minetest.unregister_item(name)","kind":2,"desc":"    * Unregisters the item from the engine, and deletes the entry with key\n      `name` from `minetest.registered_items` and from the associated item table\n      according to its nature: `minetest.registered_nodes`, etc.","body":"unregister_item(${1:name})"},{"prefix":"register_entity","token":"minetest","detail":"minetest.register_entity(name, entity definition)","kind":2,"desc":"","body":"register_entity(${1:name}, ${2:entity definition})"},{"prefix":"register_abm","token":"minetest","detail":"minetest.register_abm(abm definition)","kind":2,"desc":"","body":"register_abm(${1:abm definition})"},{"prefix":"register_lbm","token":"minetest","detail":"minetest.register_lbm(lbm definition)","kind":2,"desc":"","body":"register_lbm(${1:lbm definition})"},{"prefix":"register_alias","token":"minetest","detail":"minetest.register_alias(alias, original_name)","kind":2,"desc":"    * Also use this to set the 'mapgen aliases' needed in a game for the core\n      mapgens. See [Mapgen aliases] section above.","body":"register_alias(${1:alias}, ${2:original_name})"},{"prefix":"register_alias_force","token":"minetest","detail":"minetest.register_alias_force(alias, original_name)","kind":2,"desc":"","body":"register_alias_force(${1:alias}, ${2:original_name})"},{"prefix":"register_ore","token":"minetest","detail":"minetest.register_ore(ore definition)","kind":2,"desc":"    * Returns an integer object handle uniquely identifying the registered\n      ore on success.\n    * The order of ore registrations determines the order of ore generation.","body":"register_ore(${1:ore definition})"},{"prefix":"register_biome","token":"minetest","detail":"minetest.register_biome(biome definition)","kind":2,"desc":"    * Returns an integer object handle uniquely identifying the registered\n      biome on success. To get the biome ID, use `minetest.get_biome_id`.","body":"register_biome(${1:biome definition})"},{"prefix":"unregister_biome","token":"minetest","detail":"minetest.unregister_biome(name)","kind":2,"desc":"    * Unregisters the biome from the engine, and deletes the entry with key\n      `name` from `minetest.registered_biomes`.","body":"unregister_biome(${1:name})"},{"prefix":"register_decoration","token":"minetest","detail":"minetest.register_decoration(decoration definition)","kind":2,"desc":"    * Returns an integer object handle uniquely identifying the registered\n      decoration on success. To get the decoration ID, use\n      `minetest.get_decoration_id`.\n    * The order of decoration registrations determines the order of decoration\n      generation.","body":"register_decoration(${1:decoration definition})"},{"prefix":"register_schematic","token":"minetest","detail":"minetest.register_schematic(schematic definition)","kind":2,"desc":"    * Returns an integer object handle uniquely identifying the registered\n      schematic on success.\n    * If the schematic is loaded from a file, the `name` field is set to the\n      filename.\n    * If the function is called when loading the mod, and `name` is a relative\n      path, then the current mod path will be prepended to the schematic\n      filename.","body":"register_schematic(${1:schematic definition})"},{"prefix":"clear_registered_ores","token":"minetest","detail":"minetest.clear_registered_ores()","kind":2,"desc":"    * Clears all ores currently registered.","body":"clear_registered_ores()"},{"prefix":"clear_registered_biomes","token":"minetest","detail":"minetest.clear_registered_biomes()","kind":2,"desc":"    * Clears all biomes currently registered.","body":"clear_registered_biomes()"},{"prefix":"clear_registered_decorations","token":"minetest","detail":"minetest.clear_registered_decorations()","kind":2,"desc":"    * Clears all decorations currently registered.","body":"clear_registered_decorations()"},{"prefix":"clear_registered_schematics","token":"minetest","detail":"minetest.clear_registered_schematics()","kind":2,"desc":"    * Clears all schematics currently registered.","body":"clear_registered_schematics()"},{"prefix":"register_craft","token":"minetest","detail":"minetest.register_craft(recipe)","kind":2,"desc":"    * Check recipe table syntax for different types below.","body":"register_craft(${1:recipe})"},{"prefix":"clear_craft","token":"minetest","detail":"minetest.clear_craft(recipe)","kind":2,"desc":"    * Will erase existing craft based either on output item or on input recipe.\n    * Specify either output or input only. If you specify both, input will be\n      ignored. For input use the same recipe table syntax as for\n      `minetest.register_craft(recipe)`. For output specify only the item,\n      without a quantity.\n    * Returns false if no erase candidate could be found, otherwise returns true.\n    * **Warning**! The type field (\"shaped\", \"cooking\" or any other) will be\n      ignored if the recipe contains output. Erasing is then done independently\n      from the crafting method.","body":"clear_craft(${1:recipe})"},{"prefix":"register_chatcommand","token":"minetest","detail":"minetest.register_chatcommand(cmd, chatcommand definition)","kind":2,"desc":"","body":"register_chatcommand(${1:cmd}, ${2:chatcommand definition})"},{"prefix":"override_chatcommand","token":"minetest","detail":"minetest.override_chatcommand(name, redefinition)","kind":2,"desc":"    * Overrides fields of a chatcommand registered with `register_chatcommand`.","body":"override_chatcommand(${1:name}, ${2:redefinition})"},{"prefix":"unregister_chatcommand","token":"minetest","detail":"minetest.unregister_chatcommand(name)","kind":2,"desc":"    * Unregisters a chatcommands registered with `register_chatcommand`.","body":"unregister_chatcommand(${1:name})"},{"prefix":"register_privilege","token":"minetest","detail":"minetest.register_privilege(name, definition)","kind":2,"desc":"    * `definition` can be a description or a definition table (see [Privilege\n      definition]).\n    * If it is a description, the priv will be granted to singleplayer and admin\n      by default.\n    * To allow players with `basic_privs` to grant, see the `basic_privs`\n      minetest.conf setting.","body":"register_privilege(${1:name}, ${2:definition})"},{"prefix":"register_authentication_handler","token":"minetest","detail":"minetest.register_authentication_handler(authentication handler definition)","kind":2,"desc":"    * Registers an auth handler that overrides the builtin one.\n    * This function can be called by a single mod once only.","body":"register_authentication_handler(${1:authentication handler definition})"},{"prefix":"register_globalstep","token":"minetest","detail":"minetest.register_globalstep(function(dtime))","kind":2,"desc":"    * Called every server step, usually interval of 0.1s","body":"register_globalstep(${1:function}(${2:dtime}))"},{"prefix":"register_on_mods_loaded","token":"minetest","detail":"minetest.register_on_mods_loaded(function())","kind":2,"desc":"    * Called after mods have finished loading and before the media is cached or the\n      aliases handled.","body":"register_on_mods_loaded(${1:function}())"},{"prefix":"register_on_shutdown","token":"minetest","detail":"minetest.register_on_shutdown(function())","kind":2,"desc":"    * Called before server shutdown\n    * **Warning**: If the server terminates abnormally (i.e. crashes), the\n      registered callbacks **will likely not be run**. Data should be saved at\n      semi-frequent intervals as well as on server shutdown.","body":"register_on_shutdown(${1:function}())"},{"prefix":"register_on_placenode","token":"minetest","detail":"minetest.register_on_placenode(function(pos, newnode, placer, oldnode, itemstack, pointed_thing))","kind":2,"desc":"    * Called when a node has been placed\n    * If return `true` no item is taken from `itemstack`\n    * `placer` may be any valid ObjectRef or nil.\n    * **Not recommended**; use `on_construct` or `after_place_node` in node\n      definition whenever possible.","body":"register_on_placenode(${1:function}(${2:pos}, ${3:newnode}, ${4:placer}, ${5:oldnode}, ${6:itemstack}, ${7:pointed_thing}))"},{"prefix":"register_on_dignode","token":"minetest","detail":"minetest.register_on_dignode(function(pos, oldnode, digger))","kind":2,"desc":"    * Called when a node has been dug.\n    * **Not recommended**; Use `on_destruct` or `after_dig_node` in node\n      definition whenever possible.","body":"register_on_dignode(${1:function}(${2:pos}, ${3:oldnode}, ${4:digger}))"},{"prefix":"register_on_punchnode","token":"minetest","detail":"minetest.register_on_punchnode(function(pos, node, puncher, pointed_thing))","kind":2,"desc":"    * Called when a node is punched","body":"register_on_punchnode(${1:function}(${2:pos}, ${3:node}, ${4:puncher}, ${5:pointed_thing}))"},{"prefix":"register_on_generated","token":"minetest","detail":"minetest.register_on_generated(function(minp, maxp, blockseed))","kind":2,"desc":"    * Called after generating a piece of world. Modifying nodes inside the area\n      is a bit faster than usually.","body":"register_on_generated(${1:function}(${2:minp}, ${3:maxp}, ${4:blockseed}))"},{"prefix":"register_on_newplayer","token":"minetest","detail":"minetest.register_on_newplayer(function(ObjectRef))","kind":2,"desc":"    * Called after a new player has been created","body":"register_on_newplayer(${1:function}(${2:ObjectRef}))"},{"prefix":"register_on_punchplayer","token":"minetest","detail":"minetest.register_on_punchplayer(function(player, hitter, time_from_last_punch, tool_capabilities, dir, damage))","kind":2,"desc":"    * Called when a player is punched\n    * Note: This callback is invoked even if the punched player is dead.\n    * `player`: ObjectRef - Player that was punched\n    * `hitter`: ObjectRef - Player that hit\n    * `time_from_last_punch`: Meant for disallowing spamming of clicks\n      (can be nil).\n    * `tool_capabilities`: Capability table of used tool (can be nil)\n    * `dir`: Unit vector of direction of punch. Always defined. Points from\n      the puncher to the punched.\n    * `damage`: Number that represents the damage calculated by the engine\n    * should return `true` to prevent the default damage mechanism","body":"register_on_punchplayer(${1:function}(${2:player}, ${3:hitter}, ${4:time_from_last_punch}, ${5:tool_capabilities}, ${6:dir}, ${7:damage}))"},{"prefix":"register_on_player_hpchange","token":"minetest","detail":"minetest.register_on_player_hpchange(function(player, hp_change, reason), modifier)","kind":2,"desc":"    * Called when the player gets damaged or healed\n    * `player`: ObjectRef of the player\n    * `hp_change`: the amount of change. Negative when it is damage.\n    * `reason`: a PlayerHPChangeReason table.\n        * The `type` field will have one of the following values:\n            * `set_hp`: A mod or the engine called `set_hp` without\n                        giving a type - use this for custom damage types.\n            * `punch`: Was punched. `reason.object` will hold the puncher, or nil if none.\n            * `fall`\n            * `node_damage`: `damage_per_second` from a neighbouring node.\n                             `reason.node` will hold the node name or nil.\n            * `drown`\n            * `respawn`\n        * Any of the above types may have additional fields from mods.\n        * `reason.from` will be `mod` or `engine`.\n    * `modifier`: when true, the function should return the actual `hp_change`.\n       Note: modifiers only get a temporary `hp_change` that can be modified by later modifiers.\n       Modifiers can return true as a second argument to stop the execution of further functions.\n       Non-modifiers receive the final HP change calculated by the modifiers.","body":"register_on_player_hpchange(${1:function}(${2:player}, ${3:hp_change}, ${4:reason}), ${5:modifier})"},{"prefix":"register_on_dieplayer","token":"minetest","detail":"minetest.register_on_dieplayer(function(ObjectRef, reason))","kind":2,"desc":"    * Called when a player dies\n    * `reason`: a PlayerHPChangeReason table, see register_on_player_hpchange","body":"register_on_dieplayer(${1:function}(${2:ObjectRef}, ${3:reason}))"},{"prefix":"register_on_respawnplayer","token":"minetest","detail":"minetest.register_on_respawnplayer(function(ObjectRef))","kind":2,"desc":"    * Called when player is to be respawned\n    * Called _before_ repositioning of player occurs\n    * return true in func to disable regular player placement","body":"register_on_respawnplayer(${1:function}(${2:ObjectRef}))"},{"prefix":"register_on_prejoinplayer","token":"minetest","detail":"minetest.register_on_prejoinplayer(function(name, ip))","kind":2,"desc":"    * Called before a player joins the game\n    * If it returns a string, the player is disconnected with that string as\n      reason.","body":"register_on_prejoinplayer(${1:function}(${2:name}, ${3:ip}))"},{"prefix":"register_on_joinplayer","token":"minetest","detail":"minetest.register_on_joinplayer(function(ObjectRef))","kind":2,"desc":"    * Called when a player joins the game","body":"register_on_joinplayer(${1:function}(${2:ObjectRef}))"},{"prefix":"register_on_leaveplayer","token":"minetest","detail":"minetest.register_on_leaveplayer(function(ObjectRef, timed_out))","kind":2,"desc":"    * Called when a player leaves the game\n    * `timed_out`: True for timeout, false for other reasons.","body":"register_on_leaveplayer(${1:function}(${2:ObjectRef}, ${3:timed_out}))"},{"prefix":"register_on_auth_fail","token":"minetest","detail":"minetest.register_on_auth_fail(function(name, ip))","kind":2,"desc":"    * Called when a client attempts to log into an account but supplies the\n      wrong password.\n    * `ip`: The IP address of the client.\n    * `name`: The account the client attempted to log into.","body":"register_on_auth_fail(${1:function}(${2:name}, ${3:ip}))"},{"prefix":"register_on_cheat","token":"minetest","detail":"minetest.register_on_cheat(function(ObjectRef, cheat))","kind":2,"desc":"    * Called when a player cheats\n    * `cheat`: `{type=<cheat_type>}`, where `<cheat_type>` is one of:\n        * `moved_too_fast`\n        * `interacted_too_far`\n        * `interacted_while_dead`\n        * `finished_unknown_dig`\n        * `dug_unbreakable`\n        * `dug_too_fast`","body":"register_on_cheat(${1:function}(${2:ObjectRef}, ${3:cheat}))"},{"prefix":"register_on_chat_message","token":"minetest","detail":"minetest.register_on_chat_message(function(name, message))","kind":2,"desc":"    * Called always when a player says something\n    * Return `true` to mark the message as handled, which means that it will\n      not be sent to other players.","body":"register_on_chat_message(${1:function}(${2:name}, ${3:message}))"},{"prefix":"register_on_player_receive_fields","token":"minetest","detail":"minetest.register_on_player_receive_fields(function(player, formname, fields))","kind":2,"desc":"    * Called when the server received input from `player` in a formspec with\n      the given `formname`. Specifically, this is called on any of the\n      following events:\n          * a button was pressed,\n          * Enter was pressed while the focus was on a text field\n          * a checkbox was toggled,\n          * something was selecteed in a drop-down list,\n          * a different tab was selected,\n          * selection was changed in a textlist or table,\n          * an entry was double-clicked in a textlist or table,\n          * a scrollbar was moved, or\n          * the form was actively closed by the player.\n    * Fields are sent for formspec elements which define a field. `fields`\n      is a table containing each formspecs element value (as string), with\n      the `name` parameter as index for each. The value depends on the\n      formspec element type:\n        * `button` and variants: If pressed, contains the user-facing button\n          text as value. If not pressed, is `nil`\n        * `field`, `textarea` and variants: Text in the field\n        * `dropdown`: Text of selected item\n        * `tabheader`: Tab index, starting with `\"1\"` (only if tab changed)\n        * `checkbox`: `\"true\"` if checked, `\"false\"` if unchecked\n        * `textlist`: See `minetest.explode_textlist_event`\n        * `table`: See `minetest.explode_table_event`\n        * `scrollbar`: See `minetest.explode_scrollbar_event`\n        * Special case: `[\"quit\"]=\"true\"` is sent when the user actively\n          closed the form by mouse click, keypress or through a button_exit[]\n          element.\n        * Special case: `[\"key_enter\"]=\"true\"` is sent when the user pressed\n          the Enter key and the focus was either nowhere (causing the formspec\n          to be closed) or on a button. If the focus was on a text field,\n          additionally, the index `key_enter_field` contains the name of the\n          text field. See also: `field_close_on_enter`.\n    * Newest functions are called first\n    * If function returns `true`, remaining functions are not called","body":"register_on_player_receive_fields(${1:function}(${2:player}, ${3:formname}, ${4:fields}))"},{"prefix":"register_on_craft","token":"minetest","detail":"minetest.register_on_craft(function(itemstack, player, old_craft_grid, craft_inv))","kind":2,"desc":"    * Called when `player` crafts something\n    * `itemstack` is the output\n    * `old_craft_grid` contains the recipe (Note: the one in the inventory is\n      cleared).\n    * `craft_inv` is the inventory with the crafting grid\n    * Return either an `ItemStack`, to replace the output, or `nil`, to not\n      modify it.","body":"register_on_craft(${1:function}(${2:itemstack}, ${3:player}, ${4:old_craft_grid}, ${5:craft_inv}))"},{"prefix":"register_craft_predict","token":"minetest","detail":"minetest.register_craft_predict(function(itemstack, player, old_craft_grid, craft_inv))","kind":2,"desc":"    * The same as before, except that it is called before the player crafts, to\n      make craft prediction, and it should not change anything.","body":"register_craft_predict(${1:function}(${2:itemstack}, ${3:player}, ${4:old_craft_grid}, ${5:craft_inv}))"},{"prefix":"register_allow_player_inventory_action","token":"minetest","detail":"minetest.register_allow_player_inventory_action(function(player, action, inventory, inventory_info))","kind":2,"desc":"    * Determinates how much of a stack may be taken, put or moved to a\n      player inventory.\n    * `player` (type `ObjectRef`) is the player who modified the inventory\n      `inventory` (type `InvRef`).\n    * List of possible `action` (string) values and their\n      `inventory_info` (table) contents:\n        * `move`: `{from_list=string, to_list=string, from_index=number, to_index=number, count=number}`\n        * `put`:  `{listname=string, index=number, stack=ItemStack}`\n        * `take`: Same as `put`\n    * Return a numeric value to limit the amount of items to be taken, put or\n      moved. A value of `-1` for `take` will make the source stack infinite.","body":"register_allow_player_inventory_action(${1:function}(${2:player}, ${3:action}, ${4:inventory}, ${5:inventory_info}))"},{"prefix":"register_on_player_inventory_action","token":"minetest","detail":"minetest.register_on_player_inventory_action(function(player, action, inventory, inventory_info))","kind":2,"desc":"    * Called after a take, put or move event from/to/in a player inventory\n    * Function arguments: see `minetest.register_allow_player_inventory_action`\n    * Does not accept or handle any return value.","body":"register_on_player_inventory_action(${1:function}(${2:player}, ${3:action}, ${4:inventory}, ${5:inventory_info}))"},{"prefix":"register_on_protection_violation","token":"minetest","detail":"minetest.register_on_protection_violation(function(pos, name))","kind":2,"desc":"    * Called by `builtin` and mods when a player violates protection at a\n      position (eg, digs a node or punches a protected entity).\n    * The registered functions can be called using\n      `minetest.record_protection_violation`.\n    * The provided function should check that the position is protected by the\n      mod calling this function before it prints a message, if it does, to\n      allow for multiple protection mods.","body":"register_on_protection_violation(${1:function}(${2:pos}, ${3:name}))"},{"prefix":"register_on_item_eat","token":"minetest","detail":"minetest.register_on_item_eat(function(hp_change, replace_with_item, itemstack, user, pointed_thing))","kind":2,"desc":"    * Called when an item is eaten, by `minetest.item_eat`\n    * Return `itemstack` to cancel the default item eat response (i.e.: hp increase).","body":"register_on_item_eat(${1:function}(${2:hp_change}, ${3:replace_with_item}, ${4:itemstack}, ${5:user}, ${6:pointed_thing}))"},{"prefix":"register_on_priv_grant","token":"minetest","detail":"minetest.register_on_priv_grant(function(name, granter, priv))","kind":2,"desc":"    * Called when `granter` grants the priv `priv` to `name`.\n    * Note that the callback will be called twice if it's done by a player,\n      once with granter being the player name, and again with granter being nil.","body":"register_on_priv_grant(${1:function}(${2:name}, ${3:granter}, ${4:priv}))"},{"prefix":"register_on_priv_revoke","token":"minetest","detail":"minetest.register_on_priv_revoke(function(name, revoker, priv))","kind":2,"desc":"    * Called when `revoker` revokes the priv `priv` from `name`.\n    * Note that the callback will be called twice if it's done by a player,\n      once with revoker being the player name, and again with revoker being nil.","body":"register_on_priv_revoke(${1:function}(${2:name}, ${3:revoker}, ${4:priv}))"},{"prefix":"register_can_bypass_userlimit","token":"minetest","detail":"minetest.register_can_bypass_userlimit(function(name, ip))","kind":2,"desc":"    * Called when `name` user connects with `ip`.\n    * Return `true` to by pass the player limit","body":"register_can_bypass_userlimit(${1:function}(${2:name}, ${3:ip}))"},{"prefix":"register_on_modchannel_message","token":"minetest","detail":"minetest.register_on_modchannel_message(function(channel_name, sender, message))","kind":2,"desc":"    * Called when an incoming mod channel message is received\n    * You should have joined some channels to receive events.\n    * If message comes from a server mod, `sender` field is an empty string.","body":"register_on_modchannel_message(${1:function}(${2:channel_name}, ${3:sender}, ${4:message}))"},{"prefix":"setting_get_pos","token":"minetest","detail":"minetest.setting_get_pos(name)","kind":2,"desc":"Loads a setting from the main settings and\n  parses it as a position (in the format `(1,2,3)`). Returns a position or nil.","body":"setting_get_pos(${1:name})"},{"prefix":"string_to_privs","token":"minetest","detail":"minetest.string_to_privs(str)","kind":2,"desc":"returns `{priv1=true,...}`","body":"string_to_privs(${1:str})"},{"prefix":"privs_to_string","token":"minetest","detail":"minetest.privs_to_string(privs)","kind":2,"desc":"returns `\\\"priv1,priv2,...\\\"`\n    * Convert between two privilege representations\n* `minetest.get_player_privs(name) -> {priv1=true,...}`","body":"privs_to_string(${1:privs})"},{"prefix":"check_player_privs","token":"minetest","detail":"minetest.check_player_privs(player_or_name, ...)","kind":2,"desc":"  returns `bool, missing_privs`\n    * A quickhand for checking privileges.\n    * `player_or_name`: Either a Player object or the name of a player.\n    * `...` is either a list of strings, e.g. `\"priva\", \"privb\"` or\n      a table, e.g. `{ priva = true, privb = true }`.","body":"check_player_privs(${1:player_or_name}, ${2:}...)"},{"prefix":"check_password_entry","token":"minetest","detail":"minetest.check_password_entry(name, entry, password)","kind":2,"desc":"    * Returns true if the \"password entry\" for a player with name matches given\n      password, false otherwise.\n    * The \"password entry\" is the password representation generated by the\n      engine as returned as part of a `get_auth()` call on the auth handler.\n    * Only use this function for making it possible to log in via password from\n      external protocols such as IRC, other uses are frowned upon.","body":"check_password_entry(${1:name}, ${2:entry}, ${3:password})"},{"prefix":"get_password_hash","token":"minetest","detail":"minetest.get_password_hash(name, raw_password)","kind":2,"desc":"    * Convert a name-password pair to a password hash that Minetest can use.\n    * The returned value alone is not a good basis for password checks based\n      on comparing the password hash in the database with the password hash\n      from the function, with an externally provided password, as the hash\n      in the db might use the new SRP verifier format.\n    * For this purpose, use `minetest.check_password_entry` instead.","body":"get_password_hash(${1:name}, ${2:raw_password})"},{"prefix":"get_player_ip","token":"minetest","detail":"minetest.get_player_ip(name)","kind":2,"desc":"returns an IP address string for the player\n  `name`.\n    * The player needs to be online for this to be successful.","body":"get_player_ip(${1:name})"},{"prefix":"get_auth_handler","token":"minetest","detail":"minetest.get_auth_handler()","kind":2,"desc":"Return the currently active auth handler\n    * See the [Authentication handler definition]\n    * Use this to e.g. get the authentication data for a player:\n      `local auth_data = minetest.get_auth_handler().get_auth(playername)`","body":"get_auth_handler()"},{"prefix":"notify_authentication_modified","token":"minetest","detail":"minetest.notify_authentication_modified(name)","kind":2,"desc":"    * Must be called by the authentication handler for privilege changes.\n    * `name`: string; if omitted, all auth data should be considered modified","body":"notify_authentication_modified(${1:name})"},{"prefix":"set_player_password","token":"minetest","detail":"minetest.set_player_password(name, password_hash)","kind":2,"desc":"Set password hash of\n  player `name`.","body":"set_player_password(${1:name}, ${2:password_hash})"},{"prefix":"set_player_privs","token":"minetest","detail":"minetest.set_player_privs(name, {priv1=true,...})","kind":2,"desc":"Set privileges of player\n  `name`.","body":"set_player_privs(${1:name}, ${2:}{${3:priv1}=${4:true}, ...})"},{"prefix":"auth_reload","token":"minetest","detail":"minetest.auth_reload()","kind":2,"desc":"    * See `reload()` in authentication handler definition","body":"auth_reload()"},{"prefix":"chat_send_all","token":"minetest","detail":"minetest.chat_send_all(text)","kind":2,"desc":"","body":"chat_send_all(${1:text})"},{"prefix":"chat_send_player","token":"minetest","detail":"minetest.chat_send_player(name, text)","kind":2,"desc":"","body":"chat_send_player(${1:name}, ${2:text})"},{"prefix":"format_chat_message","token":"minetest","detail":"minetest.format_chat_message(name, message)","kind":2,"desc":"    * Used by the server to format a chat message, based on the setting `chat_message_format`.\n      Refer to the documentation of the setting for a list of valid placeholders.\n    * Takes player name and message, and returns the formatted string to be sent to players.\n    * Can be redefined by mods if required, for things like colored names or messages.\n    * **Only** the first occurrence of each placeholder will be replaced.","body":"format_chat_message(${1:name}, ${2:message})"},{"prefix":"set_node","token":"minetest","detail":"minetest.set_node(pos, node)","kind":2,"desc":"","body":"set_node(${1:pos}, ${2:node})"},{"prefix":"add_node","token":"minetest","detail":"minetest.add_node(pos, node)","kind":2,"desc":"alias to `minetest.set_node`\n    * Set node at position `pos`\n    * `node`: table `{name=string, param1=number, param2=number}`\n    * If param1 or param2 is omitted, it's set to `0`.\n    * e.g. `minetest.set_node({x=0, y=10, z=0}, {name=\"default:wood\"})`","body":"add_node(${1:pos}, ${2:node})"},{"prefix":"bulk_set_node","token":"minetest","detail":"minetest.bulk_set_node({pos1, pos2, pos3, ...}, node)","kind":2,"desc":"    * Set node on all positions set in the first argument.\n    * e.g. `minetest.bulk_set_node({{x=0, y=1, z=1}, {x=1, y=2, z=2}}, {name=\"default:stone\"})`\n    * For node specification or position syntax see `minetest.set_node` call\n    * Faster than set_node due to single call, but still considerably slower\n      than Lua Voxel Manipulators (LVM) for large numbers of nodes.\n      Unlike LVMs, this will call node callbacks. It also allows setting nodes\n      in spread out positions which would cause LVMs to waste memory.\n      For setting a cube, this is 1.3x faster than set_node whereas LVM is 20\n      times faster.","body":"bulk_set_node({${1:pos1}, ${2:pos2}, ${3:pos3}, ${4:}...}, ${5:node})"},{"prefix":"swap_node","token":"minetest","detail":"minetest.swap_node(pos, node)","kind":2,"desc":"    * Set node at position, but don't remove metadata","body":"swap_node(${1:pos}, ${2:node})"},{"prefix":"remove_node","token":"minetest","detail":"minetest.remove_node(pos)","kind":2,"desc":"    * By default it does the same as `minetest.set_node(pos, {name=\"air\"})`","body":"remove_node(${1:pos})"},{"prefix":"get_node","token":"minetest","detail":"minetest.get_node(pos)","kind":2,"desc":"    * Returns the node at the given position as table in the format\n      `{name=\"node_name\", param1=0, param2=0}`,\n      returns `{name=\"ignore\", param1=0, param2=0}` for unloaded areas.","body":"get_node(${1:pos})"},{"prefix":"get_node_or_nil","token":"minetest","detail":"minetest.get_node_or_nil(pos)","kind":2,"desc":"    * Same as `get_node` but returns `nil` for unloaded areas.","body":"get_node_or_nil(${1:pos})"},{"prefix":"get_node_light","token":"minetest","detail":"minetest.get_node_light(pos, timeofday)","kind":2,"desc":"    * Gets the light value at the given position. Note that the light value\n      \"inside\" the node at the given position is returned, so you usually want\n      to get the light value of a neighbor.\n    * `pos`: The position where to measure the light.\n    * `timeofday`: `nil` for current time, `0` for night, `0.5` for day\n    * Returns a number between `0` and `15` or `nil`","body":"get_node_light(${1:pos}, ${2:timeofday})"},{"prefix":"place_node","token":"minetest","detail":"minetest.place_node(pos, node)","kind":2,"desc":"    * Place node with the same effects that a player would cause","body":"place_node(${1:pos}, ${2:node})"},{"prefix":"dig_node","token":"minetest","detail":"minetest.dig_node(pos)","kind":2,"desc":"    * Dig node with the same effects that a player would cause\n    * Returns `true` if successful, `false` on failure (e.g. protected location)","body":"dig_node(${1:pos})"},{"prefix":"punch_node","token":"minetest","detail":"minetest.punch_node(pos)","kind":2,"desc":"    * Punch node with the same effects that a player would cause","body":"punch_node(${1:pos})"},{"prefix":"spawn_falling_node","token":"minetest","detail":"minetest.spawn_falling_node(pos)","kind":2,"desc":"    * Change node into falling node\n    * Returns `true` if successful, `false` on failure","body":"spawn_falling_node(${1:pos})"},{"prefix":"find_nodes_with_meta","token":"minetest","detail":"minetest.find_nodes_with_meta(pos1, pos2)","kind":2,"desc":"    * Get a table of positions of nodes that have metadata within a region\n      {pos1, pos2}.","body":"find_nodes_with_meta(${1:pos1}, ${2:pos2})"},{"prefix":"get_meta","token":"minetest","detail":"minetest.get_meta(pos)","kind":2,"desc":"    * Get a `NodeMetaRef` at that position","body":"get_meta(${1:pos})"},{"prefix":"get_node_timer","token":"minetest","detail":"minetest.get_node_timer(pos)","kind":2,"desc":"    * Get `NodeTimerRef`","body":"get_node_timer(${1:pos})"},{"prefix":"add_entity","token":"minetest","detail":"minetest.add_entity(pos, name, [staticdata])","kind":2,"desc":"Spawn Lua-defined entity at\n  position.\n    * Returns `ObjectRef`, or `nil` if failed","body":"add_entity(${1:pos}, ${2:name}, ${3:}[${4:staticdata}])"},{"prefix":"add_item","token":"minetest","detail":"minetest.add_item(pos, item)","kind":2,"desc":"Spawn item\n    * Returns `ObjectRef`, or `nil` if failed","body":"add_item(${1:pos}, ${2:item})"},{"prefix":"get_player_by_name","token":"minetest","detail":"minetest.get_player_by_name(name)","kind":2,"desc":"Get an `ObjectRef` to a player","body":"get_player_by_name(${1:name})"},{"prefix":"get_objects_inside_radius","token":"minetest","detail":"minetest.get_objects_inside_radius(pos, radius)","kind":2,"desc":"returns a list of\n  ObjectRefs.\n    * `radius`: using an euclidean metric","body":"get_objects_inside_radius(${1:pos}, ${2:radius})"},{"prefix":"set_timeofday","token":"minetest","detail":"minetest.set_timeofday(val)","kind":2,"desc":"    * `val` is between `0` and `1`; `0` for midnight, `0.5` for midday","body":"set_timeofday(${1:val})"},{"prefix":"get_timeofday","token":"minetest","detail":"minetest.get_timeofday()","kind":2,"desc":"","body":"get_timeofday()"},{"prefix":"get_gametime","token":"minetest","detail":"minetest.get_gametime()","kind":2,"desc":"returns the time, in seconds, since the world was\n  created.","body":"get_gametime()"},{"prefix":"get_day_count","token":"minetest","detail":"minetest.get_day_count()","kind":2,"desc":"returns number days elapsed since world was\n  created.\n    * accounts for time changes.","body":"get_day_count()"},{"prefix":"find_node_near","token":"minetest","detail":"minetest.find_node_near(pos, radius, nodenames, [search_center])","kind":2,"desc":"returns\n  pos or `nil`.\n    * `radius`: using a maximum metric\n    * `nodenames`: e.g. `{\"ignore\", \"group:tree\"}` or `\"default:dirt\"`\n    * `search_center` is an optional boolean (default: `false`)\n      If true `pos` is also checked for the nodes","body":"find_node_near(${1:pos}, ${2:radius}, ${3:nodenames}, ${4:}[${5:search_center}])"},{"prefix":"find_nodes_in_area","token":"minetest","detail":"minetest.find_nodes_in_area(pos1, pos2, nodenames)","kind":2,"desc":"returns a list of\n  positions.\n    * `nodenames`: e.g. `{\"ignore\", \"group:tree\"}` or `\"default:dirt\"`\n    * First return value: Table with all node positions\n    * Second return value: Table with the count of each node with the node name\n      as index.\n    * Area volume is limited to 4,096,000 nodes","body":"find_nodes_in_area(${1:pos1}, ${2:pos2}, ${3:nodenames})"},{"prefix":"find_nodes_in_area_under_air","token":"minetest","detail":"minetest.find_nodes_in_area_under_air(pos1, pos2, nodenames)","kind":2,"desc":"returns a\n  list of positions.\n    * `nodenames`: e.g. `{\"ignore\", \"group:tree\"}` or `\"default:dirt\"`\n    * Return value: Table with all node positions with a node air above\n    * Area volume is limited to 4,096,000 nodes","body":"find_nodes_in_area_under_air(${1:pos1}, ${2:pos2}, ${3:nodenames})"},{"prefix":"get_perlin","token":"minetest","detail":"minetest.get_perlin(noiseparams)","kind":2,"desc":"","body":"get_perlin(${1:noiseparams})"},{"prefix":"get_perlin","token":"minetest","detail":"minetest.get_perlin(seeddiff, octaves, persistence, spread)","kind":2,"desc":"    * Return world-specific perlin noise (`int(worldseed)+seeddiff`)","body":"get_perlin(${1:seeddiff}, ${2:octaves}, ${3:persistence}, ${4:spread})"},{"prefix":"get_voxel_manip","token":"minetest","detail":"minetest.get_voxel_manip([pos1, pos2])","kind":2,"desc":"    * Return voxel manipulator object.\n    * Loads the manipulator from the map if positions are passed.","body":"get_voxel_manip([${1:pos1}, ${2:pos2}])"},{"prefix":"set_gen_notify","token":"minetest","detail":"minetest.set_gen_notify(flags, {deco_ids})","kind":2,"desc":"    * Set the types of on-generate notifications that should be collected.\n    * `flags` is a flag field with the available flags:\n        * dungeon\n        * temple\n        * cave_begin\n        * cave_end\n        * large_cave_begin\n        * large_cave_end\n        * decoration\n    * The second parameter is a list of IDs of decorations which notification\n      is requested for.","body":"set_gen_notify(${1:flags}, ${2:}{${3:deco_ids}})"},{"prefix":"get_gen_notify","token":"minetest","detail":"minetest.get_gen_notify()","kind":2,"desc":"    * Returns a flagstring and a table with the `deco_id`s.","body":"get_gen_notify()"},{"prefix":"get_decoration_id","token":"minetest","detail":"minetest.get_decoration_id(decoration_name)","kind":2,"desc":"    * Returns the decoration ID number for the provided decoration name string,\n      or `nil` on failure.","body":"get_decoration_id(${1:decoration_name})"},{"prefix":"get_mapgen_object","token":"minetest","detail":"minetest.get_mapgen_object(objectname)","kind":2,"desc":"    * Return requested mapgen object if available (see [Mapgen objects])","body":"get_mapgen_object(${1:objectname})"},{"prefix":"get_heat","token":"minetest","detail":"minetest.get_heat(pos)","kind":2,"desc":"    * Returns the heat at the position, or `nil` on failure.","body":"get_heat(${1:pos})"},{"prefix":"get_humidity","token":"minetest","detail":"minetest.get_humidity(pos)","kind":2,"desc":"    * Returns the humidity at the position, or `nil` on failure.","body":"get_humidity(${1:pos})"},{"prefix":"get_biome_data","token":"minetest","detail":"minetest.get_biome_data(pos)","kind":2,"desc":"    * Returns a table containing:\n        * `biome` the biome id of the biome at that position\n        * `heat` the heat at the position\n        * `humidity` the humidity at the position\n    * Or returns `nil` on failure.","body":"get_biome_data(${1:pos})"},{"prefix":"get_biome_id","token":"minetest","detail":"minetest.get_biome_id(biome_name)","kind":2,"desc":"    * Returns the biome id, as used in the biomemap Mapgen object and returned\n      by `minetest.get_biome_data(pos)`, for a given biome_name string.","body":"get_biome_id(${1:biome_name})"},{"prefix":"get_biome_name","token":"minetest","detail":"minetest.get_biome_name(biome_id)","kind":2,"desc":"    * Returns the biome name string for the provided biome id, or `nil` on\n      failure.\n    * If no biomes have been registered, such as in mgv6, returns `default`.","body":"get_biome_name(${1:biome_id})"},{"prefix":"get_mapgen_params","token":"minetest","detail":"minetest.get_mapgen_params()","kind":2,"desc":"    * Deprecated: use `minetest.get_mapgen_setting(name)` instead.\n    * Returns a table containing:\n        * `mgname`\n        * `seed`\n        * `chunksize`\n        * `water_level`\n        * `flags`","body":"get_mapgen_params()"},{"prefix":"set_mapgen_params","token":"minetest","detail":"minetest.set_mapgen_params(MapgenParams)","kind":2,"desc":"    * Deprecated: use `minetest.set_mapgen_setting(name, value, override)`\n      instead.\n    * Set map generation parameters.\n    * Function cannot be called after the registration period; only\n      initialization and `on_mapgen_init`.\n    * Takes a table as an argument with the fields:\n        * `mgname`\n        * `seed`\n        * `chunksize`\n        * `water_level`\n        * `flags`\n    * Leave field unset to leave that parameter unchanged.\n    * `flags` contains a comma-delimited string of flags to set, or if the\n      prefix `\"no\"` is attached, clears instead.\n    * `flags` is in the same format and has the same options as `mg_flags` in\n      `minetest.conf`.","body":"set_mapgen_params(${1:MapgenParams})"},{"prefix":"get_mapgen_setting","token":"minetest","detail":"minetest.get_mapgen_setting(name)","kind":2,"desc":"    * Gets the *active* mapgen setting (or nil if none exists) in string\n      format with the following order of precedence:\n        1) Settings loaded from map_meta.txt or overrides set during mod\n           execution.\n        2) Settings set by mods without a metafile override\n        3) Settings explicitly set in the user config file, minetest.conf\n        4) Settings set as the user config default","body":"get_mapgen_setting(${1:name})"},{"prefix":"get_mapgen_setting_noiseparams","token":"minetest","detail":"minetest.get_mapgen_setting_noiseparams(name)","kind":2,"desc":"    * Same as above, but returns the value as a NoiseParams table if the\n      setting `name` exists and is a valid NoiseParams.","body":"get_mapgen_setting_noiseparams(${1:name})"},{"prefix":"set_mapgen_setting","token":"minetest","detail":"minetest.set_mapgen_setting(name, value, [override_meta])","kind":2,"desc":"    * Sets a mapgen param to `value`, and will take effect if the corresponding\n      mapgen setting is not already present in map_meta.txt.\n    * `override_meta` is an optional boolean (default: `false`). If this is set\n      to true, the setting will become the active setting regardless of the map\n      metafile contents.\n    * Note: to set the seed, use `\"seed\"`, not `\"fixed_map_seed\"`.","body":"set_mapgen_setting(${1:name}, ${2:value}, ${3:}[${4:override_meta}])"},{"prefix":"set_mapgen_setting_noiseparams","token":"minetest","detail":"minetest.set_mapgen_setting_noiseparams(name, value, [override_meta])","kind":2,"desc":"    * Same as above, except value is a NoiseParams table.","body":"set_mapgen_setting_noiseparams(${1:name}, ${2:value}, ${3:}[${4:override_meta}])"},{"prefix":"set_noiseparams","token":"minetest","detail":"minetest.set_noiseparams(name, noiseparams, set_default)","kind":2,"desc":"    * Sets the noiseparams setting of `name` to the noiseparams table specified\n      in `noiseparams`.\n    * `set_default` is an optional boolean (default: `true`) that specifies\n      whether the setting should be applied to the default config or current\n      active config.","body":"set_noiseparams(${1:name}, ${2:noiseparams}, ${3:set_default})"},{"prefix":"get_noiseparams","token":"minetest","detail":"minetest.get_noiseparams(name)","kind":2,"desc":"    * Returns a table of the noiseparams for name.","body":"get_noiseparams(${1:name})"},{"prefix":"generate_ores","token":"minetest","detail":"minetest.generate_ores(vm, pos1, pos2)","kind":2,"desc":"    * Generate all registered ores within the VoxelManip `vm` and in the area\n      from `pos1` to `pos2`.\n    * `pos1` and `pos2` are optional and default to mapchunk minp and maxp.","body":"generate_ores(${1:vm}, ${2:pos1}, ${3:pos2})"},{"prefix":"generate_decorations","token":"minetest","detail":"minetest.generate_decorations(vm, pos1, pos2)","kind":2,"desc":"    * Generate all registered decorations within the VoxelManip `vm` and in the\n      area from `pos1` to `pos2`.\n    * `pos1` and `pos2` are optional and default to mapchunk minp and maxp.","body":"generate_decorations(${1:vm}, ${2:pos1}, ${3:pos2})"},{"prefix":"clear_objects","token":"minetest","detail":"minetest.clear_objects([options])","kind":2,"desc":"    * Clear all objects in the environment\n    * Takes an optional table as an argument with the field `mode`.\n        * mode = `\"full\"` : Load and go through every mapblock, clearing\n                            objects (default).\n        * mode = `\"quick\"`: Clear objects immediately in loaded mapblocks,\n                            clear objects in unloaded mapblocks only when the\n                            mapblocks are next activated.","body":"clear_objects([${1:options}])"},{"prefix":"load_area","token":"minetest","detail":"minetest.load_area(pos1[, pos2])","kind":2,"desc":"    * Load the mapblocks containing the area from `pos1` to `pos2`.\n      `pos2` defaults to `pos1` if not specified.\n    * This function does not trigger map generation.","body":"load_area(${1:pos1}[, ${2:pos2}])"},{"prefix":"emerge_area","token":"minetest","detail":"minetest.emerge_area(pos1, pos2, [callback], [param])","kind":2,"desc":"    * Queue all blocks in the area from `pos1` to `pos2`, inclusive, to be\n      asynchronously fetched from memory, loaded from disk, or if inexistent,\n      generates them.\n    * If `callback` is a valid Lua function, this will be called for each block\n      emerged.\n    * The function signature of callback is:\n      `function EmergeAreaCallback(blockpos, action, calls_remaining, param)`\n        * `blockpos` is the *block* coordinates of the block that had been\n          emerged.\n        * `action` could be one of the following constant values:\n            * `minetest.EMERGE_CANCELLED`\n            * `minetest.EMERGE_ERRORED`\n            * `minetest.EMERGE_FROM_MEMORY`\n            * `minetest.EMERGE_FROM_DISK`\n            * `minetest.EMERGE_GENERATED`\n        * `calls_remaining` is the number of callbacks to be expected after\n          this one.\n        * `param` is the user-defined parameter passed to emerge_area (or\n          nil if the parameter was absent).","body":"emerge_area(${1:pos1}, ${2:pos2}, ${3:}[${4:callback}], ${5:}[${6:param}])"},{"prefix":"delete_area","token":"minetest","detail":"minetest.delete_area(pos1, pos2)","kind":2,"desc":"    * delete all mapblocks in the area from pos1 to pos2, inclusive","body":"delete_area(${1:pos1}, ${2:pos2})"},{"prefix":"line_of_sight","token":"minetest","detail":"minetest.line_of_sight(pos1, pos2)","kind":2,"desc":"returns `boolean, pos`\n    * Checks if there is anything other than air between pos1 and pos2.\n    * Returns false if something is blocking the sight.\n    * Returns the position of the blocking node when `false`\n    * `pos1`: First position\n    * `pos2`: Second position","body":"line_of_sight(${1:pos1}, ${2:pos2})"},{"prefix":"raycast","token":"minetest","detail":"minetest.raycast(pos1, pos2, objects, liquids)","kind":2,"desc":"returns `Raycast`\n    * Creates a `Raycast` object.\n    * `pos1`: start of the ray\n    * `pos2`: end of the ray\n    * `objects`: if false, only nodes will be returned. Default is `true`.\n    * `liquids`: if false, liquid nodes won't be returned. Default is `false`.","body":"raycast(${1:pos1}, ${2:pos2}, ${3:objects}, ${4:liquids})"},{"prefix":"find_path","token":"minetest","detail":"minetest.find_path(pos1,pos2,searchdistance,max_jump,max_drop,algorithm)","kind":2,"desc":"    * returns table containing path\n    * returns a table of 3D points representing a path from `pos1` to `pos2` or\n      `nil`.\n    * `pos1`: start position\n    * `pos2`: end position\n    * `searchdistance`: number of blocks to search in each direction using a\n      maximum metric.\n    * `max_jump`: maximum height difference to consider walkable\n    * `max_drop`: maximum height difference to consider droppable\n    * `algorithm`: One of `\"A*_noprefetch\"` (default), `\"A*\"`, `\"Dijkstra\"`","body":"find_path(${1:pos1}, ${2:pos2}, ${3:searchdistance}, ${4:max_jump}, ${5:max_drop}, ${6:algorithm})"},{"token":"minetest","detail":"minetest.spawn_tree (pos, {treedef})","kind":2,"desc":"    * spawns L-system tree at given `pos` with definition in `treedef` table","body":"spawn_tree (${1:pos}, ${2:}{${3:treedef}})"},{"prefix":"transforming_liquid_add","token":"minetest","detail":"minetest.transforming_liquid_add(pos)","kind":2,"desc":"    * add node to liquid update queue","body":"transforming_liquid_add(${1:pos})"},{"prefix":"get_node_max_level","token":"minetest","detail":"minetest.get_node_max_level(pos)","kind":2,"desc":"    * get max available level for leveled node","body":"get_node_max_level(${1:pos})"},{"prefix":"get_node_level","token":"minetest","detail":"minetest.get_node_level(pos)","kind":2,"desc":"    * get level of leveled node (water, snow)","body":"get_node_level(${1:pos})"},{"prefix":"set_node_level","token":"minetest","detail":"minetest.set_node_level(pos, level)","kind":2,"desc":"    * set level of leveled node, default `level` equals `1`\n    * if `totallevel > maxlevel`, returns rest (`total-max`).","body":"set_node_level(${1:pos}, ${2:level})"},{"prefix":"add_node_level","token":"minetest","detail":"minetest.add_node_level(pos, level)","kind":2,"desc":"    * increase level of leveled node by level, default `level` equals `1`\n    * if `totallevel > maxlevel`, returns rest (`total-max`)\n    * can be negative for decreasing","body":"add_node_level(${1:pos}, ${2:level})"},{"prefix":"fix_light","token":"minetest","detail":"minetest.fix_light(pos1, pos2)","kind":2,"desc":"returns `true`/`false`\n    * resets the light in a cuboid-shaped part of\n      the map and removes lighting bugs.\n    * Loads the area if it is not loaded.\n    * `pos1` is the corner of the cuboid with the least coordinates\n      (in node coordinates), inclusive.\n    * `pos2` is the opposite corner of the cuboid, inclusive.\n    * The actual updated cuboid might be larger than the specified one,\n      because only whole map blocks can be updated.\n      The actual updated area consists of those map blocks that intersect\n      with the given cuboid.\n    * However, the neighborhood of the updated area might change\n      as well, as light can spread out of the cuboid, also light\n      might be removed.\n    * returns `false` if the area is not fully generated,\n      `true` otherwise","body":"fix_light(${1:pos1}, ${2:pos2})"},{"prefix":"check_single_for_falling","token":"minetest","detail":"minetest.check_single_for_falling(pos)","kind":2,"desc":"    * causes an unsupported `group:falling_node` node to fall and causes an\n      unattached `group:attached_node` node to fall.\n    * does not spread these updates to neighbours.","body":"check_single_for_falling(${1:pos})"},{"prefix":"check_for_falling","token":"minetest","detail":"minetest.check_for_falling(pos)","kind":2,"desc":"    * causes an unsupported `group:falling_node` node to fall and causes an\n      unattached `group:attached_node` node to fall.\n    * spread these updates to neighbours and can cause a cascade\n      of nodes to fall.","body":"check_for_falling(${1:pos})"},{"prefix":"get_spawn_level","token":"minetest","detail":"minetest.get_spawn_level(x, z)","kind":2,"desc":"    * Returns a player spawn y co-ordinate for the provided (x, z)\n      co-ordinates, or `nil` for an unsuitable spawn point.\n    * For most mapgens a 'suitable spawn point' is one with y between\n      `water_level` and `water_level + 16`, and in mgv7 well away from rivers,\n      so `nil` will be returned for many (x, z) co-ordinates.\n    * The spawn level returned is for a player spawn in unmodified terrain.\n    * The spawn level is intentionally above terrain level to cope with\n      full-node biome 'dust' nodes.","body":"get_spawn_level(${1:x}, ${2:z})"},{"prefix":"mod_channel_join","token":"minetest","detail":"minetest.mod_channel_join(channel_name)","kind":2,"desc":"    * Server joins channel `channel_name`, and creates it if necessary. You\n      should listen for incoming messages with\n      `minetest.register_on_modchannel_message`","body":"mod_channel_join(${1:channel_name})"},{"prefix":"create_detached_inventory","token":"minetest","detail":"minetest.create_detached_inventory(name, callbacks, [player_name])","kind":2,"desc":"returns\n  an `InvRef`.\n    * `callbacks`: See [Detached inventory callbacks]\n    * `player_name`: Make detached inventory available to one player\n      exclusively, by default they will be sent to every player (even if not\n      used).\n      Note that this parameter is mostly just a workaround and will be removed\n      in future releases.\n    * Creates a detached inventory. If it already exists, it is cleared.","body":"create_detached_inventory(${1:name}, ${2:callbacks}, ${3:}[${4:player_name}])"},{"prefix":"remove_detached_inventory","token":"minetest","detail":"minetest.remove_detached_inventory(name)","kind":2,"desc":"    * Returns a `boolean` indicating whether the removal succeeded.","body":"remove_detached_inventory(${1:name})"},{"prefix":"do_item_eat","token":"minetest","detail":"minetest.do_item_eat(hp_change, replace_with_item, itemstack, user, pointed_thing)","kind":2,"desc":"  returns left over ItemStack.\n    * See `minetest.item_eat` and `minetest.register_on_item_eat`","body":"do_item_eat(${1:hp_change}, ${2:replace_with_item}, ${3:itemstack}, ${4:user}, ${5:pointed_thing})"},{"prefix":"show_formspec","token":"minetest","detail":"minetest.show_formspec(playername, formname, formspec)","kind":2,"desc":"    * `playername`: name of player to show formspec\n    * `formname`: name passed to `on_player_receive_fields` callbacks.\n      It should follow the `\"modname:<whatever>\"` naming convention\n    * `formspec`: formspec to display","body":"show_formspec(${1:playername}, ${2:formname}, ${3:formspec})"},{"prefix":"close_formspec","token":"minetest","detail":"minetest.close_formspec(playername, formname)","kind":2,"desc":"    * `playername`: name of player to close formspec\n    * `formname`: has to exactly match the one given in `show_formspec`, or the\n      formspec will not close.\n    * calling `show_formspec(playername, formname, \"\")` is equal to this\n      expression.\n    * to close a formspec regardless of the formname, call\n      `minetest.close_formspec(playername, \"\")`.\n      **USE THIS ONLY WHEN ABSOLUTELY NECESSARY!**","body":"close_formspec(${1:playername}, ${2:formname})"},{"prefix":"formspec_escape","token":"minetest","detail":"minetest.formspec_escape(string)","kind":2,"desc":"returns a string\n    * escapes the characters \"[\", \"]\", \"\\\", \",\" and \";\", which can not be used\n      in formspecs.","body":"formspec_escape(${1:string})"},{"prefix":"explode_table_event","token":"minetest","detail":"minetest.explode_table_event(string)","kind":2,"desc":"returns a table\n    * returns e.g. `{type=\"CHG\", row=1, column=2}`\n    * `type` is one of:\n        * `\"INV\"`: no row selected\n        * `\"CHG\"`: selected\n        * `\"DCL\"`: double-click","body":"explode_table_event(${1:string})"},{"prefix":"explode_textlist_event","token":"minetest","detail":"minetest.explode_textlist_event(string)","kind":2,"desc":"returns a table\n    * returns e.g. `{type=\"CHG\", index=1}`\n    * `type` is one of:\n        * `\"INV\"`: no row selected\n        * `\"CHG\"`: selected\n        * `\"DCL\"`: double-click","body":"explode_textlist_event(${1:string})"},{"prefix":"explode_scrollbar_event","token":"minetest","detail":"minetest.explode_scrollbar_event(string)","kind":2,"desc":"returns a table\n    * returns e.g. `{type=\"CHG\", value=500}`\n    * `type` is one of:\n        * `\"INV\"`: something failed\n        * `\"CHG\"`: has been changed\n        * `\"VAL\"`: not changed","body":"explode_scrollbar_event(${1:string})"},{"prefix":"inventorycube","token":"minetest","detail":"minetest.inventorycube(img1, img2, img3)","kind":2,"desc":"    * Returns a string for making an image of a cube (useful as an item image)","body":"inventorycube(${1:img1}, ${2:img2}, ${3:img3})"},{"prefix":"get_pointed_thing_position","token":"minetest","detail":"minetest.get_pointed_thing_position(pointed_thing, above)","kind":2,"desc":"    * Returns the position of a `pointed_thing` or `nil` if the `pointed_thing`\n      does not refer to a node or entity.\n    * If the optional `above` parameter is true and the `pointed_thing` refers\n      to a node, then it will return the `above` position of the `pointed_thing`.","body":"get_pointed_thing_position(${1:pointed_thing}, ${2:above})"},{"prefix":"dir_to_facedir","token":"minetest","detail":"minetest.dir_to_facedir(dir, is6d)","kind":2,"desc":"    * Convert a vector to a facedir value, used in `param2` for\n      `paramtype2=\"facedir\"`.\n    * passing something non-`nil`/`false` for the optional second parameter\n      causes it to take the y component into account.","body":"dir_to_facedir(${1:dir}, ${2:is6d})"},{"prefix":"facedir_to_dir","token":"minetest","detail":"minetest.facedir_to_dir(facedir)","kind":2,"desc":"    * Convert a facedir back into a vector aimed directly out the \"back\" of a\n      node.","body":"facedir_to_dir(${1:facedir})"},{"prefix":"dir_to_wallmounted","token":"minetest","detail":"minetest.dir_to_wallmounted(dir)","kind":2,"desc":"    * Convert a vector to a wallmounted value, used for\n      `paramtype2=\"wallmounted\"`.","body":"dir_to_wallmounted(${1:dir})"},{"prefix":"wallmounted_to_dir","token":"minetest","detail":"minetest.wallmounted_to_dir(wallmounted)","kind":2,"desc":"    * Convert a wallmounted value back into a vector aimed directly out the\n      \"back\" of a node.","body":"wallmounted_to_dir(${1:wallmounted})"},{"prefix":"dir_to_yaw","token":"minetest","detail":"minetest.dir_to_yaw(dir)","kind":2,"desc":"    * Convert a vector into a yaw (angle)","body":"dir_to_yaw(${1:dir})"},{"prefix":"yaw_to_dir","token":"minetest","detail":"minetest.yaw_to_dir(yaw)","kind":2,"desc":"    * Convert yaw (angle) to a vector","body":"yaw_to_dir(${1:yaw})"},{"prefix":"is_colored_paramtype","token":"minetest","detail":"minetest.is_colored_paramtype(ptype)","kind":2,"desc":"    * Returns a boolean. Returns `true` if the given `paramtype2` contains\n      color information (`color`, `colorwallmounted` or `colorfacedir`).","body":"is_colored_paramtype(${1:ptype})"},{"prefix":"strip_param2_color","token":"minetest","detail":"minetest.strip_param2_color(param2, paramtype2)","kind":2,"desc":"    * Removes everything but the color information from the\n      given `param2` value.\n    * Returns `nil` if the given `paramtype2` does not contain color\n      information.","body":"strip_param2_color(${1:param2}, ${2:paramtype2})"},{"prefix":"get_node_drops","token":"minetest","detail":"minetest.get_node_drops(nodename, toolname)","kind":2,"desc":"    * Returns list of item names.\n    * **Note**: This will be removed or modified in a future version.","body":"get_node_drops(${1:nodename}, ${2:toolname})"},{"prefix":"get_craft_result","token":"minetest","detail":"minetest.get_craft_result(input)","kind":2,"desc":"returns `output, decremented_input`\n    * `input.method` = `\"normal\"` or `\"cooking\"` or `\"fuel\"`\n    * `input.width` = for example `3`\n    * `input.items` = for example\n      `{stack1, stack2, stack3, stack4, stack 5, stack 6, stack 7, stack 8, stack 9}`\n    * `output.item` = `ItemStack`, if unsuccessful: empty `ItemStack`\n    * `output.time` = a number, if unsuccessful: `0`\n    * `output.replacements` = list of `ItemStack`s that couldn't be placed in\n      `decremented_input.items`\n    * `decremented_input` = like `input`","body":"get_craft_result(${1:input})"},{"prefix":"get_craft_recipe","token":"minetest","detail":"minetest.get_craft_recipe(output)","kind":2,"desc":"returns input\n    * returns last registered recipe for output item (node)\n    * `output` is a node or item type such as `\"default:torch\"`\n    * `input.method` = `\"normal\"` or `\"cooking\"` or `\"fuel\"`\n    * `input.width` = for example `3`\n    * `input.items` = for example\n      `{stack1, stack2, stack3, stack4, stack 5, stack 6, stack 7, stack 8, stack 9}`\n        * `input.items` = `nil` if no recipe found","body":"get_craft_recipe(${1:output})"},{"prefix":"get_all_craft_recipes","token":"minetest","detail":"minetest.get_all_craft_recipes(query item)","kind":2,"desc":"returns a table or `nil`\n    * returns indexed table with all registered recipes for query item (node)\n      or `nil` if no recipe was found.\n    * recipe entry table:\n        * `method`: 'normal' or 'cooking' or 'fuel'\n        * `width`: 0-3, 0 means shapeless recipe\n        * `items`: indexed [1-9] table with recipe items\n        * `output`: string with item name and quantity\n    * Example query for `\"default:gold_ingot\"` will return table:","body":"get_all_craft_recipes(${1:query item})"},{"prefix":"handle_node_drops","token":"minetest","detail":"minetest.handle_node_drops(pos, drops, digger)","kind":2,"desc":"    * `drops`: list of itemstrings\n    * Handles drops from nodes after digging: Default action is to put them\n      into digger's inventory.\n    * Can be overridden to get different functionality (e.g. dropping items on\n      ground)","body":"handle_node_drops(${1:pos}, ${2:drops}, ${3:digger})"},{"prefix":"itemstring_with_palette","token":"minetest","detail":"minetest.itemstring_with_palette(item, palette_index)","kind":2,"desc":"returns an item\n  string.\n    * Creates an item string which contains palette index information\n      for hardware colorization. You can use the returned string\n      as an output in a craft recipe.\n    * `item`: the item stack which becomes colored. Can be in string,\n      table and native form.\n    * `palette_index`: this index is added to the item stack","body":"itemstring_with_palette(${1:item}, ${2:palette_index})"},{"prefix":"itemstring_with_color","token":"minetest","detail":"minetest.itemstring_with_color(item, colorstring)","kind":2,"desc":"returns an item string\n    * Creates an item string which contains static color information\n      for hardware colorization. Use this method if you wish to colorize\n      an item that does not own a palette. You can use the returned string\n      as an output in a craft recipe.\n    * `item`: the item stack which becomes colored. Can be in string,\n      table and native form.\n    * `colorstring`: the new color of the item stack","body":"itemstring_with_color(${1:item}, ${2:colorstring})"},{"prefix":"rollback_get_node_actions","token":"minetest","detail":"minetest.rollback_get_node_actions(pos, range, seconds, limit)","kind":2,"desc":"  returns `{{actor, pos, time, oldnode, newnode}, ...}`\n    * Find who has done something to a node, or near a node\n    * `actor`: `\"player:<name>\"`, also `\"liquid\"`.","body":"rollback_get_node_actions(${1:pos}, ${2:range}, ${3:seconds}, ${4:limit})"},{"prefix":"rollback_revert_actions_by","token":"minetest","detail":"minetest.rollback_revert_actions_by(actor, seconds)","kind":2,"desc":"returns\n  `boolean, log_messages`.\n    * Revert latest actions of someone\n    * `actor`: `\"player:<name>\"`, also `\"liquid\"`.","body":"rollback_revert_actions_by(${1:actor}, ${2:seconds})"},{"prefix":"node_punch","token":"minetest","detail":"minetest.node_punch(pos, node, puncher, pointed_thing)","kind":2,"desc":"    * Calls functions registered by `minetest.register_on_punchnode()`","body":"node_punch(${1:pos}, ${2:node}, ${3:puncher}, ${4:pointed_thing})"},{"prefix":"node_dig","token":"minetest","detail":"minetest.node_dig(pos, node, digger)","kind":2,"desc":"    * Checks if node can be dug, puts item into inventory, removes node\n    * Calls functions registered by `minetest.registered_on_dignodes()`","body":"node_dig(${1:pos}, ${2:node}, ${3:digger})"},{"prefix":"sound_play","token":"minetest","detail":"minetest.sound_play(spec, parameters)","kind":2,"desc":"returns a handle\n    * `spec` is a `SimpleSoundSpec`\n    * `parameters` is a sound parameter table","body":"sound_play(${1:spec}, ${2:parameters})"},{"prefix":"sound_stop","token":"minetest","detail":"minetest.sound_stop(handle)","kind":2,"desc":"","body":"sound_stop(${1:handle})"},{"prefix":"sound_fade","token":"minetest","detail":"minetest.sound_fade(handle, step, gain)","kind":2,"desc":"    * `handle` is a handle returned by `minetest.sound_play`\n    * `step` determines how fast a sound will fade.\n      Negative step will lower the sound volume, positive step will increase\n      the sound volume.\n    * `gain` the target gain for the fade.","body":"sound_fade(${1:handle}, ${2:step}, ${3:gain})"},{"prefix":"after","token":"minetest","detail":"minetest.after(time, func, ...)","kind":2,"desc":"    * Call the function `func` after `time` seconds, may be fractional\n    * Optional: Variable number of arguments that are passed to `func`","body":"after(${1:time}, ${2:func}, ${3:}...)"},{"prefix":"request_shutdown","token":"minetest","detail":"minetest.request_shutdown([message],[reconnect],[delay])","kind":2,"desc":"request for\n  server shutdown. Will display `message` to clients.\n    * `reconnect` == true displays a reconnect button\n    * `delay` adds an optional delay (in seconds) before shutdown.\n      Negative delay cancels the current active shutdown.\n      Zero delay triggers an immediate shutdown.","body":"request_shutdown([${1:message}], [${2:reconnect}], [${3:delay}])"},{"prefix":"cancel_shutdown_requests","token":"minetest","detail":"minetest.cancel_shutdown_requests()","kind":2,"desc":"cancel current delayed shutdown","body":"cancel_shutdown_requests()"},{"prefix":"get_server_status","token":"minetest","detail":"minetest.get_server_status(name, joined)","kind":2,"desc":"    * Returns the server status string when a player joins or when the command\n      `/status` is called. Returns `nil` or an empty string when the message is\n      disabled.\n    * `joined`: Boolean value, indicates whether the function was called when\n      a player joined.\n    * This function may be overwritten by mods to customize the status message.","body":"get_server_status(${1:name}, ${2:joined})"},{"prefix":"get_server_uptime","token":"minetest","detail":"minetest.get_server_uptime()","kind":2,"desc":"returns the server uptime in seconds","body":"get_server_uptime()"},{"prefix":"remove_player","token":"minetest","detail":"minetest.remove_player(name)","kind":2,"desc":"remove player from database (if they are not\n  connected).\n    * As auth data is not removed, minetest.player_exists will continue to\n      return true. Call the below method as well if you want to remove auth\n      data too.\n    * Returns a code (0: successful, 1: no such player, 2: player is connected)","body":"remove_player(${1:name})"},{"prefix":"remove_player_auth","token":"minetest","detail":"minetest.remove_player_auth(name)","kind":2,"desc":"remove player authentication data\n    * Returns boolean indicating success (false if player nonexistant)","body":"remove_player_auth(${1:name})"},{"prefix":"get_ban_list","token":"minetest","detail":"minetest.get_ban_list()","kind":2,"desc":"returns the ban list\n  (same as `minetest.get_ban_description(\"\")`).","body":"get_ban_list()"},{"prefix":"get_ban_description","token":"minetest","detail":"minetest.get_ban_description(ip_or_name)","kind":2,"desc":"returns ban description (string)","body":"get_ban_description(${1:ip_or_name})"},{"prefix":"ban_player","token":"minetest","detail":"minetest.ban_player(name)","kind":2,"desc":"ban a player","body":"ban_player(${1:name})"},{"prefix":"unban_player_or_ip","token":"minetest","detail":"minetest.unban_player_or_ip(name)","kind":2,"desc":"unban player or IP address","body":"unban_player_or_ip(${1:name})"},{"prefix":"kick_player","token":"minetest","detail":"minetest.kick_player(name, [reason])","kind":2,"desc":"disconnect a player with a optional\n  reason.","body":"kick_player(${1:name}, ${2:}[${3:reason}])"},{"prefix":"add_particle","token":"minetest","detail":"minetest.add_particle(particle definition)","kind":2,"desc":"    * Deprecated: `minetest.add_particle(pos, velocity, acceleration,\n      expirationtime, size, collisiondetection, texture, playername)`","body":"add_particle(${1:particle definition})"},{"prefix":"add_particlespawner","token":"minetest","detail":"minetest.add_particlespawner(particlespawner definition)","kind":2,"desc":"    * Add a `ParticleSpawner`, an object that spawns an amount of particles\n      over `time` seconds.\n    * Returns an `id`, and -1 if adding didn't succeed\n    * Deprecated: `minetest.add_particlespawner(amount, time,\n      minpos, maxpos,\n      minvel, maxvel,\n      minacc, maxacc,\n      minexptime, maxexptime,\n      minsize, maxsize,\n      collisiondetection, texture, playername)`","body":"add_particlespawner(${1:particlespawner definition})"},{"prefix":"delete_particlespawner","token":"minetest","detail":"minetest.delete_particlespawner(id, player)","kind":2,"desc":"    * Delete `ParticleSpawner` with `id` (return value from\n      `minetest.add_particlespawner`).\n    * If playername is specified, only deletes on the player's client,\n      otherwise on all clients.","body":"delete_particlespawner(${1:id}, ${2:player})"},{"prefix":"create_schematic","token":"minetest","detail":"minetest.create_schematic(p1, p2, probability_list, filename, slice_prob_list)","kind":2,"desc":"    * Create a schematic from the volume of map specified by the box formed by\n      p1 and p2.\n    * Apply the specified probability and per-node force-place to the specified\n      nodes according to the `probability_list`.\n        * `probability_list` is an array of tables containing two fields, `pos`\n          and `prob`.\n            * `pos` is the 3D vector specifying the absolute coordinates of the\n              node being modified,\n            * `prob` is an integer value from `0` to `255` that encodes\n              probability and per-node force-place. Probability has levels\n              0-127, then 128 may be added to encode per-node force-place.\n              For probability stated as 0-255, divide by 2 and round down to\n              get values 0-127, then add 128 to apply per-node force-place.\n            * If there are two or more entries with the same pos value, the\n              last entry is used.\n            * If `pos` is not inside the box formed by `p1` and `p2`, it is\n              ignored.\n            * If `probability_list` equals `nil`, no probabilities are applied.\n    * Apply the specified probability to the specified horizontal slices\n      according to the `slice_prob_list`.\n        * `slice_prob_list` is an array of tables containing two fields, `ypos`\n          and `prob`.\n            * `ypos` indicates the y position of the slice with a probability\n              applied, the lowest slice being `ypos = 0`.\n            * If slice probability list equals `nil`, no slice probabilities\n              are applied.\n    * Saves schematic in the Minetest Schematic format to filename.","body":"create_schematic(${1:p1}, ${2:p2}, ${3:probability_list}, ${4:filename}, ${5:slice_prob_list})"},{"prefix":"place_schematic","token":"minetest","detail":"minetest.place_schematic(pos, schematic, rotation, replacements, force_placement, flags)","kind":2,"desc":"    * Place the schematic specified by schematic (see [Schematic specifier]) at\n      `pos`.\n    * `rotation` can equal `\"0\"`, `\"90\"`, `\"180\"`, `\"270\"`, or `\"random\"`.\n    * If the `rotation` parameter is omitted, the schematic is not rotated.\n    * `replacements` = `{[\"old_name\"] = \"convert_to\", ...}`\n    * `force_placement` is a boolean indicating whether nodes other than `air`\n      and `ignore` are replaced by the schematic.\n    * Returns nil if the schematic could not be loaded.\n    * **Warning**: Once you have loaded a schematic from a file, it will be\n      cached. Future calls will always use the cached version and the\n      replacement list defined for it, regardless of whether the file or the\n      replacement list parameter have changed. The only way to load the file\n      anew is to restart the server.\n    * `flags` is a flag field with the available flags:\n        * place_center_x\n        * place_center_y\n        * place_center_z","body":"place_schematic(${1:pos}, ${2:schematic}, ${3:rotation}, ${4:replacements}, ${5:force_placement}, ${6:flags})"},{"prefix":"place_schematic_on_vmanip","token":"minetest","detail":"minetest.place_schematic_on_vmanip(vmanip, pos, schematic, rotation, replacement, force_placement, flags)","kind":2,"desc":"    * This function is analogous to minetest.place_schematic, but places a\n      schematic onto the specified VoxelManip object `vmanip` instead of the\n      map.\n    * Returns false if any part of the schematic was cut-off due to the\n      VoxelManip not containing the full area required, and true if the whole\n      schematic was able to fit.\n    * Returns nil if the schematic could not be loaded.\n    * After execution, any external copies of the VoxelManip contents are\n      invalidated.\n    * `flags` is a flag field with the available flags:\n        * place_center_x\n        * place_center_y\n        * place_center_z","body":"place_schematic_on_vmanip(${1:vmanip}, ${2:pos}, ${3:schematic}, ${4:rotation}, ${5:replacement}, ${6:force_placement}, ${7:flags})"},{"prefix":"serialize_schematic","token":"minetest","detail":"minetest.serialize_schematic(schematic, format, options)","kind":2,"desc":"    * Return the serialized schematic specified by schematic\n      (see [Schematic specifier])\n    * in the `format` of either \"mts\" or \"lua\".\n    * \"mts\" - a string containing the binary MTS data used in the MTS file\n      format.\n    * \"lua\" - a string containing Lua code representing the schematic in table\n      format.\n    * `options` is a table containing the following optional parameters:\n        * If `lua_use_comments` is true and `format` is \"lua\", the Lua code\n          generated will have (X, Z) position comments for every X row\n          generated in the schematic data for easier reading.\n        * If `lua_num_indent_spaces` is a nonzero number and `format` is \"lua\",\n          the Lua code generated will use that number of spaces as indentation\n          instead of a tab character.","body":"serialize_schematic(${1:schematic}, ${2:format}, ${3:options})"},{"prefix":"read_schematic","token":"minetest","detail":"minetest.read_schematic(schematic, options)","kind":2,"desc":"    * Returns a Lua table representing the schematic (see: [Schematic specifier])\n    * `schematic` is the schematic to read (see: [Schematic specifier])\n    * `options` is a table containing the following optional parameters:\n        * `write_yslice_prob`: string value:\n            * `none`: no `write_yslice_prob` table is inserted,\n            * `low`: only probabilities that are not 254 or 255 are written in\n              the `write_ylisce_prob` table,\n            * `all`: write all probabilities to the `write_yslice_prob` table.\n            * The default for this option is `all`.\n            * Any invalid value will be interpreted as `all`.","body":"read_schematic(${1:schematic}, ${2:options})"},{"prefix":"request_http_api","token":"minetest","detail":"minetest.request_http_api()","kind":2,"desc":"    * returns `HTTPApiTable` containing http functions if the calling mod has\n      been granted access by being listed in the `secure.http_mods` or\n      `secure.trusted_mods` setting, otherwise returns `nil`.\n    * The returned table contains the functions `fetch`, `fetch_async` and\n      `fetch_async_get` described below.\n    * Only works at init time and must be called from the mod's main scope\n      (not from a function).\n    * Function only exists if minetest server was built with cURL support.\n    * **DO NOT ALLOW ANY OTHER MODS TO ACCESS THE RETURNED TABLE, STORE IT IN\n      A LOCAL VARIABLE!**","body":"request_http_api()"},{"prefix":"fetch","token":"HTTPApiTable","detail":"HTTPApiTable.fetch(HTTPRequest req, callback)","kind":2,"desc":"    * Performs given request asynchronously and calls callback upon completion\n    * callback: `function(HTTPRequestResult res)`\n    * Use this HTTP function if you are unsure, the others are for advanced use","body":"fetch(${1:HTTPRequest req}, ${2:callback})"},{"prefix":"fetch_async","token":"HTTPApiTable","detail":"HTTPApiTable.fetch_async(HTTPRequest req)","kind":2,"desc":"returns handle\n    * Performs given request asynchronously and returns handle for\n      `HTTPApiTable.fetch_async_get`","body":"fetch_async(${1:HTTPRequest req})"},{"prefix":"fetch_async_get","token":"HTTPApiTable","detail":"HTTPApiTable.fetch_async_get(handle)","kind":2,"desc":"returns HTTPRequestResult\n    * Return response data for given asynchronous HTTP request","body":"fetch_async_get(${1:handle})"},{"prefix":"get_mod_storage","token":"minetest","detail":"minetest.get_mod_storage()","kind":2,"desc":"    * returns reference to mod private `StorageRef`\n    * must be called during mod load time","body":"get_mod_storage()"},{"prefix":"get_connected_players","token":"minetest","detail":"minetest.get_connected_players()","kind":2,"desc":"returns list of `ObjectRefs`","body":"get_connected_players()"},{"prefix":"is_player","token":"minetest","detail":"minetest.is_player(obj)","kind":2,"desc":"boolean, whether `obj` is a player","body":"is_player(${1:obj})"},{"prefix":"player_exists","token":"minetest","detail":"minetest.player_exists(name)","kind":2,"desc":"boolean, whether player exists\n  (regardless of online status)","body":"player_exists(${1:name})"},{"prefix":"hud_replace_builtin","token":"minetest","detail":"minetest.hud_replace_builtin(name, hud_definition)","kind":2,"desc":"    * Replaces definition of a builtin hud element\n    * `name`: `\"breath\"` or `\"health\"`\n    * `hud_definition`: definition to replace builtin definition","body":"hud_replace_builtin(${1:name}, ${2:hud_definition})"},{"prefix":"send_join_message","token":"minetest","detail":"minetest.send_join_message(player_name)","kind":2,"desc":"    * This function can be overridden by mods to change the join message.","body":"send_join_message(${1:player_name})"},{"prefix":"send_leave_message","token":"minetest","detail":"minetest.send_leave_message(player_name, timed_out)","kind":2,"desc":"    * This function can be overridden by mods to change the leave message.","body":"send_leave_message(${1:player_name}, ${2:timed_out})"},{"prefix":"hash_node_position","token":"minetest","detail":"minetest.hash_node_position(pos)","kind":2,"desc":"returns an 48-bit integer\n    * `pos`: table {x=number, y=number, z=number},\n    * Gives a unique hash number for a node position (16+16+16=48bit)","body":"hash_node_position(${1:pos})"},{"prefix":"get_position_from_hash","token":"minetest","detail":"minetest.get_position_from_hash(hash)","kind":2,"desc":"returns a position\n    * Inverse transform of `minetest.hash_node_position`","body":"get_position_from_hash(${1:hash})"},{"prefix":"get_item_group","token":"minetest","detail":"minetest.get_item_group(name, group)","kind":2,"desc":"returns a rating\n    * Get rating of a group of an item. (`0` means: not in group)","body":"get_item_group(${1:name}, ${2:group})"},{"prefix":"get_node_group","token":"minetest","detail":"minetest.get_node_group(name, group)","kind":2,"desc":"returns a rating\n    * Deprecated: An alias for the former.","body":"get_node_group(${1:name}, ${2:group})"},{"prefix":"raillike_group","token":"minetest","detail":"minetest.raillike_group(name)","kind":2,"desc":"returns a rating\n    * Returns rating of the connect_to_raillike group corresponding to name\n    * If name is not yet the name of a connect_to_raillike group, a new group\n      id is created, with that name.","body":"raillike_group(${1:name})"},{"prefix":"get_content_id","token":"minetest","detail":"minetest.get_content_id(name)","kind":2,"desc":"returns an integer\n    * Gets the internal content ID of `name`","body":"get_content_id(${1:name})"},{"prefix":"get_name_from_content_id","token":"minetest","detail":"minetest.get_name_from_content_id(content_id)","kind":2,"desc":"returns a string\n    * Gets the name of the content with that content ID","body":"get_name_from_content_id(${1:content_id})"},{"prefix":"parse_json","token":"minetest","detail":"minetest.parse_json(string[, nullvalue])","kind":2,"desc":"returns something\n    * Convert a string containing JSON data into the Lua equivalent\n    * `nullvalue`: returned in place of the JSON null; defaults to `nil`\n    * On success returns a table, a string, a number, a boolean or `nullvalue`\n    * On failure outputs an error message and returns `nil`\n    * Example: `parse_json(\"[10, {\\\"a\\\":false}]\")`, returns `{10, {a = false}}`","body":"parse_json(${1:string}[, ${2:nullvalue}])"},{"prefix":"write_json","token":"minetest","detail":"minetest.write_json(data[, styled])","kind":2,"desc":"returns a string or `nil` and an error\n  message.\n    * Convert a Lua table into a JSON string\n    * styled: Outputs in a human-readable format if this is set, defaults to\n      false.\n    * Unserializable things like functions and userdata will cause an error.\n    * **Warning**: JSON is more strict than the Lua table format.\n        1. You can only use strings and positive integers of at least one as\n           keys.\n        2. You can not mix string and integer keys.\n           This is due to the fact that JSON has two distinct array and object\n           values.\n    * Example: `write_json({10, {a = false}})`,\n      returns `\"[10, {\\\"a\\\": false}]\"`","body":"write_json(${1:data}[, ${2:styled}])"},{"prefix":"serialize","token":"minetest","detail":"minetest.serialize(table)","kind":2,"desc":"returns a string\n    * Convert a table containing tables, strings, numbers, booleans and `nil`s\n      into string form readable by `minetest.deserialize`\n    * Example: `serialize({foo='bar'})`, returns `'return { [\"foo\"] = \"bar\" }'`","body":"serialize(${1:table})"},{"prefix":"deserialize","token":"minetest","detail":"minetest.deserialize(string)","kind":2,"desc":"returns a table\n    * Convert a string returned by `minetest.deserialize` into a table\n    * `string` is loaded in an empty sandbox environment.\n    * Will load functions, but they cannot access the global environment.\n    * Example: `deserialize('return { [\"foo\"] = \"bar\" }')`,\n      returns `{foo='bar'}`\n    * Example: `deserialize('print(\"foo\")')`, returns `nil`\n      (function call fails), returns\n      `error:[string \"print(\"foo\")\"]:1: attempt to call global 'print' (a nil value)`","body":"deserialize(${1:string})"},{"prefix":"compress","token":"minetest","detail":"minetest.compress(data, method, ...)","kind":2,"desc":"returns `compressed_data`\n    * Compress a string of data.\n    * `method` is a string identifying the compression method to be used.\n    * Supported compression methods:\n        * Deflate (zlib): `\"deflate\"`\n    * `...` indicates method-specific arguments. Currently defined arguments\n      are:\n        * Deflate: `level` - Compression level, `0`-`9` or `nil`.","body":"compress(${1:data}, ${2:method}, ${3:}...)"},{"prefix":"decompress","token":"minetest","detail":"minetest.decompress(compressed_data, method, ...)","kind":2,"desc":"returns data\n    * Decompress a string of data (using ZLib).\n    * See documentation on `minetest.compress()` for supported compression\n      methods.\n    * `...` indicates method-specific arguments. Currently, no methods use this","body":"decompress(${1:compressed_data}, ${2:method}, ${3:}...)"},{"prefix":"rgba","token":"minetest","detail":"minetest.rgba(red, green, blue[, alpha])","kind":2,"desc":"returns a string\n    * Each argument is a 8 Bit unsigned integer\n    * Returns the ColorString from rgb or rgba values\n    * Example: `minetest.rgba(10, 20, 30, 40)`, returns `\"#0A141E28\"`","body":"rgba(${1:red}, ${2:green}, ${3:blue}[, ${4:alpha}])"},{"prefix":"encode_base64","token":"minetest","detail":"minetest.encode_base64(string)","kind":2,"desc":"returns string encoded in base64\n    * Encodes a string in base64.","body":"encode_base64(${1:string})"},{"prefix":"decode_base64","token":"minetest","detail":"minetest.decode_base64(string)","kind":2,"desc":"returns string\n    * Decodes a string encoded in base64.","body":"decode_base64(${1:string})"},{"prefix":"is_protected","token":"minetest","detail":"minetest.is_protected(pos, name)","kind":2,"desc":"returns boolean\n    * Returning `true` restricts the player `name` from modifying (i.e. digging,\n       placing) the node at position `pos`.\n    * `name` will be `\"\"` for non-players or unknown players.\n    * This function should be overridden by protection mods. It is highly\n      recommended to grant access to players with the `protection_bypass` privilege.\n    * Cache and call the old version of this function if the position is\n      not protected by the mod. This will allow using multiple protection mods.\n    * Example:","body":"is_protected(${1:pos}, ${2:name})"},{"prefix":"record_protection_violation","token":"minetest","detail":"minetest.record_protection_violation(pos, name)","kind":2,"desc":"    * This function calls functions registered with\n      `minetest.register_on_protection_violation`.","body":"record_protection_violation(${1:pos}, ${2:name})"},{"prefix":"is_area_protected","token":"minetest","detail":"minetest.is_area_protected(pos1, pos2, player_name, interval)","kind":2,"desc":"    * Returns the position of the first node that `player_name` may not modify\n      in the specified cuboid between `pos1` and `pos2`.\n    * Returns `false` if no protections were found.\n    * Applies `is_protected()` to a 3D lattice of points in the defined volume.\n      The points are spaced evenly throughout the volume and have a spacing\n      similar to, but no larger than, `interval`.\n    * All corners and edges of the defined volume are checked.\n    * `interval` defaults to 4.\n    * `interval` should be carefully chosen and maximised to avoid an excessive\n      number of points being checked.\n    * Like `minetest.is_protected`, this function may be extended or\n      overwritten by mods to provide a faster implementation to check the\n      cuboid for intersections.\n* `minetest.rotate_and_place(itemstack, placer, pointed_thing[, infinitestacks,\n  orient_flags, prevent_after_place])`\n    * Attempt to predict the desired orientation of the facedir-capable node\n      defined by `itemstack`, and place it accordingly (on-wall, on the floor,\n      or hanging from the ceiling).\n    * `infinitestacks`: if `true`, the itemstack is not changed. Otherwise the\n      stacks are handled normally.\n    * `orient_flags`: Optional table containing extra tweaks to the placement code:\n        * `invert_wall`:   if `true`, place wall-orientation on the ground and\n          ground-orientation on the wall.\n        * `force_wall` :   if `true`, always place the node in wall orientation.\n        * `force_ceiling`: if `true`, always place on the ceiling.\n        * `force_floor`:   if `true`, always place the node on the floor.\n        * `force_facedir`: if `true`, forcefully reset the facedir to north\n          when placing on the floor or ceiling.\n        * The first four options are mutually-exclusive; the last in the list\n          takes precedence over the first.\n    * `prevent_after_place` is directly passed to `minetest.item_place_node`\n    * Returns the new itemstack after placement","body":"is_area_protected(${1:pos1}, ${2:pos2}, ${3:player_name}, ${4:interval})"},{"prefix":"rotate_node","token":"minetest","detail":"minetest.rotate_node(itemstack, placer, pointed_thing)","kind":2,"desc":"    * calls `rotate_and_place()` with `infinitestacks` set according to the state\n      of the creative mode setting, checks for \"sneak\" to set the `invert_wall`\n      parameter and `prevent_after_place` set to `true`.","body":"rotate_node(${1:itemstack}, ${2:placer}, ${3:pointed_thing})"},{"prefix":"forceload_block","token":"minetest","detail":"minetest.forceload_block(pos[, transient])","kind":2,"desc":"    * forceloads the position `pos`.\n    * returns `true` if area could be forceloaded\n    * If `transient` is `false` or absent, the forceload will be persistent\n      (saved between server runs). If `true`, the forceload will be transient\n      (not saved between server runs).","body":"forceload_block(${1:pos}[, ${2:transient}])"},{"prefix":"forceload_free_block","token":"minetest","detail":"minetest.forceload_free_block(pos[, transient])","kind":2,"desc":"    * stops forceloading the position `pos`\n    * If `transient` is `false` or absent, frees a persistent forceload.\n      If `true`, frees a transient forceload.","body":"forceload_free_block(${1:pos}[, ${2:transient}])"},{"prefix":"request_insecure_environment","token":"minetest","detail":"minetest.request_insecure_environment()","kind":2,"desc":"returns an environment containing\n  insecure functions if the calling mod has been listed as trusted in the\n  `secure.trusted_mods` setting or security is disabled, otherwise returns\n  `nil`.\n    * Only works at init time and must be called from the mod's main scope (not\n      from a function).\n    * **DO NOT ALLOW ANY OTHER MODS TO ACCESS THE RETURNED ENVIRONMENT, STORE\n      IT IN A LOCAL VARIABLE!**","body":"request_insecure_environment()"},{"prefix":"global_exists","token":"minetest","detail":"minetest.global_exists(name)","kind":2,"desc":"    * Checks if a global variable has been set, without triggering a warning.","body":"global_exists(${1:name})"},{"prefix":"get_area","token":":","detail":"get_area(id, include_borders, include_data)","kind":2,"desc":"    * Returns the area information about the specified ID.\n    * Returned values are either of these:","body":"_area(${1:id}, ${2:include_borders}, ${3:include_data})"},{"prefix":"get_areas_for_pos","token":":","detail":"get_areas_for_pos(pos, include_borders, include_data)","kind":2,"desc":"    * Returns all areas as table, indexed by the area ID.\n    * Table values: see `get_area`.","body":"_areas_for_pos(${1:pos}, ${2:include_borders}, ${3:include_data})"},{"prefix":"get_areas_in_area","token":":","detail":"get_areas_in_area(edge1, edge2, accept_overlap, include_borders, include_data)","kind":2,"desc":"    * Returns all areas that contain all nodes inside the area specified by `edge1`\n      and `edge2` (inclusive).\n    * `accept_overlap`: if `true`, areas are returned that have nodes in\n      common (intersect) with the specified area.\n    * Returns the same values as `get_areas_for_pos`.","body":"_areas_in_area(${1:edge1}, ${2:edge2}, ${3:accept_overlap}, ${4:include_borders}, ${5:include_data})"},{"prefix":"insert_area","token":":","detail":"insert_area(edge1, edge2, data, [id])","kind":2,"desc":"inserts an area into the store.\n    * Returns the new area's ID, or nil if the insertion failed.\n    * The (inclusive) positions `edge1` and `edge2` describe the area.\n    * `data` is a string stored with the area.\n    * `id` (optional): will be used as the internal area ID if it is an unique\n      number between 0 and 2^32-2.","body":"_area(${1:edge1}, ${2:edge2}, ${3:data}, ${4:}[${5:id}])"},{"prefix":"reserve","token":":","detail":"reserve(count)","kind":2,"desc":"reserves resources for at most `count` many contained\n  areas.\n  Only needed for efficiency, and only some implementations profit.","body":"(${1:count})"},{"prefix":"remove_area","token":":","detail":"remove_area(id)","kind":2,"desc":"removes the area with the given id from the store, returns\n  success.","body":"_area(${1:id})"},{"prefix":"set_cache_params","token":":","detail":"set_cache_params(params)","kind":2,"desc":"sets params for the included prefiltering cache.\n  Calling invalidates the cache, so that its elements have to be newly\n  generated.\n    * `params` is a table with the following fields:","body":"_cache_params(${1:params})"},{"prefix":"to_string","token":":","detail":"to_string()","kind":2,"desc":"Experimental. Returns area store serialized as a (binary)\n  string.","body":"_string()"},{"prefix":"to_file","token":":","detail":"to_file(filename)","kind":2,"desc":"Experimental. Like `to_string()`, but writes the data to\n  a file.","body":"_file(${1:filename})"},{"prefix":"from_string","token":":","detail":"from_string(str)","kind":2,"desc":"Experimental. Deserializes string and loads it into the\n  AreaStore.\n  Returns success and, optionally, an error message.","body":"_string(${1:str})"},{"prefix":"from_file","token":":","detail":"from_file(filename)","kind":2,"desc":"Experimental. Like `from_string()`, but reads the data\n  from a file.","body":"_file(${1:filename})"},{"prefix":"is_empty","token":":","detail":"is_empty(listname)","kind":2,"desc":"return `true` if list is empty","body":"_empty(${1:listname})"},{"prefix":"get_size","token":":","detail":"get_size(listname)","kind":2,"desc":"get size of a list","body":"_size(${1:listname})"},{"prefix":"set_size","token":":","detail":"set_size(listname, size)","kind":2,"desc":"set size of a list\n    * returns `false` on error (e.g. invalid `listname` or `size`)","body":"_size(${1:listname}, ${2:size})"},{"prefix":"get_width","token":":","detail":"get_width(listname)","kind":2,"desc":"get width of a list","body":"_width(${1:listname})"},{"prefix":"set_width","token":":","detail":"set_width(listname, width)","kind":2,"desc":"set width of list; currently used for crafting","body":"_width(${1:listname}, ${2:width})"},{"prefix":"get_stack","token":":","detail":"get_stack(listname, i)","kind":2,"desc":"get a copy of stack index `i` in list","body":"_stack(${1:listname}, ${2:i})"},{"prefix":"set_stack","token":":","detail":"set_stack(listname, i, stack)","kind":2,"desc":"copy `stack` to index `i` in list","body":"_stack(${1:listname}, ${2:i}, ${3:stack})"},{"prefix":"get_list","token":":","detail":"get_list(listname)","kind":2,"desc":"return full list","body":"_list(${1:listname})"},{"prefix":"set_list","token":":","detail":"set_list(listname, list)","kind":2,"desc":"set full list (size will not change)","body":"_list(${1:listname}, ${2:list})"},{"prefix":"get_lists","token":":","detail":"get_lists()","kind":2,"desc":"returns list of inventory lists","body":"_lists()"},{"prefix":"set_lists","token":":","detail":"set_lists(lists)","kind":2,"desc":"sets inventory lists (size will not change)","body":"_lists(${1:lists})"},{"prefix":"add_item","token":":","detail":"add_item(listname, stack)","kind":2,"desc":"add item somewhere in list, returns leftover\n  `ItemStack`.\n* `room_for_item(listname, stack):` returns `true` if the stack of items\n  can be fully added to the list","body":"_item(${1:listname}, ${2:stack})"},{"prefix":"contains_item","token":":","detail":"contains_item(listname, stack, [match_meta])","kind":2,"desc":"returns `true` if\n  the stack of items can be fully taken from the list.\n  If `match_meta` is false, only the items' names are compared\n  (default: `false`).","body":"_item(${1:listname}, ${2:stack}, ${3:}[${4:match_meta}])"},{"prefix":"remove_item","token":":","detail":"remove_item(listname, stack)","kind":2,"desc":"take as many items as specified from the\n  list, returns the items that were actually removed (as an `ItemStack`)\n  -- note that any item metadata is ignored, so attempting to remove a specific\n  unique item this way will likely remove the wrong one -- to do that use\n  `set_stack` with an empty `ItemStack`.","body":"_item(${1:listname}, ${2:stack})"},{"prefix":"get_location","token":":","detail":"get_location()","kind":2,"desc":"returns a location compatible to\n  `minetest.get_inventory(location)`.\n    * returns `{type=\"undefined\"}` in case location is not known","body":"_location()"},{"prefix":"is_empty","token":":","detail":"is_empty()","kind":2,"desc":"returns `true` if stack is empty.","body":"_empty()"},{"prefix":"get_name","token":":","detail":"get_name()","kind":2,"desc":"returns item name (e.g. `\\\"default:stone\\\"`).","body":"_name()"},{"prefix":"set_name","token":":","detail":"set_name(item_name)","kind":2,"desc":"returns a boolean indicating whether the item was\n  cleared.","body":"_name(${1:item_name})"},{"prefix":"get_count","token":":","detail":"get_count()","kind":2,"desc":"Returns number of items on the stack.","body":"_count()"},{"prefix":"set_count","token":":","detail":"set_count(count)","kind":2,"desc":"returns a boolean indicating whether the item was cleared\n    * `count`: number, unsigned 16 bit integer","body":"_count(${1:count})"},{"prefix":"get_wear","token":":","detail":"get_wear()","kind":2,"desc":"returns tool wear (`0`-`65535`), `0` for non-tools.","body":"_wear()"},{"prefix":"set_wear","token":":","detail":"set_wear(wear)","kind":2,"desc":"returns boolean indicating whether item was cleared\n    * `wear`: number, unsigned 16 bit integer","body":"_wear(${1:wear})"},{"prefix":"get_meta","token":":","detail":"get_meta()","kind":2,"desc":"returns ItemStackMetaRef. See section for more details","body":"_meta()"},{"prefix":"get_metadata","token":":","detail":"get_metadata()","kind":2,"desc":"(DEPRECATED) Returns metadata (a string attached to an item\n  stack).","body":"_metadata()"},{"prefix":"set_metadata","token":":","detail":"set_metadata(metadata)","kind":2,"desc":"(DEPRECATED) Returns true.","body":"_metadata(${1:metadata})"},{"prefix":"get_description","token":":","detail":"get_description()","kind":2,"desc":"returns the description shown in inventory list tooltips.","body":"_description()"},{"prefix":"clear","token":":","detail":"clear()","kind":2,"desc":"removes all items from the stack, making it empty.","body":"()"},{"prefix":"replace","token":":","detail":"replace(item)","kind":2,"desc":"replace the contents of this stack.\n    * `item` can also be an itemstring or table.","body":"(${1:item})"},{"prefix":"to_string","token":":","detail":"to_string()","kind":2,"desc":"returns the stack in itemstring form.","body":"_string()"},{"prefix":"to_table","token":":","detail":"to_table()","kind":2,"desc":"returns the stack in Lua table form.","body":"_table()"},{"prefix":"get_stack_max","token":":","detail":"get_stack_max()","kind":2,"desc":"returns the maximum size of the stack (depends on the\n  item).","body":"_stack_max()"},{"prefix":"get_free_space","token":":","detail":"get_free_space()","kind":2,"desc":"returns `get_stack_max() - get_count()`.","body":"_free_space()"},{"prefix":"is_known","token":":","detail":"is_known()","kind":2,"desc":"returns `true` if the item name refers to a defined item type.","body":"_known()"},{"prefix":"get_definition","token":":","detail":"get_definition()","kind":2,"desc":"returns the item definition table.","body":"_definition()"},{"prefix":"get_tool_capabilities","token":":","detail":"get_tool_capabilities()","kind":2,"desc":"returns the digging properties of the item,\n  or those of the hand if none are defined for this item type","body":"_tool_capabilities()"},{"prefix":"add_wear","token":":","detail":"add_wear(amount)","kind":2,"desc":"    * Increases wear by `amount` if the item is a tool\n    * `amount`: number, integer","body":"_wear(${1:amount})"},{"prefix":"add_item","token":":","detail":"add_item(item)","kind":2,"desc":"returns leftover `ItemStack`\n    * Put some item or stack onto this stack","body":"_item(${1:item})"},{"prefix":"item_fits","token":":","detail":"item_fits(item)","kind":2,"desc":"returns `true` if item or stack can be fully added to\n  this one.","body":"_fits(${1:item})"},{"prefix":"take_item","token":":","detail":"take_item(n)","kind":2,"desc":"returns taken `ItemStack`\n    * Take (and remove) up to `n` items from this stack\n    * `n`: number, default: `1`","body":"_item(${1:n})"},{"prefix":"peek_item","token":":","detail":"peek_item(n)","kind":2,"desc":"returns taken `ItemStack`\n    * Copy (don't remove) up to `n` items from this stack\n    * `n`: number, default: `1`","body":"_item(${1:n})"},{"prefix":"set_tool_capabilities","token":":","detail":"set_tool_capabilities([tool_capabilities])","kind":2,"desc":"    * Overrides the item's tool capabilities\n    * A nil value will clear the override data and restore the original\n      behavior.","body":"_tool_capabilities([${1:tool_capabilities}])"},{"prefix":"contains","token":":","detail":"contains(key)","kind":2,"desc":"Returns true if key present, otherwise false.\n    * Returns `nil` when the MetaData is inexistent.","body":"(${1:key})"},{"prefix":"get","token":":","detail":"get(key)","kind":2,"desc":"Returns `nil` if key not present, else the stored string.","body":"(${1:key})"},{"prefix":"set_string","token":":","detail":"set_string(key, value)","kind":2,"desc":"Value of `\\\"\\\"` will delete the key.","body":"_string(${1:key}, ${2:value})"},{"prefix":"get_string","token":":","detail":"get_string(key)","kind":2,"desc":"Returns `\\\"\\\"` if key not present.","body":"_string(${1:key})"},{"prefix":"set_int","token":":","detail":"set_int(key, value)","kind":2,"desc":"","body":"_int(${1:key}, ${2:value})"},{"prefix":"get_int","token":":","detail":"get_int(key)","kind":2,"desc":"Returns `0` if key not present.","body":"_int(${1:key})"},{"prefix":"set_float","token":":","detail":"set_float(key, value)","kind":2,"desc":"","body":"_float(${1:key}, ${2:value})"},{"prefix":"get_float","token":":","detail":"get_float(key)","kind":2,"desc":"Returns `0` if key not present.","body":"_float(${1:key})"},{"prefix":"to_table","token":":","detail":"to_table()","kind":2,"desc":"returns `nil` or a table with keys:\n    * `fields`: key-value storage\n    * `inventory`: `{list1 = {}, ...}}` (NodeMetaRef only)","body":"_table()"},{"prefix":"from_table","token":":","detail":"from_table(nil or {})","kind":2,"desc":"    * Any non-table value will clear the metadata\n    * See [Node Metadata] for an example\n    * returns `true` on success","body":"_table(${1:nil or }{})"},{"prefix":"equals","token":":","detail":"equals(other)","kind":2,"desc":"    * returns `true` if this metadata has the same key-value pairs as `other`","body":"(${1:other})"},{"prefix":"leave","token":":","detail":"leave()","kind":2,"desc":"leave the mod channel.\n    * Server leaves channel `channel_name`.\n    * No more incoming or outgoing messages can be sent to this channel from\n      server mods.\n    * This invalidate all future object usage.\n    * Ensure you set mod_channel to nil after that to free Lua resources.","body":"()"},{"prefix":"is_writeable","token":":","detail":"is_writeable()","kind":2,"desc":"returns true if channel is writeable and mod can send over\n  it.","body":"_writeable()"},{"prefix":"send_all","token":":","detail":"send_all(message)","kind":2,"desc":"Send `message` though the mod channel.\n    * If mod channel is not writeable or invalid, message will be dropped.\n    * Message size is limited to 65535 characters by protocol.","body":"_all(${1:message})"},{"prefix":"get_inventory","token":":","detail":"get_inventory()","kind":2,"desc":"returns `InvRef`","body":"_inventory()"},{"prefix":"mark_as_private","token":":","detail":"mark_as_private(name or {name1, name2, ...})","kind":2,"desc":"Mark specific vars as private\n  This will prevent them from being sent to the client. Note that the \"private\"\n  status will only be remembered if an associated key-value pair exists,\n  meaning it's best to call this when initializing all other meta (e.g.\n  `on_construct`).","body":"_as_private(${1:name or }{${2:name1}, ${3:name2}, ${4:}...})"},{"prefix":"set","token":":","detail":"set(timeout,elapsed)","kind":2,"desc":"    * set a timer's state\n    * `timeout` is in seconds, and supports fractional values (0.1 etc)\n    * `elapsed` is in seconds, and supports fractional values (0.1 etc)\n    * will trigger the node's `on_timer` function after `(timeout - elapsed)`\n      seconds.","body":"(${1:timeout}, ${2:elapsed})"},{"prefix":"start","token":":","detail":"start(timeout)","kind":2,"desc":"    * start a timer\n    * equivalent to `set(timeout,0)`","body":"(${1:timeout})"},{"prefix":"stop","token":":","detail":"stop()","kind":2,"desc":"    * stops the timer","body":"()"},{"prefix":"get_timeout","token":":","detail":"get_timeout()","kind":2,"desc":"returns current timeout in seconds\n    * if `timeout` equals `0`, timer is inactive","body":"_timeout()"},{"prefix":"get_elapsed","token":":","detail":"get_elapsed()","kind":2,"desc":"returns current elapsed time in seconds\n    * the node's `on_timer` function will be called after `(timeout - elapsed)`\n      seconds.","body":"_elapsed()"},{"prefix":"is_started","token":":","detail":"is_started()","kind":2,"desc":"returns boolean state of timer\n    * returns `true` if timer is started, otherwise `false`","body":"_started()"},{"prefix":"get_pos","token":":","detail":"get_pos()","kind":2,"desc":"returns `{x=num, y=num, z=num}`","body":"_pos()"},{"prefix":"set_pos","token":":","detail":"set_pos(pos)","kind":2,"desc":"`pos`=`{x=num, y=num, z=num}`","body":"_pos(${1:pos})"},{"prefix":"move_to","token":":","detail":"move_to(pos, continuous=false)","kind":2,"desc":"    * Does an interpolated move for Lua entities for visually smooth transitions.\n    * If `continuous` is true, the Lua entity will not be moved to the current\n      position before starting the interpolated move.\n    * For players this does the same as `set_pos`,`continuous` is ignored.","body":"_to(${1:pos}, ${2:continuous}=${3:false})"},{"prefix":"punch","token":":","detail":"punch(puncher, time_from_last_punch, tool_capabilities, direction)","kind":2,"desc":"    * `puncher` = another `ObjectRef`,\n    * `time_from_last_punch` = time since last punch action of the puncher\n    * `direction`: can be `nil`","body":"(${1:puncher}, ${2:time_from_last_punch}, ${3:tool_capabilities}, ${4:direction})"},{"prefix":"right_click","token":":","detail":"right_click(clicker)","kind":2,"desc":"is another `ObjectRef`","body":"_click(${1:clicker})"},{"prefix":"get_hp","token":":","detail":"get_hp()","kind":2,"desc":"returns number of hitpoints (2 * number of hearts)","body":"_hp()"},{"prefix":"set_hp","token":":","detail":"set_hp(hp, reason)","kind":2,"desc":"set number of hitpoints (2 * number of hearts).\n    * See reason in register_on_player_hpchange","body":"_hp(${1:hp}, ${2:reason})"},{"prefix":"get_inventory","token":":","detail":"get_inventory()","kind":2,"desc":"returns an `InvRef` for players, otherwise returns `nil`","body":"_inventory()"},{"prefix":"get_wield_list","token":":","detail":"get_wield_list()","kind":2,"desc":"returns the name of the inventory list the wielded item\n   is in.","body":"_wield_list()"},{"prefix":"get_wield_index","token":":","detail":"get_wield_index()","kind":2,"desc":"returns the index of the wielded item","body":"_wield_index()"},{"prefix":"get_wielded_item","token":":","detail":"get_wielded_item()","kind":2,"desc":"returns an `ItemStack`","body":"_wielded_item()"},{"prefix":"set_wielded_item","token":":","detail":"set_wielded_item(item)","kind":2,"desc":"replaces the wielded item, returns `true` if\n  successful.","body":"_wielded_item(${1:item})"},{"prefix":"set_armor_groups","token":":","detail":"set_armor_groups({group1=rating, group2=rating, ...})","kind":2,"desc":"","body":"_armor_groups({${1:group1}=${2:rating}, ${3:group2}=${4:rating}, ${5:}...})"},{"prefix":"get_armor_groups","token":":","detail":"get_armor_groups()","kind":2,"desc":"returns a table with the armor group ratings","body":"_armor_groups()"},{"prefix":"set_animation","token":":","detail":"set_animation(frame_range, frame_speed, frame_blend, frame_loop)","kind":2,"desc":"    * `frame_range`: table {x=num, y=num}, default: `{x=1, y=1}`\n    * `frame_speed`: number, default: `15.0`\n    * `frame_blend`: number, default: `0.0`\n    * `frame_loop`: boolean, default: `true`","body":"_animation(${1:frame_range}, ${2:frame_speed}, ${3:frame_blend}, ${4:frame_loop})"},{"prefix":"get_animation","token":":","detail":"get_animation()","kind":2,"desc":"returns `range`, `frame_speed`, `frame_blend` and\n  `frame_loop`.","body":"_animation()"},{"prefix":"set_animation_frame_speed","token":":","detail":"set_animation_frame_speed(frame_speed)","kind":2,"desc":"    * `frame_speed`: number, default: `15.0`","body":"_animation_frame_speed(${1:frame_speed})"},{"prefix":"set_attach","token":":","detail":"set_attach(parent, bone, position, rotation)","kind":2,"desc":"    * `bone`: string\n    * `position`: `{x=num, y=num, z=num}` (relative)\n    * `rotation`: `{x=num, y=num, z=num}` = Rotation on each axis, in degrees","body":"_attach(${1:parent}, ${2:bone}, ${3:position}, ${4:rotation})"},{"prefix":"get_attach","token":":","detail":"get_attach()","kind":2,"desc":"returns parent, bone, position, rotation or nil if it isn't\n  attached.","body":"_attach()"},{"prefix":"set_detach","token":":","detail":"set_detach()","kind":2,"desc":"","body":"_detach()"},{"prefix":"set_bone_position","token":":","detail":"set_bone_position(bone, position, rotation)","kind":2,"desc":"    * `bone`: string\n    * `position`: `{x=num, y=num, z=num}` (relative)\n    * `rotation`: `{x=num, y=num, z=num}`","body":"_bone_position(${1:bone}, ${2:position}, ${3:rotation})"},{"prefix":"get_bone_position","token":":","detail":"get_bone_position(bone)","kind":2,"desc":"returns position and rotation of the bone","body":"_bone_position(${1:bone})"},{"prefix":"set_properties","token":":","detail":"set_properties(object property table)","kind":2,"desc":"","body":"_properties(${1:object property table})"},{"prefix":"get_properties","token":":","detail":"get_properties()","kind":2,"desc":"returns object property table","body":"_properties()"},{"prefix":"is_player","token":":","detail":"is_player()","kind":2,"desc":"returns true for players, false otherwise","body":"_player()"},{"prefix":"get_nametag_attributes","token":":","detail":"get_nametag_attributes()","kind":2,"desc":"    * returns a table with the attributes of the nametag of an object\n    * {\n        color = {a=0..255, r=0..255, g=0..255, b=0..255},\n        text = \"\",\n      }","body":"_nametag_attributes()"},{"prefix":"set_nametag_attributes","token":":","detail":"set_nametag_attributes(attributes)","kind":2,"desc":"    * sets the attributes of the nametag of an object\n    * `attributes`:\n      {\n        color = ColorSpec,\n        text = \"My Nametag\",\n      }","body":"_nametag_attributes(${1:attributes})"},{"prefix":"remove","token":":","detail":"remove()","kind":2,"desc":"remove object (after returning from Lua)","body":"()"},{"prefix":"set_velocity","token":":","detail":"set_velocity(vel)","kind":2,"desc":"    * `vel` is a vector, e.g. `{x=0.0, y=2.3, z=1.0}`","body":"_velocity(${1:vel})"},{"prefix":"add_velocity","token":":","detail":"add_velocity(vel)","kind":2,"desc":"    * `vel` is a vector, e.g. `{x=0.0, y=2.3, z=1.0}`\n    * In comparison to using get_velocity, adding the velocity and then using\n      set_velocity, add_velocity is supposed to avoid synchronization problems.","body":"_velocity(${1:vel})"},{"prefix":"get_velocity","token":":","detail":"get_velocity()","kind":2,"desc":"returns the velocity, a vector","body":"_velocity()"},{"prefix":"set_acceleration","token":":","detail":"set_acceleration(acc)","kind":2,"desc":"    * `acc` is a vector","body":"_acceleration(${1:acc})"},{"prefix":"get_acceleration","token":":","detail":"get_acceleration()","kind":2,"desc":"returns the acceleration, a vector","body":"_acceleration()"},{"prefix":"set_rotation","token":":","detail":"set_rotation(rot)","kind":2,"desc":"    * `rot` is a vector (radians). X is pitch (elevation), Y is yaw (heading)\n      and Z is roll (bank).","body":"_rotation(${1:rot})"},{"prefix":"get_rotation","token":":","detail":"get_rotation()","kind":2,"desc":"returns the rotation, a vector (radians)","body":"_rotation()"},{"prefix":"set_yaw","token":":","detail":"set_yaw(radians)","kind":2,"desc":"sets the yaw (heading).","body":"_yaw(${1:radians})"},{"prefix":"get_yaw","token":":","detail":"get_yaw()","kind":2,"desc":"returns number in radians","body":"_yaw()"},{"prefix":"set_texture_mod","token":":","detail":"set_texture_mod(mod)","kind":2,"desc":"","body":"_texture_mod(${1:mod})"},{"prefix":"get_texture_mod","token":":","detail":"get_texture_mod()","kind":2,"desc":"returns current texture modifier","body":"_texture_mod()"},{"prefix":"set_sprite","token":":","detail":"set_sprite(p, num_frames, framelength, select_horiz_by_yawpitch)","kind":2,"desc":"    * Select sprite from spritesheet with optional animation and Dungeon Master\n      style texture selection based on yaw relative to camera\n    * `p`: {x=number, y=number}, the coordinate of the first frame\n      (x: column, y: row), default: `{x=0, y=0}`\n    * `num_frames`: number, default: `1`\n    * `framelength`: number, default: `0.2`\n    * `select_horiz_by_yawpitch`: boolean, this was once used for the Dungeon\n      Master mob, default: `false`","body":"_sprite(${1:p}, ${2:num_frames}, ${3:framelength}, ${4:select_horiz_by_yawpitch})"},{"prefix":"get_entity_name","token":":","detail":"get_entity_name()","kind":2,"desc":"(**Deprecated**: Will be removed in a future version)","body":"_entity_name()"},{"prefix":"get_luaentity","token":":","detail":"get_luaentity()","kind":2,"desc":"","body":"_luaentity()"},{"prefix":"get_player_name","token":":","detail":"get_player_name()","kind":2,"desc":"returns `\\\"\\\"` if is not a player","body":"_player_name()"},{"prefix":"get_player_velocity","token":":","detail":"get_player_velocity()","kind":2,"desc":"returns `nil` if is not a player, otherwise a\n  table {x, y, z} representing the player's instantaneous velocity in nodes/s","body":"_player_velocity()"},{"prefix":"add_player_velocity","token":":","detail":"add_player_velocity(vel)","kind":2,"desc":"    * Adds to player velocity, this happens client-side and only once.\n    * Does not apply during free_move.\n    * Note that since the player speed is normalized at each move step,\n      increasing e.g. Y velocity beyond what would usually be achieved\n      (see: physics overrides) will cause existing X/Z velocity to be reduced.\n    * Example: `add_player_velocity({x=0, y=6.5, z=0})` is equivalent to\n      pressing the jump key (assuming default settings)","body":"_player_velocity(${1:vel})"},{"prefix":"get_look_dir","token":":","detail":"get_look_dir()","kind":2,"desc":"get camera direction as a unit vector","body":"_look_dir()"},{"prefix":"get_look_vertical","token":":","detail":"get_look_vertical()","kind":2,"desc":"pitch in radians\n    * Angle ranges between -pi/2 and pi/2, which are straight up and down\n      respectively.","body":"_look_vertical()"},{"prefix":"get_look_horizontal","token":":","detail":"get_look_horizontal()","kind":2,"desc":"yaw in radians\n    * Angle is counter-clockwise from the +z direction.","body":"_look_horizontal()"},{"prefix":"set_look_vertical","token":":","detail":"set_look_vertical(radians)","kind":2,"desc":"sets look pitch\n    * radians: Angle from looking forward, where positive is downwards.","body":"_look_vertical(${1:radians})"},{"prefix":"set_look_horizontal","token":":","detail":"set_look_horizontal(radians)","kind":2,"desc":"sets look yaw\n    * radians: Angle from the +z direction, where positive is counter-clockwise.","body":"_look_horizontal(${1:radians})"},{"prefix":"get_look_pitch","token":":","detail":"get_look_pitch()","kind":2,"desc":"pitch in radians - Deprecated as broken. Use\n  `get_look_vertical`.\n    * Angle ranges between -pi/2 and pi/2, which are straight down and up\n      respectively.","body":"_look_pitch()"},{"prefix":"get_look_yaw","token":":","detail":"get_look_yaw()","kind":2,"desc":"yaw in radians - Deprecated as broken. Use\n  `get_look_horizontal`.\n    * Angle is counter-clockwise from the +x direction.","body":"_look_yaw()"},{"prefix":"set_look_pitch","token":":","detail":"set_look_pitch(radians)","kind":2,"desc":"sets look pitch - Deprecated. Use\n  `set_look_vertical`.","body":"_look_pitch(${1:radians})"},{"prefix":"set_look_yaw","token":":","detail":"set_look_yaw(radians)","kind":2,"desc":"sets look yaw - Deprecated. Use\n  `set_look_horizontal`.","body":"_look_yaw(${1:radians})"},{"prefix":"get_breath","token":":","detail":"get_breath()","kind":2,"desc":"returns player's breath","body":"_breath()"},{"prefix":"set_breath","token":":","detail":"set_breath(value)","kind":2,"desc":"sets player's breath\n    * values:\n        * `0`: player is drowning\n        * max: bubbles bar is not shown\n        * See [Object properties] for more information","body":"_breath(${1:value})"},{"prefix":"set_fov","token":":","detail":"set_fov(fov, is_multiplier)","kind":2,"desc":"Sets player's FOV\n    * `fov`: FOV value.\n    * `is_multiplier`: Set to `true` if the FOV value is a multiplier.\n      Defaults to `false`.\n    * Set to 0 to clear FOV override.","body":"_fov(${1:fov}, ${2:is_multiplier})"},{"prefix":"get_fov","token":":","detail":"get_fov()","kind":2,"desc":"    * Returns player's FOV override in degrees, and a boolean depending on whether\n      the value is a multiplier.\n    * Returns 0 as first value if player's FOV hasn't been overridden.","body":"_fov()"},{"prefix":"set_attribute","token":":","detail":"set_attribute(attribute, value)","kind":2,"desc":" DEPRECATED, use get_meta() instead\n    * Sets an extra attribute with value on player.\n    * `value` must be a string, or a number which will be converted to a\n      string.\n    * If `value` is `nil`, remove attribute from player.","body":"_attribute(${1:attribute}, ${2:value})"},{"prefix":"get_attribute","token":":","detail":"get_attribute(attribute)","kind":2,"desc":" DEPRECATED, use get_meta() instead\n    * Returns value (a string) for extra attribute.\n    * Returns `nil` if no attribute found.","body":"_attribute(${1:attribute})"},{"prefix":"get_meta","token":":","detail":"get_meta()","kind":2,"desc":"Returns a PlayerMetaRef.","body":"_meta()"},{"prefix":"set_inventory_formspec","token":":","detail":"set_inventory_formspec(formspec)","kind":2,"desc":"    * Redefine player's inventory form\n    * Should usually be called in `on_joinplayer`","body":"_inventory_formspec(${1:formspec})"},{"prefix":"get_inventory_formspec","token":":","detail":"get_inventory_formspec()","kind":2,"desc":"returns a formspec string","body":"_inventory_formspec()"},{"prefix":"set_formspec_prepend","token":":","detail":"set_formspec_prepend(formspec)","kind":2,"desc":"    * the formspec string will be added to every formspec shown to the user,\n      except for those with a no_prepend[] tag.\n    * This should be used to set style elements such as background[] and\n      bgcolor[], any non-style elements (eg: label) may result in weird behaviour.\n    * Only affects formspecs shown after this is called.","body":"_formspec_prepend(${1:formspec})"},{"prefix":"get_formspec_prepend","token":":","detail":"get_formspec_prepend(formspec)","kind":2,"desc":"returns a formspec string.","body":"_formspec_prepend(${1:formspec})"},{"prefix":"get_player_control","token":":","detail":"get_player_control()","kind":2,"desc":"returns table with player pressed keys\n    * The table consists of fields with boolean value representing the pressed\n      keys, the fields are jump, right, left, LMB, RMB, sneak, aux1, down, up.\n    * example: `{jump=false, right=true, left=false, LMB=false, RMB=false,\n      sneak=true, aux1=false, down=false, up=false}`","body":"_player_control()"},{"prefix":"get_player_control_bits","token":":","detail":"get_player_control_bits()","kind":2,"desc":"returns integer with bit packed player pressed\n  keys.\n    * bit nr/meaning: 0/up, 1/down, 2/left, 3/right, 4/jump, 5/aux1, 6/sneak,\n      7/LMB, 8/RMB","body":"_player_control_bits()"},{"prefix":"set_physics_override","token":":","detail":"set_physics_override(override_table)","kind":2,"desc":"    * `override_table` is a table with the following fields:\n        * `speed`: multiplier to default walking speed value (default: `1`)\n        * `jump`: multiplier to default jump value (default: `1`)\n        * `gravity`: multiplier to default gravity value (default: `1`)\n        * `sneak`: whether player can sneak (default: `true`)\n        * `sneak_glitch`: whether player can use the new move code replications\n          of the old sneak side-effects: sneak ladders and 2 node sneak jump\n          (default: `false`)\n        * `new_move`: use new move/sneak code. When `false` the exact old code\n          is used for the specific old sneak behaviour (default: `true`)","body":"_physics_override(${1:override_table})"},{"prefix":"get_physics_override","token":":","detail":"get_physics_override()","kind":2,"desc":"returns the table given to `set_physics_override`","body":"_physics_override()"},{"prefix":"hud_add","token":":","detail":"hud_add(hud definition)","kind":2,"desc":"add a HUD element described by HUD def, returns ID\n   number on success","body":"_add(${1:hud definition})"},{"prefix":"hud_remove","token":":","detail":"hud_remove(id)","kind":2,"desc":"remove the HUD element of the specified id","body":"_remove(${1:id})"},{"prefix":"hud_change","token":":","detail":"hud_change(id, stat, value)","kind":2,"desc":"change a value of a previously added HUD\n  element.\n    * element `stat` values:\n      `position`, `name`, `scale`, `text`, `number`, `item`, `dir`","body":"_change(${1:id}, ${2:stat}, ${3:value})"},{"prefix":"hud_get","token":":","detail":"hud_get(id)","kind":2,"desc":"gets the HUD element definition structure of the specified ID","body":"_get(${1:id})"},{"prefix":"hud_set_flags","token":":","detail":"hud_set_flags(flags)","kind":2,"desc":"sets specified HUD flags of player.\n    * `flags`: A table with the following fields set to boolean values\n        * hotbar\n        * healthbar\n        * crosshair\n        * wielditem\n        * breathbar\n        * minimap\n        * minimap_radar\n    * If a flag equals `nil`, the flag is not modified\n    * `minimap`: Modifies the client's permission to view the minimap.\n      The client may locally elect to not view the minimap.\n    * `minimap_radar` is only usable when `minimap` is true","body":"_set_flags(${1:flags})"},{"prefix":"hud_get_flags","token":":","detail":"hud_get_flags()","kind":2,"desc":"returns a table of player HUD flags with boolean values.\n    * See `hud_set_flags` for a list of flags that can be toggled.","body":"_get_flags()"},{"prefix":"hud_set_hotbar_itemcount","token":":","detail":"hud_set_hotbar_itemcount(count)","kind":2,"desc":"sets number of items in builtin hotbar\n    * `count`: number of items, must be between `1` and `32`\n* `hud_get_hotbar_itemcount`: returns number of visible items","body":"_set_hotbar_itemcount(${1:count})"},{"prefix":"hud_set_hotbar_image","token":":","detail":"hud_set_hotbar_image(texturename)","kind":2,"desc":"    * sets background image for hotbar\n* `hud_get_hotbar_image`: returns texturename","body":"_set_hotbar_image(${1:texturename})"},{"prefix":"hud_set_hotbar_selected_image","token":":","detail":"hud_set_hotbar_selected_image(texturename)","kind":2,"desc":"    * sets image for selected item of hotbar\n* `hud_get_hotbar_selected_image`: returns texturename","body":"_set_hotbar_selected_image(${1:texturename})"},{"prefix":"set_sky","token":":","detail":"set_sky(bgcolor, type, {texture names}, clouds)","kind":2,"desc":"    * `bgcolor`: ColorSpec, defaults to white\n    * `type`: Available types:\n        * `\"regular\"`: Uses 0 textures, `bgcolor` ignored\n        * `\"skybox\"`: Uses 6 textures, `bgcolor` used\n        * `\"plain\"`: Uses 0 textures, `bgcolor` used\n    * `clouds`: Boolean for whether clouds appear in front of `\"skybox\"` or\n      `\"plain\"` custom skyboxes (default: `true`)","body":"_sky(${1:bgcolor}, ${2:type}, ${3:}{${4:texture names}}, ${5:clouds})"},{"prefix":"get_sky","token":":","detail":"get_sky()","kind":2,"desc":"returns bgcolor, type, table of textures, clouds","body":"_sky()"},{"prefix":"set_clouds","token":":","detail":"set_clouds(parameters)","kind":2,"desc":"set cloud parameters\n    * `parameters` is a table with the following optional fields:\n        * `density`: from `0` (no clouds) to `1` (full clouds) (default `0.4`)\n        * `color`: basic cloud color with alpha channel, ColorSpec\n          (default `#fff0f0e5`).\n        * `ambient`: cloud color lower bound, use for a \"glow at night\" effect.\n          ColorSpec (alpha ignored, default `#000000`)\n        * `height`: cloud height, i.e. y of cloud base (default per conf,\n          usually `120`)\n        * `thickness`: cloud thickness in nodes (default `16`)\n        * `speed`: 2D cloud speed + direction in nodes per second\n          (default `{x=0, z=-2}`).","body":"_clouds(${1:parameters})"},{"prefix":"get_clouds","token":":","detail":"get_clouds()","kind":2,"desc":"returns a table with the current cloud parameters as in\n  `set_clouds`.","body":"_clouds()"},{"prefix":"override_day_night_ratio","token":":","detail":"override_day_night_ratio(ratio or nil)","kind":2,"desc":"    * `0`...`1`: Overrides day-night ratio, controlling sunlight to a specific\n      amount.\n    * `nil`: Disables override, defaulting to sunlight based on day-night cycle","body":"_day_night_ratio(${1:ratio or nil})"},{"prefix":"get_day_night_ratio","token":":","detail":"get_day_night_ratio()","kind":2,"desc":"returns the ratio or nil if it isn't overridden","body":"_day_night_ratio()"},{"prefix":"set_local_animation","token":":","detail":"set_local_animation(stand/idle, walk, dig, walk+dig, frame_speed=frame_speed)","kind":2,"desc":"  set animation for player model in third person view","body":"_local_animation(${1:stand}/${2:idle}, ${3:walk}, ${4:dig}, ${5:walk}+${6:dig}, ${7:frame_speed}=${8:frame_speed})"},{"prefix":"get_local_animation","token":":","detail":"get_local_animation()","kind":2,"desc":"returns stand, walk, dig, dig+walk tables and\n  `frame_speed`.","body":"_local_animation()"},{"prefix":"set_eye_offset","token":":","detail":"set_eye_offset({x=0,y=0,z=0},{x=0,y=0,z=0})","kind":2,"desc":"defines offset value for\n  camera per player.\n    * in first person view\n    * in third person view (max. values `{x=-10/10,y=-10,15,z=-5/5}`)","body":"_eye_offset({${1:x}=${2:0}, ${3:y}=${4:0}, ${5:z}=${6:0}}, {${7:x}=${8:0}, ${9:y}=${10:0}, ${11:z}=${12:0}})"},{"prefix":"get_eye_offset","token":":","detail":"get_eye_offset()","kind":2,"desc":"returns `offset_first` and `offset_third`","body":"_eye_offset()"},{"prefix":"send_mapblock","token":":","detail":"send_mapblock(blockpos)","kind":2,"desc":"    * Sends a server-side loaded mapblock to the player.\n    * Returns `false` if failed.\n    * Resource intensive - use sparsely\n    * To get blockpos, integer divide pos by 16","body":"_mapblock(${1:blockpos})"},{"prefix":"next","token":":","detail":"next()","kind":2,"desc":"return next integer random number [`-2147483648`...`2147483647`]","body":"()"},{"prefix":"next","token":":","detail":"next(min, max)","kind":2,"desc":"return next integer random number [`min`...`max`]","body":"(${1:min}, ${2:max})"},{"prefix":"rand_normal_dist","token":":","detail":"rand_normal_dist(min, max, num_trials=6)","kind":2,"desc":"return normally distributed\n  random number [`min`...`max`].\n    * This is only a rough approximation of a normal distribution with:\n    * `mean = (max - min) / 2`, and\n    * `variance = (((max - min + 1) ^ 2) - 1) / (12 * num_trials)`\n    * Increasing `num_trials` improves accuracy of the approximation","body":"_normal_dist(${1:min}, ${2:max}, ${3:num_trials}=${4:6})"},{"prefix":"get_2d","token":":","detail":"get_2d(pos)","kind":2,"desc":"returns 2D noise value at `pos={x=,y=}`","body":"_2d(${1:pos})"},{"prefix":"get_3d","token":":","detail":"get_3d(pos)","kind":2,"desc":"returns 3D noise value at `pos={x=,y=,z=}`","body":"_3d(${1:pos})"},{"prefix":"get_2d_map","token":":","detail":"get_2d_map(pos)","kind":2,"desc":"returns a `<size.x>` times `<size.y>` 2D array of 2D noise\n  with values starting at `pos={x=,y=}`","body":"_2d_map(${1:pos})"},{"prefix":"get_3d_map","token":":","detail":"get_3d_map(pos)","kind":2,"desc":"returns a `<size.x>` times `<size.y>` times `<size.z>`\n  3D array of 3D noise with values starting at `pos={x=,y=,z=}`.","body":"_3d_map(${1:pos})"},{"prefix":"get_2d_map_flat","token":":","detail":"get_2d_map_flat(pos, buffer)","kind":2,"desc":"returns a flat `<size.x * size.y>` element\n  array of 2D noise with values starting at `pos={x=,y=}`","body":"_2d_map_flat(${1:pos}, ${2:buffer})"},{"prefix":"get_3d_map_flat","token":":","detail":"get_3d_map_flat(pos, buffer)","kind":2,"desc":"Same as `get2dMap_flat`, but 3D noise","body":"_3d_map_flat(${1:pos}, ${2:buffer})"},{"prefix":"calc_2d_map","token":":","detail":"calc_2d_map(pos)","kind":2,"desc":"Calculates the 2d noise map starting at `pos`. The result\n  is stored internally.","body":"_2d_map(${1:pos})"},{"prefix":"calc_3d_map","token":":","detail":"calc_3d_map(pos)","kind":2,"desc":"Calculates the 3d noise map starting at `pos`. The result\n  is stored internally.","body":"_3d_map(${1:pos})"},{"prefix":"get_map_slice","token":":","detail":"get_map_slice(slice_offset, slice_size, buffer)","kind":2,"desc":"In the form of an array,\n  returns a slice of the most recently computed noise results. The result slice\n  begins at coordinates `slice_offset` and takes a chunk of `slice_size`.\n  E.g. to grab a 2-slice high horizontal 2d plane of noise starting at buffer\n  offset y = 20:\n  `noisevals = noise:get_map_slice({y=20}, {y=2})`\n  It is important to note that `slice_offset` offset coordinates begin at 1,\n  and are relative to the starting position of the most recently calculated\n  noise.\n  To grab a single vertical column of noise starting at map coordinates\n  x = 1023, y=1000, z = 1000:\n  `noise:calc_3d_map({x=1000, y=1000, z=1000})`\n  `noisevals = noise:get_map_slice({x=24, z=1}, {x=1, z=1})`","body":"_map_slice(${1:slice_offset}, ${2:slice_size}, ${3:buffer})"},{"prefix":"next","token":":","detail":"next()","kind":2,"desc":"return next integer random number [`0`...`32767`]","body":"()"},{"prefix":"next","token":":","detail":"next(min, max)","kind":2,"desc":"return next integer random number [`min`...`max`]\n    * `((max - min) == 32767) or ((max-min) <= 6553))` must be true\n      due to the simple implementation making bad distribution otherwise.","body":"(${1:min}, ${2:max})"},{"prefix":"next","token":":","detail":"next()","kind":2,"desc":"returns a `pointed_thing` with exact pointing location\n    * Returns the next thing pointed by the ray or nil.","body":"()"},{"prefix":"next_bytes","token":":","detail":"next_bytes([count])","kind":2,"desc":"return next `count` (default 1, capped at 2048) many\n  random bytes, as a string.","body":"_bytes([${1:count}])"},{"prefix":"get","token":":","detail":"get(key)","kind":2,"desc":"returns a value","body":"(${1:key})"},{"prefix":"get_bool","token":":","detail":"get_bool(key, [default])","kind":2,"desc":"returns a boolean\n    * `default` is the value returned if `key` is not found.\n    * Returns `nil` if `key` is not found and `default` not specified.","body":"_bool(${1:key}, ${2:}[${3:default}])"},{"prefix":"get_np_group","token":":","detail":"get_np_group(key)","kind":2,"desc":"returns a NoiseParams table","body":"_np_group(${1:key})"},{"prefix":"set","token":":","detail":"set(key, value)","kind":2,"desc":"    * Setting names can't contain whitespace or any of `=\"{}#`.\n    * Setting values can't contain the sequence `\\n\"\"\"`.\n    * Setting names starting with \"secure.\" can't be set on the main settings\n      object (`minetest.settings`).","body":"(${1:key}, ${2:value})"},{"prefix":"set_bool","token":":","detail":"set_bool(key, value)","kind":2,"desc":"    * See documentation for set() above.","body":"_bool(${1:key}, ${2:value})"},{"prefix":"set_np_group","token":":","detail":"set_np_group(key, value)","kind":2,"desc":"    * `value` is a NoiseParams table.\n    * Also, see documentation for set() above.","body":"_np_group(${1:key}, ${2:value})"},{"prefix":"remove","token":":","detail":"remove(key)","kind":2,"desc":"returns a boolean (`true` for success)","body":"(${1:key})"},{"prefix":"get_names","token":":","detail":"get_names()","kind":2,"desc":"returns `{key1,...}`","body":"_names()"},{"prefix":"write","token":":","detail":"write()","kind":2,"desc":"returns a boolean (`true` for success)\n    * Writes changes to file.","body":"()"},{"prefix":"to_table","token":":","detail":"to_table()","kind":2,"desc":"returns `{[key1]=value1,...}`","body":"_table()"}]