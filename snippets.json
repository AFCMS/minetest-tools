[{"desc":"damage speed = `speed * (1 + value/100)`\n* `falling_node`: if there is no walkable block under the node it will fall\n* `float`: the node will not fall through liquids\n* `level`: Can be used to give an additional sense of progression in the game.\n     * A larger level will cause e.g. a weapon of a lower level make much less\n       damage, and get worn out much faster, or not be able to get drops\n       from destroyed nodes.\n     * `0` is something that is directly accessible at the start of gameplay\n     * There is no upper limit\n     * See also: `leveldiff` in [Tools]\n* `slippery`: Players and items will slide on the node.\n  Slipperiness rises steadily with `slippery` value, starting at 1.\n\n\n### Tool-only groups\n\n* `disable_repair`: If set to 1 for a tool, it cannot be repaired using the\n  `\"toolrepair\"` crafting recipe\n\n\n### `ObjectRef` groups\n\n* `immortal`: Skips all damage and breath handling for an object. This group\n  will also hide the integrated HUD status bars for players, and is\n  automatically set to all players when damage is disabled on the server.\n* `punch_operable`: For entities; disables the regular damage mechanism for\n  players punching it by hand or a non-tool item, so that it can do something\n  else than take damage.\n\n\n\nKnown damage and digging time defining groups\n---------------------------------------------\n\n* `crumbly`: dirt, sand\n* `cracky`: tough but crackable stuff like stone.\n* `snappy`: something that can be cut using fine tools; e.g. leaves, small\n  plants, wire, sheets of metal\n* `choppy`: something that can be cut using force; e.g. trees, wooden planks\n* `fleshy`: Living things like animals and the player. This could imply\n  some blood effects when hitting.\n* `explody`: Especially prone to explosions\n* `oddly_breakable_by_hand`:\n   Can be added to nodes that shouldn't logically be breakable by the\n   hand but are. Somewhat similar to `dig_immediate`, but times are more\n   like `{[1]=3.50,[2]=2.00,[3]=0.70}` and this does not override the\n   speed of a tool if the tool can dig at a faster speed than this\n   suggests for the hand.\n\nExamples of custom groups\n-------------------------\n\nItem groups are often used for defining, well, _groups of items_.\n\n* `meat`: any meat-kind of a thing (rating might define the size or healing\n  ability or be irrelevant -- it is not defined as of yet)\n* `eatable`: anything that can be eaten. Rating might define HP gain in half\n  hearts.\n* `flammable`: can be set on fire. Rating might define the intensity of the\n  fire, affecting e.g. the speed of the spreading of an open fire.\n* `wool`: any wool (any origin, any color)\n* `metal`: any metal\n* `weapon`: any weapon\n* `heavy`: anything considerably heavy\n\nDigging time calculation specifics\n----------------------------------\n\nGroups such as `crumbly`, `cracky` and `snappy` are used for this\npurpose. Rating is `1`, `2` or `3`. A higher rating for such a group implies\nfaster digging time.\n\nThe `level` group is used to limit the toughness of nodes a tool can dig\nand to scale the digging times / damage to a greater extent.\n\n**Please do understand this**, otherwise you cannot use the system to it's\nfull potential.\n\nTools define their properties by a list of parameters for groups. They\ncannot dig other groups; thus it is important to use a standard bunch of\ngroups to enable interaction with tools.\n\n\n\n\nTools\n=====\n\nTools definition\n----------------\n\nTools define:\n\n* Full punch interval\n* Maximum drop level\n* For an arbitrary list of groups:\n    * Uses (until the tool breaks)\n        * Maximum level (usually `0`, `1`, `2` or `3`)\n        * Digging times\n        * Damage groups\n\n### Full punch interval\n\nWhen used as a weapon, the tool will do full damage if this time is spent\nbetween punches. If e.g. half the time is spent, the tool will do half\ndamage.\n\n### Maximum drop level\n\nSuggests the maximum level of node, when dug with the tool, that will drop\nit's useful item. (e.g. iron ore to drop a lump of iron).\n\nThis is not automated; it is the responsibility of the node definition\nto implement this.\n\n### Uses\n\nDetermines how many uses the tool has when it is used for digging a node,\nof this group, of the maximum level. For lower leveled nodes, the use count\nis multiplied by `3^leveldiff`.\n`leveldiff` is the difference of the tool's `maxlevel` `groupcaps` and the\nnode's `level` group. The node cannot be dug if `leveldiff` is less than zero.\n\n* `uses=10, leveldiff=0`: actual uses: 10\n* `uses=10, leveldiff=1`: actual uses: 30\n* `uses=10, leveldiff=2`: actual uses: 90\n\n### Maximum level\n\nTells what is the maximum level of a node of this group that the tool will\nbe able to dig.\n\n### Digging times\n\nList of digging times for different ratings of the group, for nodes of the\nmaximum level.\n\nFor example, as a Lua table, `times={2=2.00, 3=0.70}`. This would\nresult in the tool to be able to dig nodes that have a rating of `2` or `3`\nfor this group, and unable to dig the rating `1`, which is the toughest.\nUnless there is a matching group that enables digging otherwise.\n\nIf the result digging time is 0, a delay of 0.15 seconds is added between\ndigging nodes; If the player releases LMB after digging, this delay is set to 0,\ni.e. players can more quickly click the nodes away instead of holding LMB.\n\n### Damage groups\n\nList of damage for groups of entities. See [Entity damage mechanism].\n\nExample definition of the capabilities of a tool\n------------------------------------------------\n\n    tool_capabilities = {\n        full_punch_interval=1.5,\n        max_drop_level=1,\n        groupcaps={\n            crumbly={maxlevel=2, uses=20, times={[1]=1.60, [2]=1.20, [3]=0.80}}\n        }\n        damage_groups = {fleshy=2},\n    }\n\nThis makes the tool be able to dig nodes that fulfil both of these:\n\n* Have the `crumbly` group\n* Have a `level` group less or equal to `2`\n\nTable of resulting digging times:\n\n    crumbly        0     1     2     3     4  <- level\n         ->  0     -     -     -     -     -\n             1  0.80  1.60  1.60     -     -\n             2  0.60  1.20  1.20     -     -\n             3  0.40  0.80  0.80     -     -\n\n    level diff:    2     1     0    -1    -2\n\nTable of resulting tool uses:\n\n    ->  0     -     -     -     -     -\n        1   180    60    20     -     -\n        2   180    60    20     -     -\n        3   180    60    20     -     -\n\n**Notes**:\n\n* At `crumbly==0`, the node is not diggable.\n* At `crumbly==3`, the level difference digging time divider kicks in and makes\n  easy nodes to be quickly breakable.\n* At `level > 2`, the node is not diggable, because it's `level > maxlevel`\n\n\n\n\nEntity damage mechanism\n=======================\n\nDamage calculation:\n\n    damage = 0\n    foreach group in cap.damage_groups:\n        damage += cap.damage_groups[group]\n            * limit(actual_interval / cap.full_punch_interval, 0.0, 1.0)\n            * (object.armor_groups[group] / 100.0)\n            -- Where object.armor_groups[group] is 0 for inexistent values\n    return damage\n\nClient predicts damage based on damage groups. Because of this, it is able to\ngive an immediate response when an entity is damaged or dies; the response is\npre-defined somehow (e.g. by defining a sprite animation) (not implemented;\nTODO).\nCurrently a smoke puff will appear when an entity dies.\n\nThe group `immortal` completely disables normal damage.\n\nEntities can define a special armor group, which is `punch_operable`. This\ngroup disables the regular damage mechanism for players punching it by hand or\na non-tool item, so that it can do something else than take damage.\n\nOn the Lua side, every punch calls:\n\n    entity:on_punch(puncher, time_from_last_punch, tool_capabilities, direction,\n                    damage)\n\nThis should never be called directly, because damage is usually not handled by\nthe entity itself.\n\n* `puncher` is the object performing the punch. Can be `nil`. Should never be\n  accessed unless absolutely required, to encourage interoperability.\n* `time_from_last_punch` is time from last punch (by `puncher`) or `nil`.\n* `tool_capabilities` can be `nil`.\n* `direction` is a unit vector, pointing from the source of the punch to\n   the punched object.\n* `damage` damage that will be done to entity\nReturn value of this function will determine if damage is done by this function\n(retval true) or shall be done by engine (retval false)\n\nTo punch an entity/object in Lua, call:\n\n  object:punch(puncher, time_from_last_punch, tool_capabilities, direction)\n\n* Return value is tool wear.\n* Parameters are equal to the above callback.\n* If `direction` equals `nil` and `puncher` does not equal `nil`, `direction`\n  will be automatically filled in based on the location of `puncher`.\n\n\n\n\nMetadata\n========\n\nNode Metadata\n-------------\n\nThe instance of a node in the world normally only contains the three values\nmentioned in [Nodes]. However, it is possible to insert extra data into a node.\nIt is called \"node metadata\"; See `NodeMetaRef`.\n\nNode metadata contains two things:\n\n* A key-value store\n* An inventory\n\nSome of the values in the key-value store are handled specially:\n\n* `formspec`: Defines a right-click inventory menu. See [Formspec].\n* `infotext`: Text shown on the screen when the node is pointed at\n\nExample:\n\n    local meta = minetest.get_meta(pos)\n    meta:set_string(\"formspec\",\n            \"size[8,9]\"..\n            \"list[context;main;0,0;8,4;]\"..\n            \"list[current_player;main;0,5;8,4;]\")\n    meta:set_string(\"infotext\", \"Chest\");\n    local inv = meta:get_inventory()\n    inv:set_size(\"main\", 8*4)\n    print(dump(meta:to_table()))\n    meta:from_table({\n        inventory = {\n            main = {[1] = \"default:dirt\", [2] = \"\", [3] = \"\", [4] = \"\",\n                    [5] = \"\", [6] = \"\", [7] = \"\", [8] = \"\", [9] = \"\",\n                    [10] = \"\", [11] = \"\", [12] = \"\", [13] = \"\",\n                    [14] = \"default:cobble\", [15] = \"\", [16] = \"\", [17] = \"\",\n                    [18] = \"\", [19] = \"\", [20] = \"default:cobble\", [21] = \"\",\n                    [22] = \"\", [23] = \"\", [24] = \"\", [25] = \"\", [26] = \"\",\n                    [27] = \"\", [28] = \"\", [29] = \"\", [30] = \"\", [31] = \"\",\n                    [32] = \"\"}\n        },\n        fields = {\n            formspec = \"size[8,9]list[context;main;0,0;8,4;]list[current_player;main;0,5;8,4;]\",\n            infotext = \"Chest\"\n        }\n    })\n\nItem Metadata\n-------------\n\nItem stacks can store metadata too. See [`ItemStackMetaRef`].\n\nItem metadata only contains a key-value store.\n\nSome of the values in the key-value store are handled specially:\n\n* `description`: Set the item stack's description. Defaults to\n  `idef.description`.\n* `color`: A `ColorString`, which sets the stack's color.\n* `palette_index`: If the item has a palette, this is used to get the\n  current color from the palette.\n\nExample:\n\n    local meta = stack:get_meta()\n    meta:set_string(\"key\", \"value\")\n    print(dump(meta:to_table()))\n\n\n\n\nFormspec\n========\n\nFormspec defines a menu. This supports inventories and some of the\ntypical widgets like buttons, checkboxes, text input fields, etc.\nIt is a string, with a somewhat strange format.\n\nA formspec is made out of formspec elements, which includes widgets\nlike buttons but also can be used to set stuff like background color.\n\nMany formspec elements have a `name`, which is a unique identifier which\nis used when the server receives user input. You must not use the name\n\"quit\" for formspec elements.\n\nSpaces and newlines can be inserted between the blocks, as is used in the\nexamples.\n\nPosition and size units are inventory slots unless the new coordinate system\nis enabled. `X` and `Y` position the formspec element relative to the top left\nof the menu or container. `W` and `H` are its width and height values.\n\nIf the new system is enabled, all elements have unified coordinates for all\nelements with no padding or spacing in between. This is highly recommended\nfor new forms. See `real_coordinates[<bool>]` and `Migrating to Real\nCoordinates`.\n\nInventories with a `player:<name>` inventory location are only sent to the\nplayer named `<name>`.\n\nWhen displaying text which can contain formspec code, e.g. text set by a player,\nuse `minetest.formspec_escape`.\nFor coloured text you can use `minetest.colorize`.\n\n**WARNING**: do _not_ use a element name starting with `key_`; those names are\nreserved to pass key press events to formspec!\n\n**WARNING**: Minetest allows you to add elements to every single formspec instance\nusing `player:set_formspec_prepend()`, which may be the reason backgrounds are\nappearing when you don't expect them to, or why things are styled differently\nto normal. See [`no_prepend[]`] and [Styling Formspecs].\n\nExamples\n--------\n\n### Chest\n\n    size[8,9]\n    list[context;main;0,0;8,4;]\n    list[current_player;main;0,5;8,4;]\n\n### Furnace\n\n    size[8,9]\n    list[context;fuel;2,3;1,1;]\n    list[context;src;2,1;1,1;]\n    list[context;dst;5,1;2,2;]\n    list[current_player;main;0,5;8,4;]\n\n### Minecraft-like player inventory\n\n    size[8,7.5]\n    image[1,0.6;1,2;player.png]\n    list[current_player;main;0,3.5;8,4;]\n    list[current_player;craft;3,0;3,3;]\n    list[current_player;craftpreview;7,1;1,1;]\n\nElements\n--------\n\n### `formspec_version[<version>]`\n\n* Set the formspec version to a certain number. If not specified,\n  version 1 is assumed.\n* Must be specified before `size` element.\n* Clients older than this version can neither show newer elements nor display\n  elements with new arguments correctly.\n* Available since feature `formspec_version_element`.\n\n### `size[<W>,<H>,<fixed_size>]`\n\n* Define the size of the menu in inventory slots\n* `fixed_size`: `true`/`false` (optional)\n* deprecated: `invsize[<W>,<H>;]`\n\n### `position[<X>,<Y>]`\n\n* Must be used after `size` element.\n* Defines the position on the game window of the formspec's `anchor` point.\n* For X and Y, 0.0 and 1.0 represent opposite edges of the game window,\n  for example:\n    * [0.0, 0.0] sets the position to the top left corner of the game window.\n    * [1.0, 1.0] sets the position to the bottom right of the game window.\n* Defaults to the center of the game window [0.5, 0.5].\n\n### `anchor[<X>,<Y>]`\n\n* Must be used after both `size` and `position` (if present) elements.\n* Defines the location of the anchor point within the formspec.\n* For X and Y, 0.0 and 1.0 represent opposite edges of the formspec,\n  for example:\n    * [0.0, 1.0] sets the anchor to the bottom left corner of the formspec.\n    * [1.0, 0.0] sets the anchor to the top right of the formspec.\n* Defaults to the center of the formspec [0.5, 0.5].\n\n* `position` and `anchor` elements need suitable values to avoid a formspec\n  extending off the game window due to particular game window sizes.\n\n### `no_prepend[]`\n\n* Must be used after the `size`, `position`, and `anchor` elements (if present).\n* Disables player:set_formspec_prepend() from applying to this formspec.\n\n### `real_coordinates[<bool>]`\n\n* INFORMATION: Enable it automatically using `formspec_version` version 2 or newer.\n* When set to true, all following formspec elements will use the new coordinate system.\n* If used immediately after `size`, `position`, `anchor`, and `no_prepend` elements\n  (if present), the form size will use the new coordinate system.\n* **Note**: Formspec prepends are not affected by the coordinates in the main form.\n  They must enable it explicitly.\n* For information on converting forms to the new coordinate system, see `Migrating\n  to Real Coordinates`.\n\n### `container[<X>,<Y>]`\n\n* Start of a container block, moves all physical elements in the container by\n  (X, Y).\n* Must have matching `container_end`\n* Containers can be nested, in which case the offsets are added\n  (child containers are relative to parent containers)\n\n### `container_end[]`\n\n* End of a container, following elements are no longer relative to this\n  container.\n\n### `list[<inventory location>;<list name>;<X>,<Y>;<W>,<H>;]`\n\n* Show an inventory list if it has been sent to the client. Nothing will\n  be shown if the inventory list is of size 0.\n* **Note**: With the new coordinate system, the spacing between inventory\n  slots is one-fourth the size of an inventory slot.\n\n### `list[<inventory location>;<list name>;<X>,<Y>;<W>,<H>;<starting item index>]`\n\n* Show an inventory list if it has been sent to the client. Nothing will\n  be shown if the inventory list is of size 0.\n* **Note**: With the new coordinate system, the spacing between inventory\n  slots is one-fourth the size of an inventory slot.\n\n### `listring[<inventory location>;<list name>]`\n\n* Allows to create a ring of inventory lists\n* Shift-clicking on items in one element of the ring\n  will send them to the next inventory list inside the ring\n* The first occurrence of an element inside the ring will\n  determine the inventory where items will be sent to\n\n### `listring[]`\n\n* Shorthand for doing `listring[<inventory location>;<list name>]`\n  for the last two inventory lists added by list[...]\n\n### `listcolors[<slot_bg_normal>;<slot_bg_hover>]`\n\n* Sets background color of slots as `ColorString`\n* Sets background color of slots on mouse hovering\n\n### `listcolors[<slot_bg_normal>;<slot_bg_hover>;<slot_border>]`\n\n* Sets background color of slots as `ColorString`\n* Sets background color of slots on mouse hovering\n* Sets color of slots border\n\n### `listcolors[<slot_bg_normal>;<slot_bg_hover>;<slot_border>;<tooltip_bgcolor>;<tooltip_fontcolor>]`\n\n* Sets background color of slots as `ColorString`\n* Sets background color of slots on mouse hovering\n* Sets color of slots border\n* Sets default background color of tooltips\n* Sets default font color of tooltips\n\n### `tooltip[<gui_element_name>;<tooltip_text>;<bgcolor>;<fontcolor>]`\n\n* Adds tooltip for an element\n* `<bgcolor>` tooltip background color as `ColorString` (optional)\n* `<fontcolor>` tooltip font color as `ColorString` (optional)\n\n### `tooltip[<X>,<Y>;<W>,<H>;<tooltip_text>;<bgcolor>;<fontcolor>]`\n\n* Adds tooltip for an area. Other tooltips will take priority when present.\n* `<bgcolor>` tooltip background color as `ColorString` (optional)\n* `<fontcolor>` tooltip font color as `ColorString` (optional)\n\n### `image[<X>,<Y>;<W>,<H>;<texture name>]`\n\n* Show an image\n\n### `item_image[<X>,<Y>;<W>,<H>;<item name>]`\n\n* Show an inventory image of registered item/node\n\n### `bgcolor[<color>;<fullscreen>]`\n\n* Sets background color of formspec as `ColorString`\n* If `true`, a fullscreen background is drawn and the color is ignored\n  (does not affect the size of the formspec)\n\n### `background[<X>,<Y>;<W>,<H>;<texture name>]`\n\n* Example for formspec 8x4 in 16x resolution: image shall be sized\n  8 times 16px  times  4 times 16px.\n\n### `background[<X>,<Y>;<W>,<H>;<texture name>;<auto_clip>]`\n\n* Example for formspec 8x4 in 16x resolution:\n  image shall be sized 8 times 16px  times  4 times 16px\n* If `auto_clip` is `true`, the background is clipped to the formspec size\n  (`x` and `y` are used as offset values, `w` and `h` are ignored)\n\n### `background9[<X>,<Y>;<W>,<H>;<texture name>;<auto_clip>;<middle>]`\n\n* 9-sliced background. See https://en.wikipedia.org/wiki/9-slice_scaling\n* Middle is a rect which defines the middle of the 9-slice.\n\t* `x` - The middle will be x pixels from all sides.\n\t* `x,y` - The middle will be x pixels from the horizontal and y from the vertical.\n\t* `x,y,x2,y2` - The middle will start at x,y, and end at x2, y2. Negative x2 and y2 values\n\t\twill be added to the width and height of the texture, allowing it to be used as the\n\t\tdistance from the far end.\n\t* All numbers in middle are integers.\n* Example for formspec 8x4 in 16x resolution:\n  image shall be sized 8 times 16px  times  4 times 16px\n* If `auto_clip` is `true`, the background is clipped to the formspec size\n  (`x` and `y` are used as offset values, `w` and `h` are ignored)\n* Available since formspec version 2\n\n### `pwdfield[<X>,<Y>;<W>,<H>;<name>;<label>]`\n\n* Textual password style field; will be sent to server when a button is clicked\n* When enter is pressed in field, fields.key_enter_field will be sent with the\n  name of this field.\n* With the old coordinate system, fields are a set height, but will be vertically\n  centred on `H`. With the new coordinate system, `H` will modify the height.\n* `name` is the name of the field as returned in fields to `on_receive_fields`\n* `label`, if not blank, will be text printed on the top left above the field\n* See `field_close_on_enter` to stop enter closing the formspec\n\n### `field[<X>,<Y>;<W>,<H>;<name>;<label>;<default>]`\n\n* Textual field; will be sent to server when a button is clicked\n* When enter is pressed in field, `fields.key_enter_field` will be sent with\n  the name of this field.\n* With the old coordinate system, fields are a set height, but will be vertically\n  centred on `H`. With the new coordinate system, `H` will modify the height.\n* `name` is the name of the field as returned in fields to `on_receive_fields`\n* `label`, if not blank, will be text printed on the top left above the field\n* `default` is the default value of the field\n    * `default` may contain variable references such as `${text}` which\n      will fill the value from the metadata value `text`\n    * **Note**: no extra text or more than a single variable is supported ATM.\n* See `field_close_on_enter` to stop enter closing the formspec\n\n### `field[<name>;<label>;<default>]`\n\n* As above, but without position/size units\n* When enter is pressed in field, `fields.key_enter_field` will be sent with\n  the name of this field.\n* Special field for creating simple forms, such as sign text input\n* Must be used without a `size[]` element\n* A \"Proceed\" button will be added automatically\n* See `field_close_on_enter` to stop enter closing the formspec\n\n### `field_close_on_enter[<name>;<close_on_enter>]`\n\n* <name> is the name of the field\n* if <close_on_enter> is false, pressing enter in the field will submit the\n  form but not close it.\n* defaults to true when not specified (ie: no tag for a field)\n\n### `textarea[<X>,<Y>;<W>,<H>;<name>;<label>;<default>]`\n\n* Same as fields above, but with multi-line input\n* If the text overflows, a vertical scrollbar is added.\n* If the name is empty, the textarea is read-only and\n  the background is not shown, which corresponds to a multi-line label.\n\n### `label[<X>,<Y>;<label>]`\n\n* The label formspec element displays the text set in `label`\n  at the specified position.\n* **Note**: If the new coordinate system is enabled, labels are\n  positioned from the center of the text, not the top.\n* The text is displayed directly without automatic line breaking,\n  so label should not be used for big text chunks.  Newlines can be\n  used to make labels multiline.\n* **Note**: With the new coordinate system, newlines are spaced with\n  half a coordinate.  With the old system, newlines are spaced 2/5 of\n  an inventory slot.\n\n### `vertlabel[<X>,<Y>;<label>]`\n\n* Textual label drawn vertically\n* `label` is the text on the label\n* **Note**: If the new coordinate system is enabled, vertlabels are\n  positioned from the center of the text, not the left.\n\n### `button[<X>,<Y>;<W>,<H>;<name>;<label>]`\n\n* Clickable button. When clicked, fields will be sent.\n* With the old coordinate system, buttons are a set height, but will be vertically\n  centred on `H`. With the new coordinate system, `H` will modify the height.\n* `label` is the text on the button\n\n### `image_button[<X>,<Y>;<W>,<H>;<texture name>;<name>;<label>]`\n\n* `texture name` is the filename of an image\n* **Note**: Height is supported on both the old and new coordinate systems\n  for image_buttons.\n\n### `image_button[<X>,<Y>;<W>,<H>;<texture name>;<name>;<label>;<noclip>;<drawborder>;<pressed texture name>]`\n\n* `texture name` is the filename of an image\n* `noclip=true` means the image button doesn't need to be within specified\n  formsize.\n* `drawborder`: draw button border or not\n* `pressed texture name` is the filename of an image on pressed state\n\n### `item_image_button[<X>,<Y>;<W>,<H>;<item name>;<name>;<label>]`\n\n* `item name` is the registered name of an item/node\n* The item description will be used as the tooltip. This can be overridden with\n  a tooltip element.\n\n### `button_exit[<X>,<Y>;<W>,<H>;<name>;<label>]`\n\n* When clicked, fields will be sent and the form will quit.\n* Same as `button` in all other respects.\n\n### `image_button_exit[<X>,<Y>;<W>,<H>;<texture name>;<name>;<label>]`\n\n* When clicked, fields will be sent and the form will quit.\n* Same as `image_button` in all other respects.\n\n### `textlist[<X>,<Y>;<W>,<H>;<name>;<listelem 1>,<listelem 2>,...,<listelem n>]`\n\n* Scrollable item list showing arbitrary text elements\n* `name` fieldname sent to server on doubleclick value is current selected\n  element.\n* `listelements` can be prepended by #color in hexadecimal format RRGGBB\n  (only).\n    * if you want a listelement to start with \"#\" write \"##\".\n\n### `textlist[<X>,<Y>;<W>,<H>;<name>;<listelem 1>,<listelem 2>,...,<listelem n>;<selected idx>;<transparent>]`\n\n* Scrollable itemlist showing arbitrary text elements\n* `name` fieldname sent to server on doubleclick value is current selected\n  element.\n* `listelements` can be prepended by #RRGGBB (only) in hexadecimal format\n    * if you want a listelement to start with \"#\" write \"##\"\n* Index to be selected within textlist\n* `true`/`false`: draw transparent background\n* See also `minetest.explode_textlist_event`\n  (main menu: `core.explode_textlist_event`).\n\n### `tabheader[<X>,<Y>;<name>;<caption 1>,<caption 2>,...,<caption n>;<current_tab>;<transparent>;<draw_border>]`\n\n* Show a tab**header** at specific position (ignores formsize)\n* `X` and `Y`: position of the tabheader\n* *Note*: Width and height are automatically chosen with this syntax\n* `name` fieldname data is transferred to Lua\n* `caption 1`...: name shown on top of tab\n* `current_tab`: index of selected tab 1...\n* `transparent` (optional): show transparent\n* `draw_border` (optional): draw border\n\n### `tabheader[<X>,<Y>;<H>;<name>;<caption 1>,<caption 2>,...,<caption n>;<current_tab>;<transparent>;<draw_border>]`\n\n* Show a tab**header** at specific position (ignores formsize)\n* **Important note**: This syntax for tabheaders can only be used with the\n  new coordinate system.\n* `X` and `Y`: position of the tabheader\n* `H`: height of the tabheader. Width is automatically determined with this syntax.\n* `name` fieldname data is transferred to Lua\n* `caption 1`...: name shown on top of tab\n* `current_tab`: index of selected tab 1...\n* `transparent` (optional): show transparent\n* `draw_border` (optional): draw border\n\n### `tabheader[<X>,<Y>;<W>,<H>;<name>;<caption 1>,<caption 2>,...,<caption n>;<current_tab>;<transparent>;<draw_border>]`\n\n* Show a tab**header** at specific position (ignores formsize)\n* **Important note**: This syntax for tabheaders can only be used with the\n  new coordinate system.\n* `X` and `Y`: position of the tabheader\n* `W` and `H`: width and height of the tabheader\n* `name` fieldname data is transferred to Lua\n* `caption 1`...: name shown on top of tab\n* `current_tab`: index of selected tab 1...\n* `transparent` (optional): show transparent\n* `draw_border` (optional): draw border\n\n### `box[<X>,<Y>;<W>,<H>;<color>]`\n\n* Simple colored box\n* `color` is color specified as a `ColorString`.\n  If the alpha component is left blank, the box will be semitransparent.\n\n### `dropdown[<X>,<Y>;<W>;<name>;<item 1>,<item 2>, ...,<item n>;<selected idx>]`\n\n* Show a dropdown field\n* **Important note**: There are two different operation modes:\n    1. handle directly on change (only changed dropdown is submitted)\n    2. read the value on pressing a button (all dropdown values are available)\n* `X` and `Y`: position of the dropdown\n* `W`: width of the dropdown. Height is automatically chosen with this syntax.\n* Fieldname data is transferred to Lua\n* Items to be shown in dropdown\n* Index of currently selected dropdown item\n\n### `dropdown[<X>,<Y>;<W>,<H>;<name>;<item 1>,<item 2>, ...,<item n>;<selected idx>]`\n\n* Show a dropdown field\n* **Important note**: This syntax for dropdowns can only be used with the\n  new coordinate system.\n* **Important note**: There are two different operation modes:\n    1. handle directly on change (only changed dropdown is submitted)\n    2. read the value on pressing a button (all dropdown values are available)\n* `X` and `Y`: position of the dropdown\n* `W` and `H`: width and height of the dropdown\n* Fieldname data is transferred to Lua\n* Items to be shown in dropdown\n* Index of currently selected dropdown item\n\n### `checkbox[<X>,<Y>;<name>;<label>;<selected>]`\n\n* Show a checkbox\n* `name` fieldname data is transferred to Lua\n* `label` to be shown left of checkbox\n* `selected` (optional): `true`/`false`\n* **Note**: If the new coordinate system is enabled, checkboxes are\n  positioned from the center of the checkbox, not the top.\n\n### `scrollbar[<X>,<Y>;<W>,<H>;<orientation>;<name>;<value>]`\n\n* Show a scrollbar\n* There are two ways to use it:\n    1. handle the changed event (only changed scrollbar is available)\n    2. read the value on pressing a button (all scrollbars are available)\n* `orientation`:  `vertical`/`horizontal`\n* Fieldname data is transferred to Lua\n* Value this trackbar is set to (`0`-`1000`)\n* See also `minetest.explode_scrollbar_event`\n  (main menu: `core.explode_scrollbar_event`).\n\n### `table[<X>,<Y>;<W>,<H>;<name>;<cell 1>,<cell 2>,...,<cell n>;<selected idx>]`\n\n* Show scrollable table using options defined by the previous `tableoptions[]`\n* Displays cells as defined by the previous `tablecolumns[]`\n* `name`: fieldname sent to server on row select or doubleclick\n* `cell 1`...`cell n`: cell contents given in row-major order\n* `selected idx`: index of row to be selected within table (first row = `1`)\n* See also `minetest.explode_table_event`\n  (main menu: `core.explode_table_event`).\n\n### `tableoptions[<opt 1>;<opt 2>;...]`\n\n* Sets options for `table[]`\n* `color=#RRGGBB`\n    * default text color (`ColorString`), defaults to `#FFFFFF`\n* `background=#RRGGBB`\n    * table background color (`ColorString`), defaults to `#000000`\n* `border=<true/false>`\n    * should the table be drawn with a border? (default: `true`)\n* `highlight=#RRGGBB`\n    * highlight background color (`ColorString`), defaults to `#466432`\n* `highlight_text=#RRGGBB`\n    * highlight text color (`ColorString`), defaults to `#FFFFFF`\n* `opendepth=<value>`\n    * all subtrees up to `depth < value` are open (default value = `0`)\n    * only useful when there is a column of type \"tree\"\n\n### `tablecolumns[<type 1>,<opt 1a>,<opt 1b>,...;<type 2>,<opt 2a>,<opt 2b>;...]`\n\n* Sets columns for `table[]`\n* Types: `text`, `image`, `color`, `indent`, `tree`\n    * `text`:   show cell contents as text\n    * `image`:  cell contents are an image index, use column options to define\n                images.\n    * `color`:  cell contents are a ColorString and define color of following\n                cell.\n    * `indent`: cell contents are a number and define indentation of following\n                cell.\n    * `tree`:   same as indent, but user can open and close subtrees\n                (treeview-like).\n* Column options:\n    * `align=<value>`\n        * for `text` and `image`: content alignment within cells.\n          Available values: `left` (default), `center`, `right`, `inline`\n    * `width=<value>`\n        * for `text` and `image`: minimum width in em (default: `0`)\n        * for `indent` and `tree`: indent width in em (default: `1.5`)\n    * `padding=<value>`: padding left of the column, in em (default `0.5`).\n      Exception: defaults to 0 for indent columns\n    * `tooltip=<value>`: tooltip text (default: empty)\n    * `image` column options:\n        * `0=<value>` sets image for image index 0\n        * `1=<value>` sets image for image index 1\n        * `2=<value>` sets image for image index 2\n        * and so on; defined indices need not be contiguous empty or\n          non-numeric cells are treated as `0`.\n    * `color` column options:\n        * `span=<value>`: number of following columns to affect\n          (default: infinite).\n\n### `style[<name>;<prop1>;<prop2>;...]`\n\n* Set the style for the named element `name`.\n* Note: this **must** be before the element is defined.\n* See [Styling Formspecs].\n\n\n### `style_type[<type>;<prop1>;<prop2>;...]`\n\n* Sets the style for all elements of type `type` which appear after this element.\n* See [Styling Formspecs].\n\nMigrating to Real Coordinates\n-----------------------------\n\nIn the old system, positions included padding and spacing. Padding is a gap between\nthe formspec window edges and content, and spacing is the gaps between items. For\nexample, two `1x1` elements at `0,0` and `1,1` would have a spacing of `5/4` between them,\nand a padding of `3/8` from the formspec edge. It may be easiest to recreate old layouts\nin the new coordinate system from scratch.\n\nTo recreate an old layout with padding, you'll need to pass the positions and sizes\nthrough the following formula to re-introduce padding:\n\n```\npos = (oldpos + 1)*spacing + padding\nwhere\n    padding = 3/8\n    spacing = 5/4\n```\n\nYou'll need to change the `size[]` tag like this:\n\n```\nsize = (oldsize-1)*spacing + padding*2 + 1\n```\n\nA few elements had random offsets in the old system. Here is a table which shows these\noffsets when migrating:\n\n| Element |  Position  |  Size   | Notes\n|---------|------------|---------|-------\n| box     | +0.3, +0.1 | 0, -0.4 |\n| button  |            |         | Buttons now support height, so set h = 2 * 15/13 * 0.35, and reposition if h ~= 15/13 * 0.35 before\n| list    |            |         | Spacing is now 0.25 for both directions, meaning lists will be taller in height\n| label   | 0, +0.3    |         | The first line of text is now positioned centered exactly at the position specified\n\nStyling Formspecs\n-----------------\n\nFormspec elements can be themed using the style elements:\n\n    style[<name>;<prop1>;<prop2>;...]\n    style_type[<type>;<prop1>;<prop2>;...]\n\nWhere a prop is:\n\n    property_name=property_value\n\nFor example:\n\n    style_type[button;bgcolor=#006699]\n    style[world_delete;bgcolor=red;textcolor=yellow]\n    button[4,3.95;2.6,1;world_delete;Delete]\n\nSetting a property to nothing will reset it to the default value. For example:\n\n    style_type[button;bgimg=button.png;bgimg_pressed=button_pressed.png;border=false]\n    style[btn_exit;bgimg=;bgimg_pressed=;border=;bgcolor=red]\n\n\n### Supported Element Types\n\nSome types may inherit styles from parent types.\n\n* button\n* button_exit, inherits from button\n* checkbox\n* scrollbar\n* table\n* textlist\n* dropdown\n* field\n* pwdfield, inherits from field\n* textarea\n* label\n* vertlabel, inherits from field\n* image_button\n* item_image_button, inherits from image_button\n* tabheader\n\n\n### Valid Properties\n\n* button, button_exit\n    * alpha - boolean, whether to draw alpha in bgimg. Default true.\n    * bgcolor - color, sets button tint.\n    * bgimg - standard image. Defaults to none.\n    * bgimg_pressed - image when pressed. Defaults to bgimg when not provided.\n    * border - boolean, draw border. Set to false to hide the bevelled button pane. Default true.\n    * noclip - boolean, set to true to allow the element to exceed formspec bounds.\n    * textcolor - color, default white.\n* checkbox\n    * noclip - boolean, set to true to allow the element to exceed formspec bounds.\n* scrollbar\n    * noclip - boolean, set to true to allow the element to exceed formspec bounds.\n* table, textlist\n    * noclip - boolean, set to true to allow the element to exceed formspec bounds.\n* dropdown\n    * noclip - boolean, set to true to allow the element to exceed formspec bounds.\n* field, pwdfield, textarea\n    * border - set to false to hide the textbox background and border. Default true.\n    * noclip - boolean, set to true to allow the element to exceed formspec bounds.\n    * textcolor - color. Default white.\n* label, vertlabel\n    * noclip - boolean, set to true to allow the element to exceed formspec bounds.\n* image_button\n    * alpha - boolean, whether to draw alpha in bgimg. Default true.\n    * border - boolean, draw border. Set to false to hide the bevelled button pane. Default false.\n    * noclip - boolean, set to true to allow the element to exceed formspec bounds.\n* item_image_button\n    * border - boolean, draw border. Set to false to hide the bevelled button pane. Default false.\n    * noclip - boolean, set to true to allow the element to exceed formspec bounds.\n* tabheader\n    * noclip - boolean, set to true to allow the element to exceed formspec bounds.\n    * textcolor - color. Default white.\n\nInventory\n=========\n\nInventory locations\n-------------------\n\n* `\"context\"`: Selected node metadata (deprecated: `\"current_name\"`)\n* `\"current_player\"`: Player to whom the menu is shown\n* `\"player:<name>\"`: Any player\n* `\"nodemeta:<X>,<Y>,<Z>\"`: Any node metadata\n* `\"detached:<name>\"`: A detached inventory\n\nPlayer Inventory lists\n----------------------\n\n* `main`: list containing the default inventory\n* `craft`: list containing the craft input\n* `craftpreview`: list containing the craft prediction\n* `craftresult`: list containing the crafted output\n* `hand`: list containing an override for the empty hand\n    * Is not created automatically, use `InvRef:set_size`\n    * Is only used to enhance the empty hand's tool capabilities\n\n\nColors\n======\n\n`ColorString`\n-------------\n\n`#RGB` defines a color in hexadecimal format.\n\n`#RGBA` defines a color in hexadecimal format and alpha channel.\n\n`#RRGGBB` defines a color in hexadecimal format.\n\n`#RRGGBBAA` defines a color in hexadecimal format and alpha channel.\n\nNamed colors are also supported and are equivalent to\n[CSS Color Module Level 4](http://dev.w3.org/csswg/css-color/#named-colors).\nTo specify the value of the alpha channel, append `#AA` to the end of the color\nname (e.g. `colorname#08`). For named colors the hexadecimal string\nrepresenting the alpha value must (always) be two hexadecimal digits.\n\n`ColorSpec`\n-----------\n\nA ColorSpec specifies a 32-bit color. It can be written in any of the following\nforms:\n\n* table form: Each element ranging from 0..255 (a, if absent, defaults to 255):\n    * `colorspec = {a=255, r=0, g=255, b=0}`\n* numerical form: The raw integer value of an ARGB8 quad:\n    * `colorspec = 0xFF00FF00`\n* string form: A ColorString (defined above):\n    * `colorspec = \"green\"`\n\n\n\n\nEscape sequences\n================\n\nMost text can contain escape sequences, that can for example color the text.\nThere are a few exceptions: tab headers, dropdowns and vertical labels can't.\nThe following functions provide escape sequences:\n","prefix":"fall_damage_add_percent`: damage speed = `speed * ","body":"fall_damage_add_percent"},{"desc":"    * `color` is a ColorString\n    * The escape sequence sets the text color to `color`","prefix":"minetest.get_color_escape_sequence","body":"minetest.get_color_escape_sequence(${1:color})"},{"desc":"    * Equivalent to:\n      `minetest.get_color_escape_sequence(color) ..\n      message ..\n      minetest.get_color_escape_sequence(\"#ffffff\")`","prefix":"minetest.colorize","body":"minetest.colorize(${1:color}, ${2:message})"},{"desc":"    * `color` is a ColorString\n    * The escape sequence sets the background of the whole text element to\n      `color`. Only defined for item descriptions and tooltips.","prefix":"minetest.get_background_escape_sequence","body":"minetest.get_background_escape_sequence(${1:color})"},{"desc":"    * Removes foreground colors added by `get_color_escape_sequence`.","prefix":"minetest.strip_foreground_colors","body":"minetest.strip_foreground_colors(${1:str})"},{"desc":"    * Removes background colors added by `get_background_escape_sequence`.","prefix":"minetest.strip_background_colors","body":"minetest.strip_background_colors(${1:str})"},{"desc":"    * Removes all color escape sequences.\n\n\n\n\nSpatial Vectors\n===============\nA spatial vector is similar to a position, but instead using\nabsolute world coordinates, it uses *relative* coordinates, relative to\nno particular point.\n\nInternally, it is implemented as a table with the 3 fields\n`x`, `y` and `z`. Example: `{x = 0, y = 1, z = 0}`.\n\nFor the following functions, `v`, `v1`, `v2` are vectors,\n`p1`, `p2` are positions:\n","prefix":"minetest.strip_colors","body":"minetest.strip_colors(${1:str})"},{"desc":"    * Returns a vector.\n    * A copy of `a` if `a` is a vector.\n    * `{x = a, y = b, z = c}`, if all of `a`, `b`, `c` are defined numbers.","prefix":"vector.new","body":"vector.new(${1:a}[, ${2:b}, ${3:c}])"},{"desc":"    * Returns a vector of length 1 with direction `p1` to `p2`.\n    * If `p1` and `p2` are identical, returns `{x = 0, y = 0, z = 0}`.","prefix":"vector.direction","body":"vector.direction(${1:p1}, ${2:p2})"},{"desc":"    * Returns zero or a positive number, the distance between `p1` and `p2`.","prefix":"vector.distance","body":"vector.distance(${1:p1}, ${2:p2})"},{"desc":"    * Returns zero or a positive number, the length of vector `v`.","prefix":"vector.length","body":"vector.length(${1:v})"},{"desc":"    * Returns a vector of length 1 with direction of vector `v`.\n    * If `v` has zero length, returns `{x = 0, y = 0, z = 0}`.","prefix":"vector.normalize","body":"vector.normalize(${1:v})"},{"desc":"    * Returns a vector, each dimension rounded down.","prefix":"vector.floor","body":"vector.floor(${1:v})"},{"desc":"    * Returns a vector, each dimension rounded to nearest integer.","prefix":"vector.round","body":"vector.round(${1:v})"},{"desc":"    * Returns a vector where the function `func` has been applied to each\n      component.","prefix":"vector.apply","body":"vector.apply(${1:v}, ${2:func})"},{"desc":"    * Returns a boolean, `true` if the vectors are identical.","prefix":"vector.equals","body":"vector.equals(${1:v1}, ${2:v2})"},{"desc":"    * Returns in order minp, maxp vectors of the cuboid defined by `v1`, `v2`.","prefix":"vector.sort","body":"vector.sort(${1:v1}, ${2:v2})"},{"desc":"    * Returns the angle between `v1` and `v2` in radians.","prefix":"vector.angle","body":"vector.angle(${1:v1}, ${2:v2})"},{"desc":"    * Returns the dot product of `v1` and `v2`","prefix":"vector.dot","body":"vector.dot(${1:v1}, ${2:v2})"},{"desc":"    * Returns the cross product of `v1` and `v2`\n\nFor the following functions `x` can be either a vector or a number:\n","prefix":"vector.cross","body":"vector.cross(${1:v1}, ${2:v2})"},{"desc":"    * Returns a vector.\n    * If `x` is a vector: Returns the sum of `v` and `x`.\n    * If `x` is a number: Adds `x` to each component of `v`.","prefix":"vector.add","body":"vector.add(${1:v}, ${2:x})"},{"desc":"    * Returns a vector.\n    * If `x` is a vector: Returns the difference of `v` subtracted by `x`.\n    * If `x` is a number: Subtracts `x` from each component of `v`.","prefix":"vector.subtract","body":"vector.subtract(${1:v}, ${2:x})"},{"desc":"    * Returns a scaled vector or Schur product.","prefix":"vector.multiply","body":"vector.multiply(${1:v}, ${2:x})"},{"desc":"    * Returns a scaled vector or Schur quotient.\n\n\n\n\nHelper functions\n================\n","prefix":"vector.divide","body":"vector.divide(${1:v}, ${2:x})"},{"desc":"returns a string which makes `obj`\n  human-readable, handles reference loops.\n    * `obj`: arbitrary variable\n    * `name`: string, default: `\"_\"`\n    * `dumped`: table, default: `{}`","prefix":"dump2","body":"dump2(${1:obj}, ${2:name}, ${3:dumped})"},{"desc":"returns a string which makes `obj` human-readable\n    * `obj`: arbitrary variable\n    * `dumped`: table, default: `{}`","prefix":"dump","body":"dump(${1:obj}, ${2:dumped})"},{"desc":"    * Get the hypotenuse of a triangle with legs x and y.\n      Useful for distance calculation.","prefix":"math.hypot","body":"math.hypot(${1:x}, ${2:y})"},{"desc":"returns `-1`, `0` or `1`\n    * Get the sign of a number.\n    * tolerance: number, default: `0.0`\n    * If the absolute value of `x` is within the `tolerance` or `x` is NaN,\n      `0` is returned.","prefix":"math.sign","body":"math.sign(${1:x}, ${2:tolerance})"},{"desc":"returns the factorial of `x`","prefix":"math.factorial","body":"math.factorial(${1:x})"},{"desc":"    * `separator`: string, default: `\",\"`\n    * `include_empty`: boolean, default: `false`\n    * `max_splits`: number, if it's negative, splits aren't limited,\n      default: `-1`\n    * `sep_is_pattern`: boolean, it specifies whether separator is a plain\n      string or a pattern (regex), default: `false`\n    * e.g. `\"a,b\":split\",\"` returns `{\"a\",\"b\"}`","prefix":"string.split","body":"string.split(${1:str}, ${2:separator}, ${3:include}_${4:empty}, ${5:max}_${6:splits}, ${7:sep}_${8:is}_${9:pattern})"},{"desc":"returns the string without whitespace pre- and suffixes\n    * e.g. `\"\\n \\t\\tfoo bar\\t \":trim()` returns `\"foo bar\"`","prefix":"string:trim","body":"string:trim()"},{"desc":"returns a string or table\n    * Adds newlines to the string to keep it within the specified character\n      limit\n    * Note that the returned lines may be longer than the limit since it only\n      splits at word borders.\n    * `limit`: number, maximal amount of characters in one line\n    * `as_table`: boolean, if set to true, a table of lines instead of a string\n      is returned, default: `false`","prefix":"minetest.wrap_text","body":"minetest.wrap_text(${1:str}, ${2:limit}, ${3:as}_${4:table})"},{"desc":"returns string `\\\"(X,Y,Z)\\\"`\n    * `pos`: table {x=X, y=Y, z=Z}\n    * Converts the position `pos` to a human-readable, printable string\n    * `decimal_places`: number, if specified, the x, y and z values of\n      the position are rounded to the given decimal place.","prefix":"minetest.pos_to_string","body":"minetest.pos_to_string(${1:pos}, ${2:decimal}_${3:places})"},{"desc":"returns a position or `nil`\n    * Same but in reverse.\n    * If the string can't be parsed to a position, nothing is returned.","prefix":"minetest.string_to_pos","body":"minetest.string_to_pos(${1:string})"},{"desc":"returns two positions\n    * Converts a string representing an area box into two positions","prefix":"minetest.string_to_area","body":"minetest.string_to_area(\"(${1:X1}, ${2:Y1}, ${3:Z1})${4:}(${5:X2}, ${6:Y2}, ${7:Z2})\")"},{"desc":"returns a string\n    * escapes the characters \"[\", \"]\", \"\\\", \",\" and \";\", which can not be used\n      in formspecs.","prefix":"minetest.formspec_escape","body":"minetest.formspec_escape(${1:string})"},{"desc":"    * returns true if passed 'y', 'yes', 'true' or a number that isn't zero.","prefix":"minetest.is_yes","body":"minetest.is_yes(${1:arg})"},{"desc":"    * returns true when the passed number represents NaN.","prefix":"minetest.is_nan","body":"minetest.is_nan(${1:arg})"},{"desc":"    * returns time with microsecond precision. May not return wall time.","prefix":"minetest.get_us_time","body":"minetest.get_us_time()"},{"desc":"returns a table\n    * returns a deep copy of `table`","prefix":"table.copy","body":"table.copy(${1:table})"},{"desc":"returns the smallest numerical index containing\n      the value `val` in the table `list`. Non-numerical indices are ignored.\n      If `val` could not be found, `-1` is returned. `list` must not have\n      negative indices.","prefix":"table.indexof","body":"table.indexof(${1:list}, ${2:val})"},{"desc":"    * Appends all values in `other_table` to `table` - uses `#table + 1` to\n      find new indices.","prefix":"table.insert_all","body":"table.insert_all(${1:table}, ${2:other}_${3:table})"},{"desc":"returns a\n  position.\n    * returns the exact position on the surface of a pointed node","prefix":"minetest.pointed_thing_to_face_pos","body":"minetest.pointed_thing_to_face_pos(${1:placer}, ${2:pointed}_${3:thing})"},{"desc":"Simulates a tool\n    that digs a node.\n    Returns a table with the following fields:\n    * `diggable`: `true` if node can be dug, `false` otherwise.\n    * `time`: Time it would take to dig the node.\n    * `wear`: How much wear would be added to the tool.\n    `time` and `wear` are meaningless if node's not diggable\n    Parameters:\n    * `groups`: Table of the node groups of the node that would be dug\n    * `tool_capabilities`: Tool capabilities table of the tool","prefix":"minetest.get_dig_params","body":"minetest.get_dig_params(${1:groups}, ${2:tool}_${3:capabilities})"},{"desc":"    Simulates an item that punches an object.\n    Returns a table with the following fields:\n    * `hp`: How much damage the punch would cause.\n    * `wear`: How much wear would be added to the tool.\n    Parameters:\n    * `groups`: Damage groups of the object\n    * `tool_capabilities`: Tool capabilities table of the item\n    * `time_from_last_punch`: time in seconds since last punch action\n\n\n\n\nTranslations\n============\n\nTexts can be translated client-side with the help of `minetest.translate` and\ntranslation files.\n\nTranslating a string\n--------------------\n\nTwo functions are provided to translate strings: `minetest.translate` and\n`minetest.get_translator`.\n","prefix":"minetest.get_hit_params","body":"minetest.get_hit_params(${1:groups}, ${2:tool}_${3:capabilities }[, ${4:time}_${5:from}_${6:last}_${7:punch}])"},{"desc":"is a simple wrapper around\n  `minetest.translate`, and `minetest.get_translator(textdomain)(str, ...)` is\n  equivalent to `minetest.translate(textdomain, str, ...)`.\n  It is intended to be used in the following way, so that it avoids verbose\n  repetitions of `minetest.translate`:\n\n      local S = minetest.get_translator(textdomain)\n      S(str, ...)\n\n  As an extra commodity, if `textdomain` is nil, it is assumed to be \"\" instead.\n","prefix":"minetest.get_translator","body":"minetest.get_translator(${1:textdomain})"},{"desc":"translates the string `str` with\n  the given `textdomain` for disambiguation. The textdomain must match the\n  textdomain specified in the translation file in order to get the string\n  translated. This can be used so that a string is translated differently in\n  different contexts.\n  It is advised to use the name of the mod as textdomain whenever possible, to\n  avoid clashes with other mods.\n  This function must be given a number of arguments equal to the number of\n  arguments the translated string expects.\n  Arguments are literal strings -- they will not be translated, so if you want\n  them to be, they need to come as outputs of `minetest.translate` as well.\n\n  For instance, suppose we want to translate \"@1 Wool\" with \"@1\" being replaced\n  by the translation of \"Red\". We can do the following:\n\n      local S = minetest.get_translator()\n      S(\"@1 Wool\", S(\"Red\"))\n\n  This will be displayed as \"Red Wool\" on old clients and on clients that do\n  not have localization enabled. However, if we have for instance a translation\n  file named `wool.fr.tr` containing the following:\n\n      @1 Wool=Laine @1\n      Red=Rouge\n\n  this will be displayed as \"Laine Rouge\" on clients with a French locale.\n\nOperations on translated strings\n--------------------------------\n\nThe output of `minetest.translate` is a string, with escape sequences adding\nadditional information to that string so that it can be translated on the\ndifferent clients. In particular, you can't expect operations like string.length\nto work on them like you would expect them to, or string.gsub to work in the\nexpected manner. However, string concatenation will still work as expected\n(note that you should only use this for things like formspecs; do not translate\nsentences by breaking them into parts; arguments should be used instead), and\noperations such as `minetest.colorize` which are also concatenation.\n\nTranslation file format\n-----------------------\n\nA translation file has the suffix `.[lang].tr`, where `[lang]` is the language\nit corresponds to. It must be put into the `locale` subdirectory of the mod.\nThe file should be a text file, with the following format:\n\n* Lines beginning with `# textdomain:` (the space is significant) can be used\n  to specify the text domain of all following translations in the file.\n* All other empty lines or lines beginning with `#` are ignored.\n* Other lines should be in the format `original=translated`. Both `original`\n  and `translated` can contain escape sequences beginning with `@` to insert\n  arguments, literal `@`, `=` or newline (See [Escapes] below).\n  There must be no extraneous whitespace around the `=` or at the beginning or\n  the end of the line.\n\nEscapes\n-------\n\nStrings that need to be translated can contain several escapes, preceded by `@`.\n\n* `@@` acts as a literal `@`.\n* `@n`, where `n` is a digit between 1 and 9, is an argument for the translated\n  string that will be inlined when translated. Due to how translations are\n  implemented, the original translation string **must** have its arguments in\n  increasing order, without gaps or repetitions, starting from 1.\n* `@=` acts as a literal `=`. It is not required in strings given to\n  `minetest.translate`, but is in translation files to avoid being confused\n  with the `=` separating the original from the translation.\n* `@\\n` (where the `\\n` is a literal newline) acts as a literal newline.\n  As with `@=`, this escape is not required in strings given to\n  `minetest.translate`, but is in translation files.\n* `@n` acts as a literal newline as well.\n\n\n\n\nPerlin noise\n============\n\nPerlin noise creates a continuously-varying value depending on the input values.\nUsually in Minetest the input values are either 2D or 3D co-ordinates in nodes.\nThe result is used during map generation to create the terrain shape, vary heat\nand humidity to distribute biomes, vary the density of decorations or vary the\nstructure of ores.\n\nStructure of perlin noise\n-------------------------\n\nAn 'octave' is a simple noise generator that outputs a value between -1 and 1.\nThe smooth wavy noise it generates has a single characteristic scale, almost\nlike a 'wavelength', so on its own does not create fine detail.\nDue to this perlin noise combines several octaves to create variation on\nmultiple scales. Each additional octave has a smaller 'wavelength' than the\nprevious.\n\nThis combination results in noise varying very roughly between -2.0 and 2.0 and\nwith an average value of 0.0, so `scale` and `offset` are then used to multiply\nand offset the noise variation.\n\nThe final perlin noise variation is created as follows:\n\nnoise = offset + scale * (octave1 +\n                          octave2 * persistence +\n                          octave3 * persistence ^ 2 +\n                          octave4 * persistence ^ 3 +\n                          ...)\n\nNoise Parameters\n----------------\n\nNoise Parameters are commonly called `NoiseParams`.\n\n### `offset`\n\nAfter the multiplication by `scale` this is added to the result and is the final\nstep in creating the noise value.\nCan be positive or negative.\n\n### `scale`\n\nOnce all octaves have been combined, the result is multiplied by this.\nCan be positive or negative.\n\n### `spread`\n\nFor octave1, this is roughly the change of input value needed for a very large\nvariation in the noise value generated by octave1. It is almost like a\n'wavelength' for the wavy noise variation.\nEach additional octave has a 'wavelength' that is smaller than the previous\noctave, to create finer detail. `spread` will therefore roughly be the typical\nsize of the largest structures in the final noise variation.\n\n`spread` is a vector with values for x, y, z to allow the noise variation to be\nstretched or compressed in the desired axes.\nValues are positive numbers.\n\n### `seed`\n\nThis is a whole number that determines the entire pattern of the noise\nvariation. Altering it enables different noise patterns to be created.\nWith other parameters equal, different seeds produce different noise patterns\nand identical seeds produce identical noise patterns.\n\nFor this parameter you can randomly choose any whole number. Usually it is\npreferable for this to be different from other seeds, but sometimes it is useful\nto be able to create identical noise patterns.\n\nWhen used in mapgen this is actually a 'seed offset', it is added to the\n'world seed' to create the seed used by the noise, to ensure the noise has a\ndifferent pattern in different worlds.\n\n### `octaves`\n\nThe number of simple noise generators that are combined.\nA whole number, 1 or more.\nEach additional octave adds finer detail to the noise but also increases the\nnoise calculation load.\n3 is a typical minimum for a high quality, complex and natural-looking noise\nvariation. 1 octave has a slight 'gridlike' appearence.\n\nChoose the number of octaves according to the `spread` and `lacunarity`, and the\nsize of the finest detail you require. For example:\nif `spread` is 512 nodes, `lacunarity` is 2.0 and finest detail required is 16\nnodes, octaves will be 6 because the 'wavelengths' of the octaves will be\n512, 256, 128, 64, 32, 16 nodes.\nWarning: If the 'wavelength' of any octave falls below 1 an error will occur.\n\n### `persistence`\n\nEach additional octave has an amplitude that is the amplitude of the previous\noctave multiplied by `persistence`, to reduce the amplitude of finer details,\nas is often helpful and natural to do so.\nSince this controls the balance of fine detail to large-scale detail\n`persistence` can be thought of as the 'roughness' of the noise.\n\nA positive or negative non-zero number, often between 0.3 and 1.0.\nA common medium value is 0.5, such that each octave has half the amplitude of\nthe previous octave.\nThis may need to be tuned when altering `lacunarity`; when doing so consider\nthat a common medium value is 1 / lacunarity.\n\n### `lacunarity`\n\nEach additional octave has a 'wavelength' that is the 'wavelength' of the\nprevious octave multiplied by 1 / lacunarity, to create finer detail.\n'lacunarity' is often 2.0 so 'wavelength' often halves per octave.\n\nA positive number no smaller than 1.0.\nValues below 2.0 create higher quality noise at the expense of requiring more\noctaves to cover a paticular range of 'wavelengths'.\n\n### `flags`\n\nLeave this field unset for no special handling.\nCurrently supported are `defaults`, `eased` and `absvalue`:\n\n#### `defaults`\n\nSpecify this if you would like to keep auto-selection of eased/not-eased while\nspecifying some other flags.\n\n#### `eased`\n\nMaps noise gradient values onto a quintic S-curve before performing\ninterpolation. This results in smooth, rolling noise.\nDisable this (`noeased`) for sharp-looking noise with a slightly gridded\nappearence.\nIf no flags are specified (or defaults is), 2D noise is eased and 3D noise is\nnot eased.\nEasing a 3D noise significantly increases the noise calculation load, so use\nwith restraint.\n\n#### `absvalue`\n\nThe absolute value of each octave's noise variation is used when combining the\noctaves. The final perlin noise variation is created as follows:\n\nnoise = offset + scale * (abs(octave1) +\n                          abs(octave2) * persistence +\n                          abs(octave3) * persistence ^ 2 +\n                          abs(octave4) * persistence ^ 3 +\n                          ...)\n\n### Format example\n\nFor 2D or 3D perlin noise or perlin noise maps:\n\n    np_terrain = {\n        offset = 0,\n        scale = 1,\n        spread = {x = 500, y = 500, z = 500},\n        seed = 571347,\n        octaves = 5,\n        persist = 0.63,\n        lacunarity = 2.0,\n        flags = \"defaults, absvalue\",\n    }\n\nFor 2D noise the Z component of `spread` is still defined but is ignored.\nA single noise parameter table can be used for 2D or 3D noise.\n\n\n\n\nOres\n====\n\nOre types\n---------\n\nThese tell in what manner the ore is generated.\n\nAll default ores are of the uniformly-distributed scatter type.\n\n### `scatter`\n\nRandomly chooses a location and generates a cluster of ore.\n\nIf `noise_params` is specified, the ore will be placed if the 3D perlin noise\nat that point is greater than the `noise_threshold`, giving the ability to\ncreate a non-equal distribution of ore.\n\n### `sheet`\n\nCreates a sheet of ore in a blob shape according to the 2D perlin noise\ndescribed by `noise_params` and `noise_threshold`. This is essentially an\nimproved version of the so-called \"stratus\" ore seen in some unofficial mods.\n\nThis sheet consists of vertical columns of uniform randomly distributed height,\nvarying between the inclusive range `column_height_min` and `column_height_max`.\nIf `column_height_min` is not specified, this parameter defaults to 1.\nIf `column_height_max` is not specified, this parameter defaults to `clust_size`\nfor reverse compatibility. New code should prefer `column_height_max`.\n\nThe `column_midpoint_factor` parameter controls the position of the column at\nwhich ore emanates from.\nIf 1, columns grow upward. If 0, columns grow downward. If 0.5, columns grow\nequally starting from each direction.\n`column_midpoint_factor` is a decimal number ranging in value from 0 to 1. If\nthis parameter is not specified, the default is 0.5.\n\nThe ore parameters `clust_scarcity` and `clust_num_ores` are ignored for this\nore type.\n\n### `puff`\n\nCreates a sheet of ore in a cloud-like puff shape.\n\nAs with the `sheet` ore type, the size and shape of puffs are described by\n`noise_params` and `noise_threshold` and are placed at random vertical\npositions within the currently generated chunk.\n\nThe vertical top and bottom displacement of each puff are determined by the\nnoise parameters `np_puff_top` and `np_puff_bottom`, respectively.\n\n### `blob`\n\nCreates a deformed sphere of ore according to 3d perlin noise described by\n`noise_params`. The maximum size of the blob is `clust_size`, and\n`clust_scarcity` has the same meaning as with the `scatter` type.\n\n### `vein`\n\nCreates veins of ore varying in density by according to the intersection of two\ninstances of 3d perlin noise with different seeds, both described by\n`noise_params`.\n\n`random_factor` varies the influence random chance has on placement of an ore\ninside the vein, which is `1` by default. Note that modifying this parameter\nmay require adjusting `noise_threshold`.\n\nThe parameters `clust_scarcity`, `clust_num_ores`, and `clust_size` are ignored\nby this ore type.\n\nThis ore type is difficult to control since it is sensitive to small changes.\nThe following is a decent set of parameters to work from:\n\n    noise_params = {\n        offset  = 0,\n        scale   = 3,\n        spread  = {x=200, y=200, z=200},\n        seed    = 5390,\n        octaves = 4,\n        persist = 0.5,\n        lacunarity = 2.0,\n        flags = \"eased\",\n    },\n    noise_threshold = 1.6\n\n**WARNING**: Use this ore type *very* sparingly since it is ~200x more\ncomputationally expensive than any other ore.\n\n### `stratum`\n\nCreates a single undulating ore stratum that is continuous across mapchunk\nborders and horizontally spans the world.\n\nThe 2D perlin noise described by `noise_params` defines the Y co-ordinate of\nthe stratum midpoint. The 2D perlin noise described by `np_stratum_thickness`\ndefines the stratum's vertical thickness (in units of nodes). Due to being\ncontinuous across mapchunk borders the stratum's vertical thickness is\nunlimited.\n\nIf the noise parameter `noise_params` is omitted the ore will occur from y_min\nto y_max in a simple horizontal stratum.\n\nA parameter `stratum_thickness` can be provided instead of the noise parameter\n`np_stratum_thickness`, to create a constant thickness.\n\nLeaving out one or both noise parameters makes the ore generation less\nintensive, useful when adding multiple strata.\n\n`y_min` and `y_max` define the limits of the ore generation and for performance\nreasons should be set as close together as possible but without clipping the\nstratum's Y variation.\n\nEach node in the stratum has a 1-in-`clust_scarcity` chance of being ore, so a\nsolid-ore stratum would require a `clust_scarcity` of 1.\n\nThe parameters `clust_num_ores`, `clust_size`, `noise_threshold` and\n`random_factor` are ignored by this ore type.\n\nOre attributes\n--------------\n\nSee section [Flag Specifier Format].\n\nCurrently supported flags:\n`puff_cliffs`, `puff_additive_composition`.\n\n### `puff_cliffs`\n\nIf set, puff ore generation will not taper down large differences in\ndisplacement when approaching the edge of a puff. This flag has no effect for\nore types other than `puff`.\n\n### `puff_additive_composition`\n\nBy default, when noise described by `np_puff_top` or `np_puff_bottom` results\nin a negative displacement, the sub-column at that point is not generated. With\nthis attribute set, puff ore generation will instead generate the absolute\ndifference in noise displacement values. This flag has no effect for ore types\nother than `puff`.\n\n\n\n\nDecoration types\n================\n\nThe varying types of decorations that can be placed.\n\n`simple`\n--------\n\nCreates a 1 times `H` times 1 column of a specified node (or a random node from\na list, if a decoration list is specified). Can specify a certain node it must\nspawn next to, such as water or lava, for example. Can also generate a\ndecoration of random height between a specified lower and upper bound.\nThis type of decoration is intended for placement of grass, flowers, cacti,\npapyri, waterlilies and so on.\n\n`schematic`\n-----------\n\nCopies a box of `MapNodes` from a specified schematic file (or raw description).\nCan specify a probability of a node randomly appearing when placed.\nThis decoration type is intended to be used for multi-node sized discrete\nstructures, such as trees, cave spikes, rocks, and so on.\n\n\n\n\nSchematics\n==========\n\nSchematic specifier\n--------------------\n\nA schematic specifier identifies a schematic by either a filename to a\nMinetest Schematic file (`.mts`) or through raw data supplied through Lua,\nin the form of a table.  This table specifies the following fields:\n\n* The `size` field is a 3D vector containing the dimensions of the provided\n  schematic. (required field)\n* The `yslice_prob` field is a table of {ypos, prob} slice tables. A slice table\n  sets the probability of a particular horizontal slice of the schematic being\n  placed. (optional field)\n  `ypos` = 0 for the lowest horizontal slice of a schematic.\n  The default of `prob` is 255.\n* The `data` field is a flat table of MapNode tables making up the schematic,\n  in the order of `[z [y [x]]]`. (required field)\n  Each MapNode table contains:\n    * `name`: the name of the map node to place (required)\n    * `prob` (alias `param1`): the probability of this node being placed\n      (default: 255)\n    * `param2`: the raw param2 value of the node being placed onto the map\n      (default: 0)\n    * `force_place`: boolean representing if the node should forcibly overwrite\n      any previous contents (default: false)\n\nAbout probability values:\n\n* A probability value of `0` or `1` means that node will never appear\n  (0% chance).\n* A probability value of `254` or `255` means the node will always appear\n  (100% chance).\n* If the probability value `p` is greater than `1`, then there is a\n  `(p / 256 * 100)` percent chance that node will appear when the schematic is\n  placed on the map.\n\nSchematic attributes\n--------------------\n\nSee section [Flag Specifier Format].\n\nCurrently supported flags: `place_center_x`, `place_center_y`, `place_center_z`,\n                           `force_placement`.\n\n* `place_center_x`: Placement of this decoration is centered along the X axis.\n* `place_center_y`: Placement of this decoration is centered along the Y axis.\n* `place_center_z`: Placement of this decoration is centered along the Z axis.\n* `force_placement`: Schematic nodes other than \"ignore\" will replace existing\n  nodes.\n\n\n\n\nLua Voxel Manipulator\n=====================\n\nAbout VoxelManip\n----------------\n\nVoxelManip is a scripting interface to the internal 'Map Voxel Manipulator'\nfacility. The purpose of this object is for fast, low-level, bulk access to\nreading and writing Map content. As such, setting map nodes through VoxelManip\nwill lack many of the higher level features and concepts you may be used to\nwith other methods of setting nodes. For example, nodes will not have their\nconstruction and destruction callbacks run, and no rollback information is\nlogged.\n\nIt is important to note that VoxelManip is designed for speed, and *not* ease\nof use or flexibility. If your mod requires a map manipulation facility that\nwill handle 100% of all edge cases, or the use of high level node placement\nfeatures, perhaps `minetest.set_node()` is better suited for the job.\n\nIn addition, VoxelManip might not be faster, or could even be slower, for your\nspecific use case. VoxelManip is most effective when setting large areas of map\nat once - for example, if only setting a 3x3x3 node area, a\n`minetest.set_node()` loop may be more optimal. Always profile code using both\nmethods of map manipulation to determine which is most appropriate for your\nusage.\n\nA recent simple test of setting cubic areas showed that `minetest.set_node()`\nis faster than a VoxelManip for a 3x3x3 node cube or smaller.\n\nUsing VoxelManip\n----------------\n\nA VoxelManip object can be created any time using either:\n`VoxelManip([p1, p2])`, or `minetest.get_voxel_manip([p1, p2])`.\n\nIf the optional position parameters are present for either of these routines,\nthe specified region will be pre-loaded into the VoxelManip object on creation.\nOtherwise, the area of map you wish to manipulate must first be loaded into the\nVoxelManip object using `VoxelManip:read_from_map()`.\n\nNote that `VoxelManip:read_from_map()` returns two position vectors. The region\nformed by these positions indicate the minimum and maximum (respectively)\npositions of the area actually loaded in the VoxelManip, which may be larger\nthan the area requested. For convenience, the loaded area coordinates can also\nbe queried any time after loading map data with `VoxelManip:get_emerged_area()`.\n\nNow that the VoxelManip object is populated with map data, your mod can fetch a\ncopy of this data using either of two methods. `VoxelManip:get_node_at()`,\nwhich retrieves an individual node in a MapNode formatted table at the position\nrequested is the simplest method to use, but also the slowest.\n\nNodes in a VoxelManip object may also be read in bulk to a flat array table\nusing:\n","prefix":"minetest.translate","body":"minetest.translate(${1:textdomain}, ${2:str}, ${3:}...)"},{"desc":"for node content (in Content ID form, see section\n  [Content IDs]),","prefix":"VoxelManip:get_data","body":"VoxelManip:get_data()"},{"desc":"for node light levels, and","prefix":"VoxelManip:get_light_data","body":"VoxelManip:get_light_data()"},{"desc":"for the node type-dependent \\\"param2\\\" values.\n\nSee section [Flat array format] for more details.\n\nIt is very important to understand that the tables returned by any of the above\nthree functions represent a snapshot of the VoxelManip's internal state at the\ntime of the call. This copy of the data will not magically update itself if\nanother function modifies the internal VoxelManip state.\nAny functions that modify a VoxelManip's contents work on the VoxelManip's\ninternal state unless otherwise explicitly stated.\n\nOnce the bulk data has been edited to your liking, the internal VoxelManip\nstate can be set using:\n","prefix":"VoxelManip:get_param2_data","body":"VoxelManip:get_param2_data()"},{"desc":"for node content (in Content ID form, see section\n  [Content IDs]),","prefix":"VoxelManip:set_data","body":"VoxelManip:set_data()"},{"desc":"for node light levels, and","prefix":"VoxelManip:set_light_data","body":"VoxelManip:set_light_data()"},{"desc":"for the node type-dependent `param2` values.\n\nThe parameter to each of the above three functions can use any table at all in\nthe same flat array format as produced by `get_data()` etc. and is not required\nto be a table retrieved from `get_data()`.\n\nOnce the internal VoxelManip state has been modified to your liking, the\nchanges can be committed back to the map by calling `VoxelManip:write_to_map()`\n\n### Flat array format\n\nLet\n    `Nx = p2.X - p1.X + 1`,\n    `Ny = p2.Y - p1.Y + 1`, and\n    `Nz = p2.Z - p1.Z + 1`.\n\nThen, for a loaded region of p1..p2, this array ranges from `1` up to and\nincluding the value of the expression `Nx * Ny * Nz`.\n\nPositions offset from p1 are present in the array with the format of:\n\n    [\n        (0, 0, 0),   (1, 0, 0),   (2, 0, 0),   ... (Nx, 0, 0),\n        (0, 1, 0),   (1, 1, 0),   (2, 1, 0),   ... (Nx, 1, 0),\n        ...\n        (0, Ny, 0),  (1, Ny, 0),  (2, Ny, 0),  ... (Nx, Ny, 0),\n        (0, 0, 1),   (1, 0, 1),   (2, 0, 1),   ... (Nx, 0, 1),\n        ...\n        (0, Ny, 2),  (1, Ny, 2),  (2, Ny, 2),  ... (Nx, Ny, 2),\n        ...\n        (0, Ny, Nz), (1, Ny, Nz), (2, Ny, Nz), ... (Nx, Ny, Nz)\n    ]\n\nand the array index for a position p contained completely in p1..p2 is:\n\n`(p.Z - p1.Z) * Ny * Nx + (p.Y - p1.Y) * Nx + (p.X - p1.X) + 1`\n\nNote that this is the same \"flat 3D array\" format as\n`PerlinNoiseMap:get3dMap_flat()`.\nVoxelArea objects (see section [`VoxelArea`]) can be used to simplify calculation\nof the index for a single point in a flat VoxelManip array.\n\n### Content IDs\n\nA Content ID is a unique integer identifier for a specific node type.\nThese IDs are used by VoxelManip in place of the node name string for\n`VoxelManip:get_data()` and `VoxelManip:set_data()`. You can use\n`minetest.get_content_id()` to look up the Content ID for the specified node\nname, and `minetest.get_name_from_content_id()` to look up the node name string\nfor a given Content ID.\nAfter registration of a node, its Content ID will remain the same throughout\nexecution of the mod.\nNote that the node being queried needs to have already been been registered.\n\nThe following builtin node types have their Content IDs defined as constants:\n\n* `minetest.CONTENT_UNKNOWN`: ID for \"unknown\" nodes\n* `minetest.CONTENT_AIR`:     ID for \"air\" nodes\n* `minetest.CONTENT_IGNORE`:  ID for \"ignore\" nodes\n\n### Mapgen VoxelManip objects\n\nInside of `on_generated()` callbacks, it is possible to retrieve the same\nVoxelManip object used by the core's Map Generator (commonly abbreviated\nMapgen). Most of the rules previously described still apply but with a few\ndifferences:\n\n* The Mapgen VoxelManip object is retrieved using:\n  `minetest.get_mapgen_object(\"voxelmanip\")`\n* This VoxelManip object already has the region of map just generated loaded\n  into it; it's not necessary to call `VoxelManip:read_from_map()` before using\n  a Mapgen VoxelManip.\n* The `on_generated()` callbacks of some mods may place individual nodes in the\n  generated area using non-VoxelManip map modification methods. Because the\n  same Mapgen VoxelManip object is passed through each `on_generated()`\n  callback, it becomes necessary for the Mapgen VoxelManip object to maintain\n  consistency with the current map state. For this reason, calling any of the\n  following functions:\n  `minetest.add_node()`, `minetest.set_node()`, or `minetest.swap_node()`\n  will also update the Mapgen VoxelManip object's internal state active on the\n  current thread.\n* After modifying the Mapgen VoxelManip object's internal buffer, it may be\n  necessary to update lighting information using either:\n  `VoxelManip:calc_lighting()` or `VoxelManip:set_lighting()`.\n\n### Other API functions operating on a VoxelManip\n\nIf any VoxelManip contents were set to a liquid node,\n`VoxelManip:update_liquids()` must be called for these liquid nodes to begin\nflowing. It is recommended to call this function only after having written all\nbuffered data back to the VoxelManip object, save for special situations where\nthe modder desires to only have certain liquid nodes begin flowing.\n\nThe functions `minetest.generate_ores()` and `minetest.generate_decorations()`\nwill generate all registered decorations and ores throughout the full area\ninside of the specified VoxelManip object.\n\n`minetest.place_schematic_on_vmanip()` is otherwise identical to\n`minetest.place_schematic()`, except instead of placing the specified schematic\ndirectly on the map at the specified position, it will place the schematic\ninside the VoxelManip.\n\n### Notes\n\n* Attempting to read data from a VoxelManip object before map is read will\n  result in a zero-length array table for `VoxelManip:get_data()`, and an\n  \"ignore\" node at any position for `VoxelManip:get_node_at()`.\n* If either a region of map has not yet been generated or is out-of-bounds of\n  the map, that region is filled with \"ignore\" nodes.\n* Other mods, or the core itself, could possibly modify the area of map\n  currently loaded into a VoxelManip object. With the exception of Mapgen\n  VoxelManips (see above section), the internal buffers are not updated. For\n  this reason, it is strongly encouraged to complete the usage of a particular\n  VoxelManip object in the same callback it had been created.\n* If a VoxelManip object will be used often, such as in an `on_generated()`\n  callback, consider passing a file-scoped table as the optional parameter to\n  `VoxelManip:get_data()`, which serves as a static buffer the function can use\n  to write map data to instead of returning a new table each call. This greatly\n  enhances performance by avoiding unnecessary memory allocations.\n\nMethods\n-------\n","prefix":"VoxelManip:set_param2_data","body":"VoxelManip:set_param2_data()"},{"desc":" Loads a chunk of map into the VoxelManip object\n  containing the region formed by `p1` and `p2`.\n    * returns actual emerged `pmin`, actual emerged `pmax`","prefix":"read_from_map","body":"read_from_map(${1:p1}, ${2:p2})"},{"desc":"Writes the data loaded from the `VoxelManip` back to\n  the map.\n    * **important**: data must be set using `VoxelManip:set_data()` before\n      calling this.\n    * if `light` is true, then lighting is automatically recalculated.\n      The default value is true.\n      If `light` is false, no light calculations happen, and you should correct\n      all modified blocks with `minetest.fix_light()` as soon as possible.\n      Keep in mind that modifying the map where light is incorrect can cause\n      more lighting bugs.","prefix":"write_to_map","body":"write_to_map([${1:light}])"},{"desc":"Returns a `MapNode` table of the node currently loaded in\n  the `VoxelManip` at that position","prefix":"get_node_at","body":"get_node_at(${1:pos})"},{"desc":"Sets a specific `MapNode` in the `VoxelManip` at\n  that position.","prefix":"set_node_at","body":"set_node_at(${1:pos}, ${2:node})"},{"desc":"Retrieves the node content data loaded into the\n  `VoxelManip` object.\n    * returns raw node data in the form of an array of node content IDs\n    * if the param `buffer` is present, this table will be used to store the\n      result instead.","prefix":"get_data","body":"get_data([${1:buffer}])"},{"desc":"Sets the data contents of the `VoxelManip` object","prefix":"set_data","body":"set_data(${1:data})"},{"desc":"Does nothing, kept for compatibility.","prefix":"update_map","body":"update_map()"},{"desc":"Set the lighting within the `VoxelManip` to\n  a uniform value.\n    * `light` is a table, `{day=<0...15>, night=<0...15>}`\n    * To be used only by a `VoxelManip` object from\n      `minetest.get_mapgen_object`.\n    * (`p1`, `p2`) is the area in which lighting is set, defaults to the whole\n      area if left out.","prefix":"set_lighting","body":"set_lighting(${1:light}, ${2:}[${3:p1}, ${4:p2}])"},{"desc":"Gets the light data read into the `VoxelManip` object\n    * Returns an array (indices 1 to volume) of integers ranging from `0` to\n      `255`.\n    * Each value is the bitwise combination of day and night light values\n      (`0` to `15` each).","prefix":"get_light_data","body":"get_light_data()"},{"desc":"","prefix":"light = day + ","body":"light = day + (${1:night }*${2:16})"},{"desc":"Sets the `param1` (light) contents of each node\n  in the `VoxelManip`.\n    * expects lighting data in the same format that `get_light_data()` returns","prefix":"set_light_data","body":"set_light_data(${1:light}_${2:data})"},{"desc":"Gets the raw `param2` data read into the\n  `VoxelManip` object.\n    * Returns an array (indices 1 to volume) of integers ranging from `0` to\n      `255`.\n    * If the param `buffer` is present, this table will be used to store the\n      result instead.","prefix":"get_param2_data","body":"get_param2_data([${1:buffer}])"},{"desc":"Sets the `param2` contents of each node in\n  the `VoxelManip`.","prefix":"set_param2_data","body":"set_param2_data(${1:param2}_${2:data})"},{"desc":" Calculate lighting within the\n  `VoxelManip`.\n    * To be used only by a `VoxelManip` object from\n      `minetest.get_mapgen_object`.\n    * (`p1`, `p2`) is the area in which lighting is set, defaults to the whole\n      area if left out or nil. For almost all uses these should be left out\n      or nil to use the default.\n    * `propagate_shadow` is an optional boolean deciding whether shadows in a\n      generated mapchunk above are propagated down into the mapchunk, defaults\n      to `true` if left out.","prefix":"calc_lighting","body":"calc_lighting([${1:p1}, ${2:p2}], ${3:}[${4:propagate}_${5:shadow}])"},{"desc":"Update liquid flow","prefix":"update_liquids","body":"update_liquids()"},{"desc":"Returns `true` or `false` if the data in the voxel\n  manipulator had been modified since the last read from map, due to a call to\n  `minetest.set_data()` on the loaded area elsewhere.","prefix":"was_modified","body":"was_modified()"},{"desc":"Returns actual emerged minimum and maximum positions.\n\n`VoxelArea`\n-----------\n\nA helper class for voxel areas.\nIt can be created via `VoxelArea:new{MinEdge=pmin, MaxEdge=pmax}`.\nThe coordinates are *inclusive*, like most other things in Minetest.\n\n### Methods\n","prefix":"get_emerged_area","body":"get_emerged_area()"},{"desc":"returns a 3D vector containing the size of the area formed by\n  `MinEdge` and `MaxEdge`.","prefix":"getExtent","body":"getExtent()"},{"desc":"returns the volume of the area formed by `MinEdge` and\n  `MaxEdge`.","prefix":"getVolume","body":"getVolume()"},{"desc":"returns the index of an absolute position in a flat array\n  starting at `1`.\n    * `x`, `y` and `z` must be integers to avoid an incorrect index result.\n    * The position (x, y, z) is not checked for being inside the area volume,\n      being outside can cause an incorrect index result.\n    * Useful for things like `VoxelManip`, raw Schematic specifiers,\n      `PerlinNoiseMap:get2d`/`3dMap`, and so on.","prefix":"index","body":"index(${1:x}, ${2:y}, ${3:z})"},{"desc":"same functionality as `index(x, y, z)` but takes a vector.\n    * As with `index(x, y, z)`, the components of `p` must be integers, and `p`\n      is not checked for being inside the area volume.","prefix":"indexp","body":"indexp(${1:p})"},{"desc":"returns the absolute position vector corresponding to index\n  `i`.","prefix":"position","body":"position(${1:i})"},{"desc":"check if (`x`,`y`,`z`) is inside area formed by\n  `MinEdge` and `MaxEdge`.","prefix":"contains","body":"contains(${1:x}, ${2:y}, ${3:z})"},{"desc":"same as above, except takes a vector","prefix":"containsp","body":"containsp(${1:p})"},{"desc":"same as above, except takes an index `i`","prefix":"containsi","body":"containsi(${1:i})"},{"desc":"returns an iterator that returns\n  indices.\n    * from (`minx`,`miny`,`minz`) to (`maxx`,`maxy`,`maxz`) in the order of\n      `[z [y [x]]]`.","prefix":"iter","body":"iter(${1:minx}, ${2:miny}, ${3:minz}, ${4:maxx}, ${5:maxy}, ${6:maxz})"},{"desc":"same as above, except takes a vector\n\n\n\n\nMapgen objects\n==============\n\nA mapgen object is a construct used in map generation. Mapgen objects can be\nused by an `on_generate` callback to speed up operations by avoiding\nunnecessary recalculations, these can be retrieved using the\n`minetest.get_mapgen_object()` function. If the requested Mapgen object is\nunavailable, or `get_mapgen_object()` was called outside of an `on_generate()`\ncallback, `nil` is returned.\n\nThe following Mapgen objects are currently available:\n\n### `voxelmanip`\n\nThis returns three values; the `VoxelManip` object to be used, minimum and\nmaximum emerged position, in that order. All mapgens support this object.\n\n### `heightmap`\n\nReturns an array containing the y coordinates of the ground levels of nodes in\nthe most recently generated chunk by the current mapgen.\n\n### `biomemap`\n\nReturns an array containing the biome IDs of nodes in the most recently\ngenerated chunk by the current mapgen.\n\n### `heatmap`\n\nReturns an array containing the temperature values of nodes in the most\nrecently generated chunk by the current mapgen.\n\n### `humiditymap`\n\nReturns an array containing the humidity values of nodes in the most recently\ngenerated chunk by the current mapgen.\n\n### `gennotify`\n\nReturns a table mapping requested generation notification types to arrays of\npositions at which the corresponding generated structures are located within\nthe current chunk. To set the capture of positions of interest to be recorded\non generate, use `minetest.set_gen_notify()`.\nFor decorations, the returned positions are the ground surface 'place_on'\nnodes, not the decorations themselves. A 'simple' type decoration is often 1\nnode above the returned position and possibly displaced by 'place_offset_y'.\n\nPossible fields of the table returned are:\n\n* `dungeon`\n* `temple`\n* `cave_begin`\n* `cave_end`\n* `large_cave_begin`\n* `large_cave_end`\n* `decoration`\n\nDecorations have a key in the format of `\"decoration#id\"`, where `id` is the\nnumeric unique decoration ID as returned by `minetest.get_decoration_id`.\n\n\n\n\nRegistered entities\n===================\n\nFunctions receive a \"luaentity\" as `self`:\n\n* It has the member `.name`, which is the registered name `(\"mod:thing\")`\n* It has the member `.object`, which is an `ObjectRef` pointing to the object\n* The original prototype stuff is visible directly via a metatable\n\nCallbacks:\n","prefix":"iterp","body":"iterp(${1:minp}, ${2:maxp})"},{"desc":"    * Called when the object is instantiated.\n    * `dtime_s` is the time passed since the object was unloaded, which can be\n      used for updating the entity state.","prefix":"on_activate","body":"on_activate(${1:self}, ${2:staticdata}, ${3:dtime}_${4:s})"},{"desc":"    * Called on every server tick, after movement and collision processing.\n      `dtime` is usually 0.1 seconds, as per the `dedicated_server_step` setting\n      in `minetest.conf`.","prefix":"on_step","body":"on_step(${1:self}, ${2:dtime})"},{"desc":"    * Called when somebody punches the object.\n    * Note that you probably want to handle most punches using the automatic\n      armor group system.\n    * `puncher`: an `ObjectRef` (can be `nil`)\n    * `time_from_last_punch`: Meant for disallowing spamming of clicks\n      (can be `nil`).\n    * `tool_capabilities`: capability table of used tool (can be `nil`)\n    * `dir`: unit vector of direction of punch. Always defined. Points from the\n      puncher to the punched.\n    * `damage`: damage that will be done to entity.","prefix":"on_punch","body":"on_punch(${1:self}, ${2:puncher}, ${3:time}_${4:from}_${5:last}_${6:punch}, ${7:tool}_${8:capabilities}, ${9:dir}, ${10:damage})"},{"desc":"    * Called when the object dies.\n    * `killer`: an `ObjectRef` (can be `nil`)","prefix":"on_death","body":"on_death(${1:self}, ${2:killer})"},{"desc":"","prefix":"on_rightclick","body":"on_rightclick(${1:self}, ${2:clicker})"},{"desc":"    * `child`: an `ObjectRef` of the child that attaches","prefix":"on_attach_child","body":"on_attach_child(${1:self}, ${2:child})"},{"desc":"    * `child`: an `ObjectRef` of the child that detaches","prefix":"on_detach_child","body":"on_detach_child(${1:self}, ${2:child})"},{"desc":"    * `parent`: an `ObjectRef` (can be `nil`) from where it got detached\n    * This happens before the parent object is removed from the world","prefix":"on_detach","body":"on_detach(${1:self}, ${2:parent})"},{"desc":"    * Should return a string that will be passed to `on_activate` when the\n      object is instantiated the next time.\n\n\n\n\nL-system trees\n==============\n\nTree definition\n---------------\n\n    treedef={\n        axiom,         --string  initial tree axiom\n        rules_a,       --string  rules set A\n        rules_b,       --string  rules set B\n        rules_c,       --string  rules set C\n        rules_d,       --string  rules set D\n        trunk,         --string  trunk node name\n        leaves,        --string  leaves node name\n        leaves2,       --string  secondary leaves node name\n        leaves2_chance,--num     chance (0-100) to replace leaves with leaves2\n        angle,         --num     angle in deg\n        iterations,    --num     max # of iterations, usually 2 -5\n        random_level,  --num     factor to lower nr of iterations, usually 0 - 3\n        trunk_type,    --string  single/double/crossed) type of trunk: 1 node,\n                       --        2x2 nodes or 3x3 in cross shape\n        thin_branches, --boolean true -> use thin (1 node) branches\n        fruit,         --string  fruit node name\n        fruit_chance,  --num     chance (0-100) to replace leaves with fruit node\n        seed,          --num     random seed, if no seed is provided, the engine\n                                 will create one.\n    }\n\nKey for special L-System symbols used in axioms\n-----------------------------------------------\n\n* `G`: move forward one unit with the pen up\n* `F`: move forward one unit with the pen down drawing trunks and branches\n* `f`: move forward one unit with the pen down drawing leaves (100% chance)\n* `T`: move forward one unit with the pen down drawing trunks only\n* `R`: move forward one unit with the pen down placing fruit\n* `A`: replace with rules set A\n* `B`: replace with rules set B\n* `C`: replace with rules set C\n* `D`: replace with rules set D\n* `a`: replace with rules set A, chance 90%\n* `b`: replace with rules set B, chance 80%\n* `c`: replace with rules set C, chance 70%\n* `d`: replace with rules set D, chance 60%\n* `+`: yaw the turtle right by `angle` parameter\n* `-`: yaw the turtle left by `angle` parameter\n* `&`: pitch the turtle down by `angle` parameter\n* `^`: pitch the turtle up by `angle` parameter\n* `/`: roll the turtle to the right by `angle` parameter\n* `*`: roll the turtle to the left by `angle` parameter\n* `[`: save in stack current state info\n* `]`: recover from stack state info\n\nExample\n-------\n\nSpawn a small apple tree:\n\n    pos = {x=230,y=20,z=4}\n    apple_tree={\n        axiom=\"FFFFFAFFBF\",\n        rules_a=\"[&&&FFFFF&&FFFF][&&&++++FFFFF&&FFFF][&&&----FFFFF&&FFFF]\",\n        rules_b=\"[&&&++FFFFF&&FFFF][&&&--FFFFF&&FFFF][&&&------FFFFF&&FFFF]\",\n        trunk=\"default:tree\",\n        leaves=\"default:leaves\",\n        angle=30,\n        iterations=2,\n        random_level=0,\n        trunk_type=\"single\",\n        thin_branches=true,\n        fruit_chance=10,\n        fruit=\"default:apple\"\n    }\n    minetest.spawn_tree(pos,apple_tree)\n\n\n\n\n'minetest' namespace reference\n==============================\n\nUtilities\n---------\n","prefix":"get_staticdata","body":"get_staticdata(${1:self})"},{"desc":"returns the currently loading mod's name,\n  when loading a mod.","prefix":"minetest.get_current_modname","body":"minetest.get_current_modname()"},{"desc":"returns e.g.\n  `\"/home/user/.minetest/usermods/modname\"`.\n    * Useful for loading additional `.lua` modules or static data from mod","prefix":"minetest.get_modpath","body":"minetest.get_modpath(${1:modname})"},{"desc":"returns a list of installed mods\n    * Return a list of installed mods, sorted alphabetically","prefix":"minetest.get_modnames","body":"minetest.get_modnames()"},{"desc":"returns e.g. `\\\"/home/user/.minetest/world\\\"`\n    * Useful for storing custom data","prefix":"minetest.get_worldpath","body":"minetest.get_worldpath()"},{"desc":"* `minetest.features`: Table containing API feature flags\n\n      {\n          glasslike_framed = true,  -- 0.4.7\n          nodebox_as_selectionbox = true,  -- 0.4.7\n          get_all_craft_recipes_works = true,  -- 0.4.7\n          -- The transparency channel of textures can optionally be used on\n          -- nodes (0.4.7)\n          use_texture_alpha = true,\n          -- Tree and grass ABMs are no longer done from C++ (0.4.8)\n          no_legacy_abms = true,\n          -- Texture grouping is possible using parentheses (0.4.11)\n          texture_names_parens = true,\n          -- Unique Area ID for AreaStore:insert_area (0.4.14)\n          area_store_custom_ids = true,\n          -- add_entity supports passing initial staticdata to on_activate\n          -- (0.4.16)\n          add_entity_with_staticdata = true,\n          -- Chat messages are no longer predicted (0.4.16)\n          no_chat_message_prediction = true,\n          -- The transparency channel of textures can optionally be used on\n          -- objects (ie: players and lua entities) (5.0.0)\n          object_use_texture_alpha = true,\n          -- Object selectionbox is settable independently from collisionbox\n          -- (5.0.0)\n          object_independent_selectionbox = true,\n          -- Specifies whether binary data can be uploaded or downloaded using\n          -- the HTTP API (5.1.0)\n          httpfetch_binary_data = true,\n          -- Whether formspec_version[<version>] may be used (5.1.0)\n          formspec_version_element = true,\n          -- Whether AreaStore's IDs are kept on save/load (5.1.0)\n          area_store_persistent_ids = true,\n      }\n","prefix":"minetest.is_singleplayer","body":"minetest.is_singleplayer()"},{"desc":"returns `boolean, missing_features`\n    * `arg`: string or table in format `{foo=true, bar=true}`\n    * `missing_features`: `{foo=true, bar=true}`","prefix":"minetest.has_feature","body":"minetest.has_feature(${1:arg})"},{"desc":"Table containing information\n  about a player. Example return value:\n\n      {\n          address = \"127.0.0.1\",     -- IP address of client\n          ip_version = 4,            -- IPv4 / IPv6\n          min_rtt = 0.01,            -- minimum round trip time\n          max_rtt = 0.2,             -- maximum round trip time\n          avg_rtt = 0.02,            -- average round trip time\n          min_jitter = 0.01,         -- minimum packet time jitter\n          max_jitter = 0.5,          -- maximum packet time jitter\n          avg_jitter = 0.03,         -- average packet time jitter\n          connection_uptime = 200,   -- seconds since client connected\n          protocol_version = 32,     -- protocol version used by client\n          formspec_version = 2,      -- supported formspec version\n          -- following information is available on debug build only!!!\n          -- DO NOT USE IN MODS\n          --ser_vers = 26,             -- serialization version used by client\n          --major = 0,                 -- major version number\n          --minor = 4,                 -- minor version number\n          --patch = 10,                -- patch version number\n          --vers_string = \"0.4.9-git\", -- full version string\n          --state = \"Active\"           -- current client state\n      }\n","prefix":"minetest.get_player_information","body":"minetest.get_player_information(${1:player}_${2:name})"},{"desc":"returns success.\n    * Creates a directory specified by `path`, creating parent directories\n      if they don't exist.","prefix":"minetest.mkdir","body":"minetest.mkdir(${1:path})"},{"desc":"returns list of entry names\n    * is_dir is one of:\n        * nil: return all entries,\n        * true: return only subdirectory names, or\n        * false: return only file names.","prefix":"minetest.get_dir_list","body":"minetest.get_dir_list(${1:path}, ${2:}[${3:is}_${4:dir}])"},{"desc":"returns boolean indicating success\n    * Replaces contents of file at path with new contents in a safe (atomic)\n      way. Use this instead of below code when writing e.g. database files:\n      `local f = io.open(path, \"wb\"); f:write(content); f:close()`","prefix":"minetest.safe_file_write","body":"minetest.safe_file_write(${1:path}, ${2:content})"},{"desc":"returns a table containing components of the\n   engine version.  Components:\n    * `project`: Name of the project, eg, \"Minetest\"\n    * `string`: Simple version, eg, \"1.2.3-dev\"\n    * `hash`: Full git version (only set if available),\n      eg, \"1.2.3-dev-01234567-dirty\".\n  Use this for informational purposes only. The information in the returned\n  table does not represent the capabilities of the engine, nor is it\n  reliable or verifiable. Compatible forks will have a different name and\n  version entirely. To check for the presence of engine features, test\n  whether the functions exported by the wanted features exist. For example:\n  `if minetest.check_for_falling then ... end`.","prefix":"minetest.get_version","body":"minetest.get_version()"},{"desc":"returns the sha1 hash of data\n    * `data`: string of data to hash\n    * `raw`: return raw bytes instead of hex digits, default: false\n\nLogging\n-------\n","prefix":"minetest.sha1","body":"minetest.sha1(${1:data}, ${2:}[${3:raw}])"},{"desc":"    * Equivalent to `minetest.log(table.concat({...}, \"\\t\"))`","prefix":"minetest.debug","body":"minetest.debug(...)"},{"desc":"    * `level` is one of `\"none\"`, `\"error\"`, `\"warning\"`, `\"action\"`,\n      `\"info\"`, or `\"verbose\"`.  Default is `\"none\"`.\n\nRegistration functions\n----------------------\n\nCall these functions only at load time!\n\n### Environment\n","prefix":"minetest.log","body":"minetest.log([${1:level}, ]${2:text})"},{"desc":"","prefix":"minetest.register_node","body":"minetest.register_node(${1:name}, ${2:node definition})"},{"desc":"","prefix":"minetest.register_craftitem","body":"minetest.register_craftitem(${1:name}, ${2:item definition})"},{"desc":"","prefix":"minetest.register_tool","body":"minetest.register_tool(${1:name}, ${2:item definition})"},{"desc":"    * Overrides fields of an item registered with register_node/tool/craftitem.\n    * Note: Item must already be defined, (opt)depend on the mod defining it.\n    * Example: `minetest.override_item(\"default:mese\",\n      {light_source=minetest.LIGHT_MAX})`","prefix":"minetest.override_item","body":"minetest.override_item(${1:name}, ${2:redefinition})"},{"desc":"    * Unregisters the item from the engine, and deletes the entry with key\n      `name` from `minetest.registered_items` and from the associated item table\n      according to its nature: `minetest.registered_nodes`, etc.","prefix":"minetest.unregister_item","body":"minetest.unregister_item(${1:name})"},{"desc":"","prefix":"minetest.register_entity","body":"minetest.register_entity(${1:name}, ${2:entity definition})"},{"desc":"","prefix":"minetest.register_abm","body":"minetest.register_abm(${1:abm definition})"},{"desc":"","prefix":"minetest.register_lbm","body":"minetest.register_lbm(${1:lbm definition})"},{"desc":"    * Also use this to set the 'mapgen aliases' needed in a game for the core\n      mapgens. See [Mapgen aliases] section above.","prefix":"minetest.register_alias","body":"minetest.register_alias(${1:alias}, ${2:original}_${3:name})"},{"desc":"","prefix":"minetest.register_alias_force","body":"minetest.register_alias_force(${1:alias}, ${2:original}_${3:name})"},{"desc":"    * Returns an integer object handle uniquely identifying the registered\n      ore on success.\n    * The order of ore registrations determines the order of ore generation.","prefix":"minetest.register_ore","body":"minetest.register_ore(${1:ore definition})"},{"desc":"    * Returns an integer object handle uniquely identifying the registered\n      biome on success. To get the biome ID, use `minetest.get_biome_id`.","prefix":"minetest.register_biome","body":"minetest.register_biome(${1:biome definition})"},{"desc":"    * Unregisters the biome from the engine, and deletes the entry with key\n      `name` from `minetest.registered_biomes`.","prefix":"minetest.unregister_biome","body":"minetest.unregister_biome(${1:name})"},{"desc":"    * Returns an integer object handle uniquely identifying the registered\n      decoration on success. To get the decoration ID, use\n      `minetest.get_decoration_id`.\n    * The order of decoration registrations determines the order of decoration\n      generation.","prefix":"minetest.register_decoration","body":"minetest.register_decoration(${1:decoration definition})"},{"desc":"    * Returns an integer object handle uniquely identifying the registered\n      schematic on success.\n    * If the schematic is loaded from a file, the `name` field is set to the\n      filename.\n    * If the function is called when loading the mod, and `name` is a relative\n      path, then the current mod path will be prepended to the schematic\n      filename.","prefix":"minetest.register_schematic","body":"minetest.register_schematic(${1:schematic definition})"},{"desc":"    * Clears all ores currently registered.","prefix":"minetest.clear_registered_ores","body":"minetest.clear_registered_ores()"},{"desc":"    * Clears all biomes currently registered.","prefix":"minetest.clear_registered_biomes","body":"minetest.clear_registered_biomes()"},{"desc":"    * Clears all decorations currently registered.","prefix":"minetest.clear_registered_decorations","body":"minetest.clear_registered_decorations()"},{"desc":"    * Clears all schematics currently registered.\n\n### Gameplay\n","prefix":"minetest.clear_registered_schematics","body":"minetest.clear_registered_schematics()"},{"desc":"    * Check recipe table syntax for different types below.","prefix":"minetest.register_craft","body":"minetest.register_craft(${1:recipe})"},{"desc":"    * Will erase existing craft based either on output item or on input recipe.\n    * Specify either output or input only. If you specify both, input will be\n      ignored. For input use the same recipe table syntax as for\n      `minetest.register_craft(recipe)`. For output specify only the item,\n      without a quantity.\n    * Returns false if no erase candidate could be found, otherwise returns true.\n    * **Warning**! The type field (\"shaped\", \"cooking\" or any other) will be\n      ignored if the recipe contains output. Erasing is then done independently\n      from the crafting method.","prefix":"minetest.clear_craft","body":"minetest.clear_craft(${1:recipe})"},{"desc":"","prefix":"minetest.register_chatcommand","body":"minetest.register_chatcommand(${1:cmd}, ${2:chatcommand definition})"},{"desc":"    * Overrides fields of a chatcommand registered with `register_chatcommand`.","prefix":"minetest.override_chatcommand","body":"minetest.override_chatcommand(${1:name}, ${2:redefinition})"},{"desc":"    * Unregisters a chatcommands registered with `register_chatcommand`.","prefix":"minetest.unregister_chatcommand","body":"minetest.unregister_chatcommand(${1:name})"},{"desc":"    * `definition` can be a description or a definition table (see [Privilege\n      definition]).\n    * If it is a description, the priv will be granted to singleplayer and admin\n      by default.\n    * To allow players with `basic_privs` to grant, see the `basic_privs`\n      minetest.conf setting.","prefix":"minetest.register_privilege","body":"minetest.register_privilege(${1:name}, ${2:definition})"},{"desc":"    * Registers an auth handler that overrides the builtin one.\n    * This function can be called by a single mod once only.\n\nGlobal callback registration functions\n--------------------------------------\n\nCall these functions only at load time!\n","prefix":"minetest.register_authentication_handler","body":"minetest.register_authentication_handler(${1:authentication handler definition})"},{"desc":"    * Called every server step, usually interval of 0.1s","prefix":"minetest.register_globalstep","body":"minetest.register_globalstep(${1:function}(${2:dtime}))"},{"desc":"    * Called after mods have finished loading and before the media is cached or the\n      aliases handled.","prefix":"minetest.register_on_mods_loaded","body":"minetest.register_on_mods_loaded(${1:function}())"},{"desc":"    * Called before server shutdown\n    * **Warning**: If the server terminates abnormally (i.e. crashes), the\n      registered callbacks **will likely not be run**. Data should be saved at\n      semi-frequent intervals as well as on server shutdown.","prefix":"minetest.register_on_shutdown","body":"minetest.register_on_shutdown(${1:function}())"},{"desc":"    * Called when a node has been placed\n    * If return `true` no item is taken from `itemstack`\n    * `placer` may be any valid ObjectRef or nil.\n    * **Not recommended**; use `on_construct` or `after_place_node` in node\n      definition whenever possible.","prefix":"minetest.register_on_placenode","body":"minetest.register_on_placenode(${1:function}(${2:pos}, ${3:newnode}, ${4:placer}, ${5:oldnode}, ${6:itemstack}, ${7:pointed}_${8:thing}))"},{"desc":"    * Called when a node has been dug.\n    * **Not recommended**; Use `on_destruct` or `after_dig_node` in node\n      definition whenever possible.","prefix":"minetest.register_on_dignode","body":"minetest.register_on_dignode(${1:function}(${2:pos}, ${3:oldnode}, ${4:digger}))"},{"desc":"    * Called when a node is punched","prefix":"minetest.register_on_punchnode","body":"minetest.register_on_punchnode(${1:function}(${2:pos}, ${3:node}, ${4:puncher}, ${5:pointed}_${6:thing}))"},{"desc":"    * Called after generating a piece of world. Modifying nodes inside the area\n      is a bit faster than usually.","prefix":"minetest.register_on_generated","body":"minetest.register_on_generated(${1:function}(${2:minp}, ${3:maxp}, ${4:blockseed}))"},{"desc":"    * Called after a new player has been created","prefix":"minetest.register_on_newplayer","body":"minetest.register_on_newplayer(${1:function}(${2:ObjectRef}))"},{"desc":"    * Called when a player is punched\n    * Note: This callback is invoked even if the punched player is dead.\n    * `player`: ObjectRef - Player that was punched\n    * `hitter`: ObjectRef - Player that hit\n    * `time_from_last_punch`: Meant for disallowing spamming of clicks\n      (can be nil).\n    * `tool_capabilities`: Capability table of used tool (can be nil)\n    * `dir`: Unit vector of direction of punch. Always defined. Points from\n      the puncher to the punched.\n    * `damage`: Number that represents the damage calculated by the engine\n    * should return `true` to prevent the default damage mechanism","prefix":"minetest.register_on_punchplayer","body":"minetest.register_on_punchplayer(${1:function}(${2:player}, ${3:hitter}, ${4:time}_${5:from}_${6:last}_${7:punch}, ${8:tool}_${9:capabilities}, ${10:dir}, ${11:damage}))"},{"desc":"    * Called when the player gets damaged or healed\n    * `player`: ObjectRef of the player\n    * `hp_change`: the amount of change. Negative when it is damage.\n    * `reason`: a PlayerHPChangeReason table.\n        * The `type` field will have one of the following values:\n            * `set_hp`: A mod or the engine called `set_hp` without\n                        giving a type - use this for custom damage types.\n            * `punch`: Was punched. `reason.object` will hold the puncher, or nil if none.\n            * `fall`\n            * `node_damage`: `damage_per_second` from a neighbouring node.\n                             `reason.node` will hold the node name or nil.\n            * `drown`\n            * `respawn`\n        * Any of the above types may have additional fields from mods.\n        * `reason.from` will be `mod` or `engine`.\n    * `modifier`: when true, the function should return the actual `hp_change`.\n       Note: modifiers only get a temporary `hp_change` that can be modified by later modifiers.\n       Modifiers can return true as a second argument to stop the execution of further functions.\n       Non-modifiers receive the final HP change calculated by the modifiers.","prefix":"minetest.register_on_player_hpchange","body":"minetest.register_on_player_hpchange(${1:function}(${2:player}, ${3:hp}_${4:change}, ${5:reason}), ${6:modifier})"},{"desc":"    * Called when a player dies\n    * `reason`: a PlayerHPChangeReason table, see register_on_player_hpchange","prefix":"minetest.register_on_dieplayer","body":"minetest.register_on_dieplayer(${1:function}(${2:ObjectRef}, ${3:reason}))"},{"desc":"    * Called when player is to be respawned\n    * Called _before_ repositioning of player occurs\n    * return true in func to disable regular player placement","prefix":"minetest.register_on_respawnplayer","body":"minetest.register_on_respawnplayer(${1:function}(${2:ObjectRef}))"},{"desc":"    * Called before a player joins the game\n    * If it returns a string, the player is disconnected with that string as\n      reason.","prefix":"minetest.register_on_prejoinplayer","body":"minetest.register_on_prejoinplayer(${1:function}(${2:name}, ${3:ip}))"},{"desc":"    * Called when a player joins the game","prefix":"minetest.register_on_joinplayer","body":"minetest.register_on_joinplayer(${1:function}(${2:ObjectRef}))"},{"desc":"    * Called when a player leaves the game\n    * `timed_out`: True for timeout, false for other reasons.","prefix":"minetest.register_on_leaveplayer","body":"minetest.register_on_leaveplayer(${1:function}(${2:ObjectRef}, ${3:timed}_${4:out}))"},{"desc":"    * Called when a client attempts to log into an account but supplies the\n      wrong password.\n    * `ip`: The IP address of the client.\n    * `name`: The account the client attempted to log into.","prefix":"minetest.register_on_auth_fail","body":"minetest.register_on_auth_fail(${1:function}(${2:name}, ${3:ip}))"},{"desc":"    * Called when a player cheats\n    * `cheat`: `{type=<cheat_type>}`, where `<cheat_type>` is one of:\n        * `moved_too_fast`\n        * `interacted_too_far`\n        * `interacted_while_dead`\n        * `finished_unknown_dig`\n        * `dug_unbreakable`\n        * `dug_too_fast`","prefix":"minetest.register_on_cheat","body":"minetest.register_on_cheat(${1:function}(${2:ObjectRef}, ${3:cheat}))"},{"desc":"    * Called always when a player says something\n    * Return `true` to mark the message as handled, which means that it will\n      not be sent to other players.","prefix":"minetest.register_on_chat_message","body":"minetest.register_on_chat_message(${1:function}(${2:name}, ${3:message}))"},{"desc":"    * Called when the server received input from `player` in a formspec with\n      the given `formname`. Specifically, this is called on any of the\n      following events:\n          * a button was pressed,\n          * Enter was pressed while the focus was on a text field\n          * a checkbox was toggled,\n          * something was selecteed in a drop-down list,\n          * a different tab was selected,\n          * selection was changed in a textlist or table,\n          * an entry was double-clicked in a textlist or table,\n          * a scrollbar was moved, or\n          * the form was actively closed by the player.\n    * Fields are sent for formspec elements which define a field. `fields`\n      is a table containing each formspecs element value (as string), with\n      the `name` parameter as index for each. The value depends on the\n      formspec element type:\n        * `button` and variants: If pressed, contains the user-facing button\n          text as value. If not pressed, is `nil`\n        * `field`, `textarea` and variants: Text in the field\n        * `dropdown`: Text of selected item\n        * `tabheader`: Tab index, starting with `\"1\"` (only if tab changed)\n        * `checkbox`: `\"true\"` if checked, `\"false\"` if unchecked\n        * `textlist`: See `minetest.explode_textlist_event`\n        * `table`: See `minetest.explode_table_event`\n        * `scrollbar`: See `minetest.explode_scrollbar_event`\n        * Special case: `[\"quit\"]=\"true\"` is sent when the user actively\n          closed the form by mouse click, keypress or through a button_exit[]\n          element.\n        * Special case: `[\"key_enter\"]=\"true\"` is sent when the user pressed\n          the Enter key and the focus was either nowhere (causing the formspec\n          to be closed) or on a button. If the focus was on a text field,\n          additionally, the index `key_enter_field` contains the name of the\n          text field. See also: `field_close_on_enter`.\n    * Newest functions are called first\n    * If function returns `true`, remaining functions are not called","prefix":"minetest.register_on_player_receive_fields","body":"minetest.register_on_player_receive_fields(${1:function}(${2:player}, ${3:formname}, ${4:fields}))"},{"desc":"    * Called when `player` crafts something\n    * `itemstack` is the output\n    * `old_craft_grid` contains the recipe (Note: the one in the inventory is\n      cleared).\n    * `craft_inv` is the inventory with the crafting grid\n    * Return either an `ItemStack`, to replace the output, or `nil`, to not\n      modify it.","prefix":"minetest.register_on_craft","body":"minetest.register_on_craft(${1:function}(${2:itemstack}, ${3:player}, ${4:old}_${5:craft}_${6:grid}, ${7:craft}_${8:inv}))"},{"desc":"    * The same as before, except that it is called before the player crafts, to\n      make craft prediction, and it should not change anything.","prefix":"minetest.register_craft_predict","body":"minetest.register_craft_predict(${1:function}(${2:itemstack}, ${3:player}, ${4:old}_${5:craft}_${6:grid}, ${7:craft}_${8:inv}))"},{"desc":"    * Determinates how much of a stack may be taken, put or moved to a\n      player inventory.\n    * `player` (type `ObjectRef`) is the player who modified the inventory\n      `inventory` (type `InvRef`).\n    * List of possible `action` (string) values and their\n      `inventory_info` (table) contents:\n        * `move`: `{from_list=string, to_list=string, from_index=number, to_index=number, count=number}`\n        * `put`:  `{listname=string, index=number, stack=ItemStack}`\n        * `take`: Same as `put`\n    * Return a numeric value to limit the amount of items to be taken, put or\n      moved. A value of `-1` for `take` will make the source stack infinite.","prefix":"minetest.register_allow_player_inventory_action","body":"minetest.register_allow_player_inventory_action(${1:function}(${2:player}, ${3:action}, ${4:inventory}, ${5:inventory}_${6:info}))"},{"desc":"    * Called after a take, put or move event from/to/in a player inventory\n    * Function arguments: see `minetest.register_allow_player_inventory_action`\n    * Does not accept or handle any return value.","prefix":"minetest.register_on_player_inventory_action","body":"minetest.register_on_player_inventory_action(${1:function}(${2:player}, ${3:action}, ${4:inventory}, ${5:inventory}_${6:info}))"},{"desc":"    * Called by `builtin` and mods when a player violates protection at a\n      position (eg, digs a node or punches a protected entity).\n    * The registered functions can be called using\n      `minetest.record_protection_violation`.\n    * The provided function should check that the position is protected by the\n      mod calling this function before it prints a message, if it does, to\n      allow for multiple protection mods.","prefix":"minetest.register_on_protection_violation","body":"minetest.register_on_protection_violation(${1:function}(${2:pos}, ${3:name}))"},{"desc":"    * Called when an item is eaten, by `minetest.item_eat`\n    * Return `itemstack` to cancel the default item eat response (i.e.: hp increase).","prefix":"minetest.register_on_item_eat","body":"minetest.register_on_item_eat(${1:function}(${2:hp}_${3:change}, ${4:replace}_${5:with}_${6:item}, ${7:itemstack}, ${8:user}, ${9:pointed}_${10:thing}))"},{"desc":"    * Called when `granter` grants the priv `priv` to `name`.\n    * Note that the callback will be called twice if it's done by a player,\n      once with granter being the player name, and again with granter being nil.","prefix":"minetest.register_on_priv_grant","body":"minetest.register_on_priv_grant(${1:function}(${2:name}, ${3:granter}, ${4:priv}))"},{"desc":"    * Called when `revoker` revokes the priv `priv` from `name`.\n    * Note that the callback will be called twice if it's done by a player,\n      once with revoker being the player name, and again with revoker being nil.","prefix":"minetest.register_on_priv_revoke","body":"minetest.register_on_priv_revoke(${1:function}(${2:name}, ${3:revoker}, ${4:priv}))"},{"desc":"    * Called when `name` user connects with `ip`.\n    * Return `true` to by pass the player limit","prefix":"minetest.register_can_bypass_userlimit","body":"minetest.register_can_bypass_userlimit(${1:function}(${2:name}, ${3:ip}))"},{"desc":"    * Called when an incoming mod channel message is received\n    * You should have joined some channels to receive events.\n    * If message comes from a server mod, `sender` field is an empty string.\n\nSetting-related\n---------------\n\n* `minetest.settings`: Settings object containing all of the settings from the\n  main config file (`minetest.conf`).","prefix":"minetest.register_on_modchannel_message","body":"minetest.register_on_modchannel_message(${1:function}(${2:channel}_${3:name}, ${4:sender}, ${5:message}))"},{"desc":"Loads a setting from the main settings and\n  parses it as a position (in the format `(1,2,3)`). Returns a position or nil.\n\nAuthentication\n--------------\n","prefix":"minetest.setting_get_pos","body":"minetest.setting_get_pos(${1:name})"},{"desc":"returns `{priv1=true,...}`","prefix":"minetest.string_to_privs","body":"minetest.string_to_privs(${1:str})"},{"desc":"returns `\\\"priv1,priv2,...\\\"`\n    * Convert between two privilege representations\n* `minetest.get_player_privs(name) -> {priv1=true,...}`","prefix":"minetest.privs_to_string","body":"minetest.privs_to_string(${1:privs})"},{"desc":"  returns `bool, missing_privs`\n    * A quickhand for checking privileges.\n    * `player_or_name`: Either a Player object or the name of a player.\n    * `...` is either a list of strings, e.g. `\"priva\", \"privb\"` or\n      a table, e.g. `{ priva = true, privb = true }`.\n","prefix":"minetest.check_player_privs","body":"minetest.check_player_privs(${1:player}_${2:or}_${3:name}, ${4:}...)"},{"desc":"    * Returns true if the \"password entry\" for a player with name matches given\n      password, false otherwise.\n    * The \"password entry\" is the password representation generated by the\n      engine as returned as part of a `get_auth()` call on the auth handler.\n    * Only use this function for making it possible to log in via password from\n      external protocols such as IRC, other uses are frowned upon.","prefix":"minetest.check_password_entry","body":"minetest.check_password_entry(${1:name}, ${2:entry}, ${3:password})"},{"desc":"    * Convert a name-password pair to a password hash that Minetest can use.\n    * The returned value alone is not a good basis for password checks based\n      on comparing the password hash in the database with the password hash\n      from the function, with an externally provided password, as the hash\n      in the db might use the new SRP verifier format.\n    * For this purpose, use `minetest.check_password_entry` instead.","prefix":"minetest.get_password_hash","body":"minetest.get_password_hash(${1:name}, ${2:raw}_${3:password})"},{"desc":"returns an IP address string for the player\n  `name`.\n    * The player needs to be online for this to be successful.\n","prefix":"minetest.get_player_ip","body":"minetest.get_player_ip(${1:name})"},{"desc":"Return the currently active auth handler\n    * See the [Authentication handler definition]\n    * Use this to e.g. get the authentication data for a player:\n      `local auth_data = minetest.get_auth_handler().get_auth(playername)`","prefix":"minetest.get_auth_handler","body":"minetest.get_auth_handler()"},{"desc":"    * Must be called by the authentication handler for privilege changes.\n    * `name`: string; if omitted, all auth data should be considered modified","prefix":"minetest.notify_authentication_modified","body":"minetest.notify_authentication_modified(${1:name})"},{"desc":"Set password hash of\n  player `name`.","prefix":"minetest.set_player_password","body":"minetest.set_player_password(${1:name}, ${2:password}_${3:hash})"},{"desc":"Set privileges of player\n  `name`.","prefix":"minetest.set_player_privs","body":"minetest.set_player_privs(${1:name}, ${2:}{${3:priv1}=${4:true}, ...})"},{"desc":"    * See `reload()` in authentication handler definition\n\n`minetest.set_player_password`, `minetest_set_player_privs`,\n`minetest_get_player_privs` and `minetest.auth_reload` call the authentication\nhandler.\n\nChat\n----\n","prefix":"minetest.auth_reload","body":"minetest.auth_reload()"},{"desc":"","prefix":"minetest.chat_send_all","body":"minetest.chat_send_all(${1:text})"},{"desc":"","prefix":"minetest.chat_send_player","body":"minetest.chat_send_player(${1:name}, ${2:text})"},{"desc":"    * Used by the server to format a chat message, based on the setting `chat_message_format`.\n      Refer to the documentation of the setting for a list of valid placeholders.\n    * Takes player name and message, and returns the formatted string to be sent to players.\n    * Can be redefined by mods if required, for things like colored names or messages.\n    * **Only** the first occurrence of each placeholder will be replaced.\n\nEnvironment access\n------------------\n","prefix":"minetest.format_chat_message","body":"minetest.format_chat_message(${1:name}, ${2:message})"},{"desc":"","prefix":"minetest.set_node","body":"minetest.set_node(${1:pos}, ${2:node})"},{"desc":"alias to `minetest.set_node`\n    * Set node at position `pos`\n    * `node`: table `{name=string, param1=number, param2=number}`\n    * If param1 or param2 is omitted, it's set to `0`.\n    * e.g. `minetest.set_node({x=0, y=10, z=0}, {name=\"default:wood\"})`","prefix":"minetest.add_node","body":"minetest.add_node(${1:pos}, ${2:node})"},{"desc":"    * Set node on all positions set in the first argument.\n    * e.g. `minetest.bulk_set_node({{x=0, y=1, z=1}, {x=1, y=2, z=2}}, {name=\"default:stone\"})`\n    * For node specification or position syntax see `minetest.set_node` call\n    * Faster than set_node due to single call, but still considerably slower\n      than Lua Voxel Manipulators (LVM) for large numbers of nodes.\n      Unlike LVMs, this will call node callbacks. It also allows setting nodes\n      in spread out positions which would cause LVMs to waste memory.\n      For setting a cube, this is 1.3x faster than set_node whereas LVM is 20\n      times faster.","prefix":"minetest.bulk_set_node","body":"minetest.bulk_set_node({${1:pos1}, ${2:pos2}, ${3:pos3}, ${4:}...}, ${5:node})"},{"desc":"    * Set node at position, but don't remove metadata","prefix":"minetest.swap_node","body":"minetest.swap_node(${1:pos}, ${2:node})"},{"desc":"    * By default it does the same as `minetest.set_node(pos, {name=\"air\"})`","prefix":"minetest.remove_node","body":"minetest.remove_node(${1:pos})"},{"desc":"    * Returns the node at the given position as table in the format\n      `{name=\"node_name\", param1=0, param2=0}`,\n      returns `{name=\"ignore\", param1=0, param2=0}` for unloaded areas.","prefix":"minetest.get_node","body":"minetest.get_node(${1:pos})"},{"desc":"    * Same as `get_node` but returns `nil` for unloaded areas.","prefix":"minetest.get_node_or_nil","body":"minetest.get_node_or_nil(${1:pos})"},{"desc":"    * Gets the light value at the given position. Note that the light value\n      \"inside\" the node at the given position is returned, so you usually want\n      to get the light value of a neighbor.\n    * `pos`: The position where to measure the light.\n    * `timeofday`: `nil` for current time, `0` for night, `0.5` for day\n    * Returns a number between `0` and `15` or `nil`","prefix":"minetest.get_node_light","body":"minetest.get_node_light(${1:pos}, ${2:timeofday})"},{"desc":"    * Place node with the same effects that a player would cause","prefix":"minetest.place_node","body":"minetest.place_node(${1:pos}, ${2:node})"},{"desc":"    * Dig node with the same effects that a player would cause\n    * Returns `true` if successful, `false` on failure (e.g. protected location)","prefix":"minetest.dig_node","body":"minetest.dig_node(${1:pos})"},{"desc":"    * Punch node with the same effects that a player would cause","prefix":"minetest.punch_node","body":"minetest.punch_node(${1:pos})"},{"desc":"    * Change node into falling node\n    * Returns `true` if successful, `false` on failure\n","prefix":"minetest.spawn_falling_node","body":"minetest.spawn_falling_node(${1:pos})"},{"desc":"    * Get a table of positions of nodes that have metadata within a region\n      {pos1, pos2}.","prefix":"minetest.find_nodes_with_meta","body":"minetest.find_nodes_with_meta(${1:pos1}, ${2:pos2})"},{"desc":"    * Get a `NodeMetaRef` at that position","prefix":"minetest.get_meta","body":"minetest.get_meta(${1:pos})"},{"desc":"    * Get `NodeTimerRef`\n","prefix":"minetest.get_node_timer","body":"minetest.get_node_timer(${1:pos})"},{"desc":"Spawn Lua-defined entity at\n  position.\n    * Returns `ObjectRef`, or `nil` if failed","prefix":"minetest.add_entity","body":"minetest.add_entity(${1:pos}, ${2:name}, ${3:}[${4:staticdata}])"},{"desc":"Spawn item\n    * Returns `ObjectRef`, or `nil` if failed","prefix":"minetest.add_item","body":"minetest.add_item(${1:pos}, ${2:item})"},{"desc":"Get an `ObjectRef` to a player","prefix":"minetest.get_player_by_name","body":"minetest.get_player_by_name(${1:name})"},{"desc":"returns a list of\n  ObjectRefs.\n    * `radius`: using an euclidean metric","prefix":"minetest.get_objects_inside_radius","body":"minetest.get_objects_inside_radius(${1:pos}, ${2:radius})"},{"desc":"    * `val` is between `0` and `1`; `0` for midnight, `0.5` for midday","prefix":"minetest.set_timeofday","body":"minetest.set_timeofday(${1:val})"},{"desc":"","prefix":"minetest.get_timeofday","body":"minetest.get_timeofday()"},{"desc":"returns the time, in seconds, since the world was\n  created.","prefix":"minetest.get_gametime","body":"minetest.get_gametime()"},{"desc":"returns number days elapsed since world was\n  created.\n    * accounts for time changes.","prefix":"minetest.get_day_count","body":"minetest.get_day_count()"},{"desc":"returns\n  pos or `nil`.\n    * `radius`: using a maximum metric\n    * `nodenames`: e.g. `{\"ignore\", \"group:tree\"}` or `\"default:dirt\"`\n    * `search_center` is an optional boolean (default: `false`)\n      If true `pos` is also checked for the nodes","prefix":"minetest.find_node_near","body":"minetest.find_node_near(${1:pos}, ${2:radius}, ${3:nodenames}, ${4:}[${5:search}_${6:center}])"},{"desc":"returns a list of\n  positions.\n    * `nodenames`: e.g. `{\"ignore\", \"group:tree\"}` or `\"default:dirt\"`\n    * First return value: Table with all node positions\n    * Second return value: Table with the count of each node with the node name\n      as index.\n    * Area volume is limited to 4,096,000 nodes","prefix":"minetest.find_nodes_in_area","body":"minetest.find_nodes_in_area(${1:pos1}, ${2:pos2}, ${3:nodenames})"},{"desc":"returns a\n  list of positions.\n    * `nodenames`: e.g. `{\"ignore\", \"group:tree\"}` or `\"default:dirt\"`\n    * Return value: Table with all node positions with a node air above\n    * Area volume is limited to 4,096,000 nodes","prefix":"minetest.find_nodes_in_area_under_air","body":"minetest.find_nodes_in_area_under_air(${1:pos1}, ${2:pos2}, ${3:nodenames})"},{"desc":"","prefix":"minetest.get_perlin","body":"minetest.get_perlin(${1:noiseparams})"},{"desc":"    * Return world-specific perlin noise (`int(worldseed)+seeddiff`)","prefix":"minetest.get_perlin","body":"minetest.get_perlin(${1:seeddiff}, ${2:octaves}, ${3:persistence}, ${4:spread})"},{"desc":"    * Return voxel manipulator object.\n    * Loads the manipulator from the map if positions are passed.","prefix":"minetest.get_voxel_manip","body":"minetest.get_voxel_manip([${1:pos1}, ${2:pos2}])"},{"desc":"    * Set the types of on-generate notifications that should be collected.\n    * `flags` is a flag field with the available flags:\n        * dungeon\n        * temple\n        * cave_begin\n        * cave_end\n        * large_cave_begin\n        * large_cave_end\n        * decoration\n    * The second parameter is a list of IDs of decorations which notification\n      is requested for.","prefix":"minetest.set_gen_notify","body":"minetest.set_gen_notify(${1:flags}, ${2:}{${3:deco}_${4:ids}})"},{"desc":"    * Returns a flagstring and a table with the `deco_id`s.","prefix":"minetest.get_gen_notify","body":"minetest.get_gen_notify()"},{"desc":"    * Returns the decoration ID number for the provided decoration name string,\n      or `nil` on failure.","prefix":"minetest.get_decoration_id","body":"minetest.get_decoration_id(${1:decoration}_${2:name})"},{"desc":"    * Return requested mapgen object if available (see [Mapgen objects])","prefix":"minetest.get_mapgen_object","body":"minetest.get_mapgen_object(${1:objectname})"},{"desc":"    * Returns the heat at the position, or `nil` on failure.","prefix":"minetest.get_heat","body":"minetest.get_heat(${1:pos})"},{"desc":"    * Returns the humidity at the position, or `nil` on failure.","prefix":"minetest.get_humidity","body":"minetest.get_humidity(${1:pos})"},{"desc":"    * Returns a table containing:\n        * `biome` the biome id of the biome at that position\n        * `heat` the heat at the position\n        * `humidity` the humidity at the position\n    * Or returns `nil` on failure.","prefix":"minetest.get_biome_data","body":"minetest.get_biome_data(${1:pos})"},{"desc":"    * Returns the biome id, as used in the biomemap Mapgen object and returned\n      by `minetest.get_biome_data(pos)`, for a given biome_name string.","prefix":"minetest.get_biome_id","body":"minetest.get_biome_id(${1:biome}_${2:name})"},{"desc":"    * Returns the biome name string for the provided biome id, or `nil` on\n      failure.\n    * If no biomes have been registered, such as in mgv6, returns `default`.","prefix":"minetest.get_biome_name","body":"minetest.get_biome_name(${1:biome}_${2:id})"},{"desc":"    * Deprecated: use `minetest.get_mapgen_setting(name)` instead.\n    * Returns a table containing:\n        * `mgname`\n        * `seed`\n        * `chunksize`\n        * `water_level`\n        * `flags`","prefix":"minetest.get_mapgen_params","body":"minetest.get_mapgen_params()"},{"desc":"    * Deprecated: use `minetest.set_mapgen_setting(name, value, override)`\n      instead.\n    * Set map generation parameters.\n    * Function cannot be called after the registration period; only\n      initialization and `on_mapgen_init`.\n    * Takes a table as an argument with the fields:\n        * `mgname`\n        * `seed`\n        * `chunksize`\n        * `water_level`\n        * `flags`\n    * Leave field unset to leave that parameter unchanged.\n    * `flags` contains a comma-delimited string of flags to set, or if the\n      prefix `\"no\"` is attached, clears instead.\n    * `flags` is in the same format and has the same options as `mg_flags` in\n      `minetest.conf`.","prefix":"minetest.set_mapgen_params","body":"minetest.set_mapgen_params(${1:MapgenParams})"},{"desc":"    * Gets the *active* mapgen setting (or nil if none exists) in string\n      format with the following order of precedence:\n        1) Settings loaded from map_meta.txt or overrides set during mod\n           execution.\n        2) Settings set by mods without a metafile override\n        3) Settings explicitly set in the user config file, minetest.conf\n        4) Settings set as the user config default","prefix":"minetest.get_mapgen_setting","body":"minetest.get_mapgen_setting(${1:name})"},{"desc":"    * Same as above, but returns the value as a NoiseParams table if the\n      setting `name` exists and is a valid NoiseParams.","prefix":"minetest.get_mapgen_setting_noiseparams","body":"minetest.get_mapgen_setting_noiseparams(${1:name})"},{"desc":"    * Sets a mapgen param to `value`, and will take effect if the corresponding\n      mapgen setting is not already present in map_meta.txt.\n    * `override_meta` is an optional boolean (default: `false`). If this is set\n      to true, the setting will become the active setting regardless of the map\n      metafile contents.\n    * Note: to set the seed, use `\"seed\"`, not `\"fixed_map_seed\"`.","prefix":"minetest.set_mapgen_setting","body":"minetest.set_mapgen_setting(${1:name}, ${2:value}, ${3:}[${4:override}_${5:meta}])"},{"desc":"    * Same as above, except value is a NoiseParams table.","prefix":"minetest.set_mapgen_setting_noiseparams","body":"minetest.set_mapgen_setting_noiseparams(${1:name}, ${2:value}, ${3:}[${4:override}_${5:meta}])"},{"desc":"    * Sets the noiseparams setting of `name` to the noiseparams table specified\n      in `noiseparams`.\n    * `set_default` is an optional boolean (default: `true`) that specifies\n      whether the setting should be applied to the default config or current\n      active config.","prefix":"minetest.set_noiseparams","body":"minetest.set_noiseparams(${1:name}, ${2:noiseparams}, ${3:set}_${4:default})"},{"desc":"    * Returns a table of the noiseparams for name.","prefix":"minetest.get_noiseparams","body":"minetest.get_noiseparams(${1:name})"},{"desc":"    * Generate all registered ores within the VoxelManip `vm` and in the area\n      from `pos1` to `pos2`.\n    * `pos1` and `pos2` are optional and default to mapchunk minp and maxp.","prefix":"minetest.generate_ores","body":"minetest.generate_ores(${1:vm}, ${2:pos1}, ${3:pos2})"},{"desc":"    * Generate all registered decorations within the VoxelManip `vm` and in the\n      area from `pos1` to `pos2`.\n    * `pos1` and `pos2` are optional and default to mapchunk minp and maxp.","prefix":"minetest.generate_decorations","body":"minetest.generate_decorations(${1:vm}, ${2:pos1}, ${3:pos2})"},{"desc":"    * Clear all objects in the environment\n    * Takes an optional table as an argument with the field `mode`.\n        * mode = `\"full\"` : Load and go through every mapblock, clearing\n                            objects (default).\n        * mode = `\"quick\"`: Clear objects immediately in loaded mapblocks,\n                            clear objects in unloaded mapblocks only when the\n                            mapblocks are next activated.","prefix":"minetest.clear_objects","body":"minetest.clear_objects([${1:options}])"},{"desc":"    * Load the mapblocks containing the area from `pos1` to `pos2`.\n      `pos2` defaults to `pos1` if not specified.\n    * This function does not trigger map generation.","prefix":"minetest.load_area","body":"minetest.load_area(${1:pos1}[, ${2:pos2}])"},{"desc":"    * Queue all blocks in the area from `pos1` to `pos2`, inclusive, to be\n      asynchronously fetched from memory, loaded from disk, or if inexistent,\n      generates them.\n    * If `callback` is a valid Lua function, this will be called for each block\n      emerged.\n    * The function signature of callback is:\n      `function EmergeAreaCallback(blockpos, action, calls_remaining, param)`\n        * `blockpos` is the *block* coordinates of the block that had been\n          emerged.\n        * `action` could be one of the following constant values:\n            * `minetest.EMERGE_CANCELLED`\n            * `minetest.EMERGE_ERRORED`\n            * `minetest.EMERGE_FROM_MEMORY`\n            * `minetest.EMERGE_FROM_DISK`\n            * `minetest.EMERGE_GENERATED`\n        * `calls_remaining` is the number of callbacks to be expected after\n          this one.\n        * `param` is the user-defined parameter passed to emerge_area (or\n          nil if the parameter was absent).","prefix":"minetest.emerge_area","body":"minetest.emerge_area(${1:pos1}, ${2:pos2}, ${3:}[${4:callback}], ${5:}[${6:param}])"},{"desc":"    * delete all mapblocks in the area from pos1 to pos2, inclusive","prefix":"minetest.delete_area","body":"minetest.delete_area(${1:pos1}, ${2:pos2})"},{"desc":"returns `boolean, pos`\n    * Checks if there is anything other than air between pos1 and pos2.\n    * Returns false if something is blocking the sight.\n    * Returns the position of the blocking node when `false`\n    * `pos1`: First position\n    * `pos2`: Second position","prefix":"minetest.line_of_sight","body":"minetest.line_of_sight(${1:pos1}, ${2:pos2})"},{"desc":"returns `Raycast`\n    * Creates a `Raycast` object.\n    * `pos1`: start of the ray\n    * `pos2`: end of the ray\n    * `objects`: if false, only nodes will be returned. Default is `true`.\n    * `liquids`: if false, liquid nodes won't be returned. Default is `false`.","prefix":"minetest.raycast","body":"minetest.raycast(${1:pos1}, ${2:pos2}, ${3:objects}, ${4:liquids})"},{"desc":"    * returns table containing path\n    * returns a table of 3D points representing a path from `pos1` to `pos2` or\n      `nil`.\n    * `pos1`: start position\n    * `pos2`: end position\n    * `searchdistance`: number of blocks to search in each direction using a\n      maximum metric.\n    * `max_jump`: maximum height difference to consider walkable\n    * `max_drop`: maximum height difference to consider droppable\n    * `algorithm`: One of `\"A*_noprefetch\"` (default), `\"A*\"`, `\"Dijkstra\"`","prefix":"minetest.find_path","body":"minetest.find_path(${1:pos1}, ${2:pos2}, ${3:searchdistance}, ${4:max}_${5:jump}, ${6:max}_${7:drop}, ${8:algorithm})"},{"desc":"    * spawns L-system tree at given `pos` with definition in `treedef` table","prefix":"minetest.spawn_tree ","body":"minetest.spawn_tree (${1:pos}, ${2:}{${3:treedef}})"},{"desc":"    * add node to liquid update queue","prefix":"minetest.transforming_liquid_add","body":"minetest.transforming_liquid_add(${1:pos})"},{"desc":"    * get max available level for leveled node","prefix":"minetest.get_node_max_level","body":"minetest.get_node_max_level(${1:pos})"},{"desc":"    * get level of leveled node (water, snow)","prefix":"minetest.get_node_level","body":"minetest.get_node_level(${1:pos})"},{"desc":"    * set level of leveled node, default `level` equals `1`\n    * if `totallevel > maxlevel`, returns rest (`total-max`).","prefix":"minetest.set_node_level","body":"minetest.set_node_level(${1:pos}, ${2:level})"},{"desc":"    * increase level of leveled node by level, default `level` equals `1`\n    * if `totallevel > maxlevel`, returns rest (`total-max`)\n    * can be negative for decreasing","prefix":"minetest.add_node_level","body":"minetest.add_node_level(${1:pos}, ${2:level})"},{"desc":"returns `true`/`false`\n    * resets the light in a cuboid-shaped part of\n      the map and removes lighting bugs.\n    * Loads the area if it is not loaded.\n    * `pos1` is the corner of the cuboid with the least coordinates\n      (in node coordinates), inclusive.\n    * `pos2` is the opposite corner of the cuboid, inclusive.\n    * The actual updated cuboid might be larger than the specified one,\n      because only whole map blocks can be updated.\n      The actual updated area consists of those map blocks that intersect\n      with the given cuboid.\n    * However, the neighborhood of the updated area might change\n      as well, as light can spread out of the cuboid, also light\n      might be removed.\n    * returns `false` if the area is not fully generated,\n      `true` otherwise","prefix":"minetest.fix_light","body":"minetest.fix_light(${1:pos1}, ${2:pos2})"},{"desc":"    * causes an unsupported `group:falling_node` node to fall and causes an\n      unattached `group:attached_node` node to fall.\n    * does not spread these updates to neighbours.","prefix":"minetest.check_single_for_falling","body":"minetest.check_single_for_falling(${1:pos})"},{"desc":"    * causes an unsupported `group:falling_node` node to fall and causes an\n      unattached `group:attached_node` node to fall.\n    * spread these updates to neighbours and can cause a cascade\n      of nodes to fall.","prefix":"minetest.check_for_falling","body":"minetest.check_for_falling(${1:pos})"},{"desc":"    * Returns a player spawn y co-ordinate for the provided (x, z)\n      co-ordinates, or `nil` for an unsuitable spawn point.\n    * For most mapgens a 'suitable spawn point' is one with y between\n      `water_level` and `water_level + 16`, and in mgv7 well away from rivers,\n      so `nil` will be returned for many (x, z) co-ordinates.\n    * The spawn level returned is for a player spawn in unmodified terrain.\n    * The spawn level is intentionally above terrain level to cope with\n      full-node biome 'dust' nodes.\n\nMod channels\n------------\n\nYou can find mod channels communication scheme in `doc/mod_channels.png`.\n","prefix":"minetest.get_spawn_level","body":"minetest.get_spawn_level(${1:x}, ${2:z})"},{"desc":"    * Server joins channel `channel_name`, and creates it if necessary. You\n      should listen for incoming messages with\n      `minetest.register_on_modchannel_message`\n\nInventory\n---------\n\n`minetest.get_inventory(location)`: returns an `InvRef`\n\n* `location` = e.g.\n    * `{type=\"player\", name=\"celeron55\"}`\n    * `{type=\"node\", pos={x=, y=, z=}}`\n    * `{type=\"detached\", name=\"creative\"}`","prefix":"minetest.mod_channel_join","body":"minetest.mod_channel_join(${1:channel}_${2:name})"},{"desc":"returns\n  an `InvRef`.\n    * `callbacks`: See [Detached inventory callbacks]\n    * `player_name`: Make detached inventory available to one player\n      exclusively, by default they will be sent to every player (even if not\n      used).\n      Note that this parameter is mostly just a workaround and will be removed\n      in future releases.\n    * Creates a detached inventory. If it already exists, it is cleared.","prefix":"minetest.create_detached_inventory","body":"minetest.create_detached_inventory(${1:name}, ${2:callbacks}, ${3:}[${4:player}_${5:name}])"},{"desc":"    * Returns a `boolean` indicating whether the removal succeeded.","prefix":"minetest.remove_detached_inventory","body":"minetest.remove_detached_inventory(${1:name})"},{"desc":"  returns left over ItemStack.\n    * See `minetest.item_eat` and `minetest.register_on_item_eat`\n\nFormspec\n--------\n","prefix":"minetest.do_item_eat","body":"minetest.do_item_eat(${1:hp}_${2:change}, ${3:replace}_${4:with}_${5:item}, ${6:itemstack}, ${7:user}, ${8:pointed}_${9:thing})"},{"desc":"    * `playername`: name of player to show formspec\n    * `formname`: name passed to `on_player_receive_fields` callbacks.\n      It should follow the `\"modname:<whatever>\"` naming convention\n    * `formspec`: formspec to display","prefix":"minetest.show_formspec","body":"minetest.show_formspec(${1:playername}, ${2:formname}, ${3:formspec})"},{"desc":"    * `playername`: name of player to close formspec\n    * `formname`: has to exactly match the one given in `show_formspec`, or the\n      formspec will not close.\n    * calling `show_formspec(playername, formname, \"\")` is equal to this\n      expression.\n    * to close a formspec regardless of the formname, call\n      `minetest.close_formspec(playername, \"\")`.\n      **USE THIS ONLY WHEN ABSOLUTELY NECESSARY!**","prefix":"minetest.close_formspec","body":"minetest.close_formspec(${1:playername}, ${2:formname})"},{"desc":"returns a string\n    * escapes the characters \"[\", \"]\", \"\\\", \",\" and \";\", which can not be used\n      in formspecs.","prefix":"minetest.formspec_escape","body":"minetest.formspec_escape(${1:string})"},{"desc":"returns a table\n    * returns e.g. `{type=\"CHG\", row=1, column=2}`\n    * `type` is one of:\n        * `\"INV\"`: no row selected\n        * `\"CHG\"`: selected\n        * `\"DCL\"`: double-click","prefix":"minetest.explode_table_event","body":"minetest.explode_table_event(${1:string})"},{"desc":"returns a table\n    * returns e.g. `{type=\"CHG\", index=1}`\n    * `type` is one of:\n        * `\"INV\"`: no row selected\n        * `\"CHG\"`: selected\n        * `\"DCL\"`: double-click","prefix":"minetest.explode_textlist_event","body":"minetest.explode_textlist_event(${1:string})"},{"desc":"returns a table\n    * returns e.g. `{type=\"CHG\", value=500}`\n    * `type` is one of:\n        * `\"INV\"`: something failed\n        * `\"CHG\"`: has been changed\n        * `\"VAL\"`: not changed\n\nItem handling\n-------------\n","prefix":"minetest.explode_scrollbar_event","body":"minetest.explode_scrollbar_event(${1:string})"},{"desc":"    * Returns a string for making an image of a cube (useful as an item image)","prefix":"minetest.inventorycube","body":"minetest.inventorycube(${1:img1}, ${2:img2}, ${3:img3})"},{"desc":"    * Returns the position of a `pointed_thing` or `nil` if the `pointed_thing`\n      does not refer to a node or entity.\n    * If the optional `above` parameter is true and the `pointed_thing` refers\n      to a node, then it will return the `above` position of the `pointed_thing`.","prefix":"minetest.get_pointed_thing_position","body":"minetest.get_pointed_thing_position(${1:pointed}_${2:thing}, ${3:above})"},{"desc":"    * Convert a vector to a facedir value, used in `param2` for\n      `paramtype2=\"facedir\"`.\n    * passing something non-`nil`/`false` for the optional second parameter\n      causes it to take the y component into account.","prefix":"minetest.dir_to_facedir","body":"minetest.dir_to_facedir(${1:dir}, ${2:is6d})"},{"desc":"    * Convert a facedir back into a vector aimed directly out the \"back\" of a\n      node.","prefix":"minetest.facedir_to_dir","body":"minetest.facedir_to_dir(${1:facedir})"},{"desc":"    * Convert a vector to a wallmounted value, used for\n      `paramtype2=\"wallmounted\"`.","prefix":"minetest.dir_to_wallmounted","body":"minetest.dir_to_wallmounted(${1:dir})"},{"desc":"    * Convert a wallmounted value back into a vector aimed directly out the\n      \"back\" of a node.","prefix":"minetest.wallmounted_to_dir","body":"minetest.wallmounted_to_dir(${1:wallmounted})"},{"desc":"    * Convert a vector into a yaw (angle)","prefix":"minetest.dir_to_yaw","body":"minetest.dir_to_yaw(${1:dir})"},{"desc":"    * Convert yaw (angle) to a vector","prefix":"minetest.yaw_to_dir","body":"minetest.yaw_to_dir(${1:yaw})"},{"desc":"    * Returns a boolean. Returns `true` if the given `paramtype2` contains\n      color information (`color`, `colorwallmounted` or `colorfacedir`).","prefix":"minetest.is_colored_paramtype","body":"minetest.is_colored_paramtype(${1:ptype})"},{"desc":"    * Removes everything but the color information from the\n      given `param2` value.\n    * Returns `nil` if the given `paramtype2` does not contain color\n      information.","prefix":"minetest.strip_param2_color","body":"minetest.strip_param2_color(${1:param2}, ${2:paramtype2})"},{"desc":"    * Returns list of item names.\n    * **Note**: This will be removed or modified in a future version.","prefix":"minetest.get_node_drops","body":"minetest.get_node_drops(${1:nodename}, ${2:toolname})"},{"desc":"returns `output, decremented_input`\n    * `input.method` = `\"normal\"` or `\"cooking\"` or `\"fuel\"`\n    * `input.width` = for example `3`\n    * `input.items` = for example\n      `{stack1, stack2, stack3, stack4, stack 5, stack 6, stack 7, stack 8, stack 9}`\n    * `output.item` = `ItemStack`, if unsuccessful: empty `ItemStack`\n    * `output.time` = a number, if unsuccessful: `0`\n    * `output.replacements` = list of `ItemStack`s that couldn't be placed in\n      `decremented_input.items`\n    * `decremented_input` = like `input`","prefix":"minetest.get_craft_result","body":"minetest.get_craft_result(${1:input})"},{"desc":"returns input\n    * returns last registered recipe for output item (node)\n    * `output` is a node or item type such as `\"default:torch\"`\n    * `input.method` = `\"normal\"` or `\"cooking\"` or `\"fuel\"`\n    * `input.width` = for example `3`\n    * `input.items` = for example\n      `{stack1, stack2, stack3, stack4, stack 5, stack 6, stack 7, stack 8, stack 9}`\n        * `input.items` = `nil` if no recipe found","prefix":"minetest.get_craft_recipe","body":"minetest.get_craft_recipe(${1:output})"},{"desc":"returns a table or `nil`\n    * returns indexed table with all registered recipes for query item (node)\n      or `nil` if no recipe was found.\n    * recipe entry table:\n        * `method`: 'normal' or 'cooking' or 'fuel'\n        * `width`: 0-3, 0 means shapeless recipe\n        * `items`: indexed [1-9] table with recipe items\n        * `output`: string with item name and quantity\n    * Example query for `\"default:gold_ingot\"` will return table:\n\n          {\n              [1]={method = \"cooking\", width = 3, output = \"default:gold_ingot\",\n              items = {1 = \"default:gold_lump\"}},\n              [2]={method = \"normal\", width = 1, output = \"default:gold_ingot 9\",\n              items = {1 = \"default:goldblock\"}}\n          }","prefix":"minetest.get_all_craft_recipes","body":"minetest.get_all_craft_recipes(${1:query item})"},{"desc":"    * `drops`: list of itemstrings\n    * Handles drops from nodes after digging: Default action is to put them\n      into digger's inventory.\n    * Can be overridden to get different functionality (e.g. dropping items on\n      ground)","prefix":"minetest.handle_node_drops","body":"minetest.handle_node_drops(${1:pos}, ${2:drops}, ${3:digger})"},{"desc":"returns an item\n  string.\n    * Creates an item string which contains palette index information\n      for hardware colorization. You can use the returned string\n      as an output in a craft recipe.\n    * `item`: the item stack which becomes colored. Can be in string,\n      table and native form.\n    * `palette_index`: this index is added to the item stack","prefix":"minetest.itemstring_with_palette","body":"minetest.itemstring_with_palette(${1:item}, ${2:palette}_${3:index})"},{"desc":"returns an item string\n    * Creates an item string which contains static color information\n      for hardware colorization. Use this method if you wish to colorize\n      an item that does not own a palette. You can use the returned string\n      as an output in a craft recipe.\n    * `item`: the item stack which becomes colored. Can be in string,\n      table and native form.\n    * `colorstring`: the new color of the item stack\n\nRollback\n--------\n","prefix":"minetest.itemstring_with_color","body":"minetest.itemstring_with_color(${1:item}, ${2:colorstring})"},{"desc":"  returns `{{actor, pos, time, oldnode, newnode}, ...}`\n    * Find who has done something to a node, or near a node\n    * `actor`: `\"player:<name>\"`, also `\"liquid\"`.","prefix":"minetest.rollback_get_node_actions","body":"minetest.rollback_get_node_actions(${1:pos}, ${2:range}, ${3:seconds}, ${4:limit})"},{"desc":"returns\n  `boolean, log_messages`.\n    * Revert latest actions of someone\n    * `actor`: `\"player:<name>\"`, also `\"liquid\"`.\n\nDefaults for the `on_*` item definition functions\n-------------------------------------------------\n\nThese functions return the leftover itemstack.\n","prefix":"minetest.rollback_revert_actions_by","body":"minetest.rollback_revert_actions_by(${1:actor}, ${2:seconds})"},{"desc":"    * Place item as a node\n    * `param2` overrides `facedir` and wallmounted `param2`\n    * `prevent_after_place`: if set to `true`, `after_place_node` is not called\n      for the newly placed node to prevent a callback and placement loop\n    * returns `itemstack, success`","prefix":"minetest.item_place_node","body":"minetest.item_place_node(${1:itemstack}, ${2:placer}, ${3:pointed}_${4:thing}[, ${5:param2}, ${6:prevent}_${7:after}_${8:place}])"},{"desc":"    * Place item as-is","prefix":"minetest.item_place_object","body":"minetest.item_place_object(${1:itemstack}, ${2:placer}, ${3:pointed}_${4:thing})"},{"desc":"    * Use one of the above based on what the item is.\n    * Calls `on_rightclick` of `pointed_thing.under` if defined instead\n    * **Note**: is not called when wielded item overrides `on_place`\n    * `param2` overrides `facedir` and wallmounted `param2`\n    * returns `itemstack, success`","prefix":"minetest.item_place","body":"minetest.item_place(${1:itemstack}, ${2:placer}, ${3:pointed}_${4:thing}, ${5:param2})"},{"desc":"    * Drop the item","prefix":"minetest.item_drop","body":"minetest.item_drop(${1:itemstack}, ${2:dropper}, ${3:pos})"},{"desc":"    * Eat the item.\n    * `replace_with_item` is the itemstring which is added to the inventory.\n      If the player is eating a stack, then replace_with_item goes to a\n      different spot. Can be `nil`\n    * See `minetest.do_item_eat`\n\nDefaults for the `on_punch` and `on_dig` node definition callbacks\n------------------------------------------------------------------\n","prefix":"minetest.item_eat","body":"minetest.item_eat(${1:hp}_${2:change}, ${3:replace}_${4:with}_${5:item})"},{"desc":"    * Calls functions registered by `minetest.register_on_punchnode()`","prefix":"minetest.node_punch","body":"minetest.node_punch(${1:pos}, ${2:node}, ${3:puncher}, ${4:pointed}_${5:thing})"},{"desc":"    * Checks if node can be dug, puts item into inventory, removes node\n    * Calls functions registered by `minetest.registered_on_dignodes()`\n\nSounds\n------\n","prefix":"minetest.node_dig","body":"minetest.node_dig(${1:pos}, ${2:node}, ${3:digger})"},{"desc":"returns a handle\n    * `spec` is a `SimpleSoundSpec`\n    * `parameters` is a sound parameter table","prefix":"minetest.sound_play","body":"minetest.sound_play(${1:spec}, ${2:parameters})"},{"desc":"","prefix":"minetest.sound_stop","body":"minetest.sound_stop(${1:handle})"},{"desc":"    * `handle` is a handle returned by `minetest.sound_play`\n    * `step` determines how fast a sound will fade.\n      Negative step will lower the sound volume, positive step will increase\n      the sound volume.\n    * `gain` the target gain for the fade.\n\nTiming\n------\n","prefix":"minetest.sound_fade","body":"minetest.sound_fade(${1:handle}, ${2:step}, ${3:gain})"},{"desc":"    * Call the function `func` after `time` seconds, may be fractional\n    * Optional: Variable number of arguments that are passed to `func`\n\nServer\n------\n","prefix":"minetest.after","body":"minetest.after(${1:time}, ${2:func}, ${3:}...)"},{"desc":"request for\n  server shutdown. Will display `message` to clients.\n    * `reconnect` == true displays a reconnect button\n    * `delay` adds an optional delay (in seconds) before shutdown.\n      Negative delay cancels the current active shutdown.\n      Zero delay triggers an immediate shutdown.","prefix":"minetest.request_shutdown","body":"minetest.request_shutdown([${1:message}], [${2:reconnect}], [${3:delay}])"},{"desc":"cancel current delayed shutdown","prefix":"minetest.cancel_shutdown_requests","body":"minetest.cancel_shutdown_requests()"},{"desc":"    * Returns the server status string when a player joins or when the command\n      `/status` is called. Returns `nil` or an empty string when the message is\n      disabled.\n    * `joined`: Boolean value, indicates whether the function was called when\n      a player joined.\n    * This function may be overwritten by mods to customize the status message.","prefix":"minetest.get_server_status","body":"minetest.get_server_status(${1:name}, ${2:joined})"},{"desc":"returns the server uptime in seconds","prefix":"minetest.get_server_uptime","body":"minetest.get_server_uptime()"},{"desc":"remove player from database (if they are not\n  connected).\n    * As auth data is not removed, minetest.player_exists will continue to\n      return true. Call the below method as well if you want to remove auth\n      data too.\n    * Returns a code (0: successful, 1: no such player, 2: player is connected)","prefix":"minetest.remove_player","body":"minetest.remove_player(${1:name})"},{"desc":"remove player authentication data\n    * Returns boolean indicating success (false if player nonexistant)\n\nBans\n----\n","prefix":"minetest.remove_player_auth","body":"minetest.remove_player_auth(${1:name})"},{"desc":"returns the ban list\n  (same as `minetest.get_ban_description(\"\")`).","prefix":"minetest.get_ban_list","body":"minetest.get_ban_list()"},{"desc":"returns ban description (string)","prefix":"minetest.get_ban_description","body":"minetest.get_ban_description(${1:ip}_${2:or}_${3:name})"},{"desc":"ban a player","prefix":"minetest.ban_player","body":"minetest.ban_player(${1:name})"},{"desc":"unban player or IP address","prefix":"minetest.unban_player_or_ip","body":"minetest.unban_player_or_ip(${1:name})"},{"desc":"disconnect a player with a optional\n  reason.\n\nParticles\n---------\n","prefix":"minetest.kick_player","body":"minetest.kick_player(${1:name}, ${2:}[${3:reason}])"},{"desc":"    * Deprecated: `minetest.add_particle(pos, velocity, acceleration,\n      expirationtime, size, collisiondetection, texture, playername)`\n","prefix":"minetest.add_particle","body":"minetest.add_particle(${1:particle definition})"},{"desc":"    * Add a `ParticleSpawner`, an object that spawns an amount of particles\n      over `time` seconds.\n    * Returns an `id`, and -1 if adding didn't succeed\n    * Deprecated: `minetest.add_particlespawner(amount, time,\n      minpos, maxpos,\n      minvel, maxvel,\n      minacc, maxacc,\n      minexptime, maxexptime,\n      minsize, maxsize,\n      collisiondetection, texture, playername)`\n","prefix":"minetest.add_particlespawner","body":"minetest.add_particlespawner(${1:particlespawner definition})"},{"desc":"    * Delete `ParticleSpawner` with `id` (return value from\n      `minetest.add_particlespawner`).\n    * If playername is specified, only deletes on the player's client,\n      otherwise on all clients.\n\nSchematics\n----------\n","prefix":"minetest.delete_particlespawner","body":"minetest.delete_particlespawner(${1:id}, ${2:player})"},{"desc":"    * Create a schematic from the volume of map specified by the box formed by\n      p1 and p2.\n    * Apply the specified probability and per-node force-place to the specified\n      nodes according to the `probability_list`.\n        * `probability_list` is an array of tables containing two fields, `pos`\n          and `prob`.\n            * `pos` is the 3D vector specifying the absolute coordinates of the\n              node being modified,\n            * `prob` is an integer value from `0` to `255` that encodes\n              probability and per-node force-place. Probability has levels\n              0-127, then 128 may be added to encode per-node force-place.\n              For probability stated as 0-255, divide by 2 and round down to\n              get values 0-127, then add 128 to apply per-node force-place.\n            * If there are two or more entries with the same pos value, the\n              last entry is used.\n            * If `pos` is not inside the box formed by `p1` and `p2`, it is\n              ignored.\n            * If `probability_list` equals `nil`, no probabilities are applied.\n    * Apply the specified probability to the specified horizontal slices\n      according to the `slice_prob_list`.\n        * `slice_prob_list` is an array of tables containing two fields, `ypos`\n          and `prob`.\n            * `ypos` indicates the y position of the slice with a probability\n              applied, the lowest slice being `ypos = 0`.\n            * If slice probability list equals `nil`, no slice probabilities\n              are applied.\n    * Saves schematic in the Minetest Schematic format to filename.\n","prefix":"minetest.create_schematic","body":"minetest.create_schematic(${1:p1}, ${2:p2}, ${3:probability}_${4:list}, ${5:filename}, ${6:slice}_${7:prob}_${8:list})"},{"desc":"    * Place the schematic specified by schematic (see [Schematic specifier]) at\n      `pos`.\n    * `rotation` can equal `\"0\"`, `\"90\"`, `\"180\"`, `\"270\"`, or `\"random\"`.\n    * If the `rotation` parameter is omitted, the schematic is not rotated.\n    * `replacements` = `{[\"old_name\"] = \"convert_to\", ...}`\n    * `force_placement` is a boolean indicating whether nodes other than `air`\n      and `ignore` are replaced by the schematic.\n    * Returns nil if the schematic could not be loaded.\n    * **Warning**: Once you have loaded a schematic from a file, it will be\n      cached. Future calls will always use the cached version and the\n      replacement list defined for it, regardless of whether the file or the\n      replacement list parameter have changed. The only way to load the file\n      anew is to restart the server.\n    * `flags` is a flag field with the available flags:\n        * place_center_x\n        * place_center_y\n        * place_center_z\n","prefix":"minetest.place_schematic","body":"minetest.place_schematic(${1:pos}, ${2:schematic}, ${3:rotation}, ${4:replacements}, ${5:force}_${6:placement}, ${7:flags})"},{"desc":"    * This function is analogous to minetest.place_schematic, but places a\n      schematic onto the specified VoxelManip object `vmanip` instead of the\n      map.\n    * Returns false if any part of the schematic was cut-off due to the\n      VoxelManip not containing the full area required, and true if the whole\n      schematic was able to fit.\n    * Returns nil if the schematic could not be loaded.\n    * After execution, any external copies of the VoxelManip contents are\n      invalidated.\n    * `flags` is a flag field with the available flags:\n        * place_center_x\n        * place_center_y\n        * place_center_z\n","prefix":"minetest.place_schematic_on_vmanip","body":"minetest.place_schematic_on_vmanip(${1:vmanip}, ${2:pos}, ${3:schematic}, ${4:rotation}, ${5:replacement}, ${6:force}_${7:placement}, ${8:flags})"},{"desc":"    * Return the serialized schematic specified by schematic\n      (see [Schematic specifier])\n    * in the `format` of either \"mts\" or \"lua\".\n    * \"mts\" - a string containing the binary MTS data used in the MTS file\n      format.\n    * \"lua\" - a string containing Lua code representing the schematic in table\n      format.\n    * `options` is a table containing the following optional parameters:\n        * If `lua_use_comments` is true and `format` is \"lua\", the Lua code\n          generated will have (X, Z) position comments for every X row\n          generated in the schematic data for easier reading.\n        * If `lua_num_indent_spaces` is a nonzero number and `format` is \"lua\",\n          the Lua code generated will use that number of spaces as indentation\n          instead of a tab character.\n","prefix":"minetest.serialize_schematic","body":"minetest.serialize_schematic(${1:schematic}, ${2:format}, ${3:options})"},{"desc":"    * Returns a Lua table representing the schematic (see: [Schematic specifier])\n    * `schematic` is the schematic to read (see: [Schematic specifier])\n    * `options` is a table containing the following optional parameters:\n        * `write_yslice_prob`: string value:\n            * `none`: no `write_yslice_prob` table is inserted,\n            * `low`: only probabilities that are not 254 or 255 are written in\n              the `write_ylisce_prob` table,\n            * `all`: write all probabilities to the `write_yslice_prob` table.\n            * The default for this option is `all`.\n            * Any invalid value will be interpreted as `all`.\n\nHTTP Requests\n-------------\n","prefix":"minetest.read_schematic","body":"minetest.read_schematic(${1:schematic}, ${2:options})"},{"desc":"    * returns `HTTPApiTable` containing http functions if the calling mod has\n      been granted access by being listed in the `secure.http_mods` or\n      `secure.trusted_mods` setting, otherwise returns `nil`.\n    * The returned table contains the functions `fetch`, `fetch_async` and\n      `fetch_async_get` described below.\n    * Only works at init time and must be called from the mod's main scope\n      (not from a function).\n    * Function only exists if minetest server was built with cURL support.\n    * **DO NOT ALLOW ANY OTHER MODS TO ACCESS THE RETURNED TABLE, STORE IT IN\n      A LOCAL VARIABLE!**","prefix":"minetest.request_http_api","body":"minetest.request_http_api()"},{"desc":"    * Performs given request asynchronously and calls callback upon completion\n    * callback: `function(HTTPRequestResult res)`\n    * Use this HTTP function if you are unsure, the others are for advanced use","prefix":"HTTPApiTable.fetch","body":"HTTPApiTable.fetch(${1:HTTPRequest req}, ${2:callback})"},{"desc":"returns handle\n    * Performs given request asynchronously and returns handle for\n      `HTTPApiTable.fetch_async_get`","prefix":"HTTPApiTable.fetch_async","body":"HTTPApiTable.fetch_async(${1:HTTPRequest req})"},{"desc":"returns HTTPRequestResult\n    * Return response data for given asynchronous HTTP request\n\nStorage API\n-----------\n","prefix":"HTTPApiTable.fetch_async_get","body":"HTTPApiTable.fetch_async_get(${1:handle})"},{"desc":"    * returns reference to mod private `StorageRef`\n    * must be called during mod load time\n\nMisc.\n-----\n","prefix":"minetest.get_mod_storage","body":"minetest.get_mod_storage()"},{"desc":"returns list of `ObjectRefs`","prefix":"minetest.get_connected_players","body":"minetest.get_connected_players()"},{"desc":"boolean, whether `obj` is a player","prefix":"minetest.is_player","body":"minetest.is_player(${1:obj})"},{"desc":"boolean, whether player exists\n  (regardless of online status)","prefix":"minetest.player_exists","body":"minetest.player_exists(${1:name})"},{"desc":"    * Replaces definition of a builtin hud element\n    * `name`: `\"breath\"` or `\"health\"`\n    * `hud_definition`: definition to replace builtin definition","prefix":"minetest.hud_replace_builtin","body":"minetest.hud_replace_builtin(${1:name}, ${2:hud}_${3:definition})"},{"desc":"    * This function can be overridden by mods to change the join message.","prefix":"minetest.send_join_message","body":"minetest.send_join_message(${1:player}_${2:name})"},{"desc":"    * This function can be overridden by mods to change the leave message.","prefix":"minetest.send_leave_message","body":"minetest.send_leave_message(${1:player}_${2:name}, ${3:timed}_${4:out})"},{"desc":"returns an 48-bit integer\n    * `pos`: table {x=number, y=number, z=number},\n    * Gives a unique hash number for a node position (16+16+16=48bit)","prefix":"minetest.hash_node_position","body":"minetest.hash_node_position(${1:pos})"},{"desc":"returns a position\n    * Inverse transform of `minetest.hash_node_position`","prefix":"minetest.get_position_from_hash","body":"minetest.get_position_from_hash(${1:hash})"},{"desc":"returns a rating\n    * Get rating of a group of an item. (`0` means: not in group)","prefix":"minetest.get_item_group","body":"minetest.get_item_group(${1:name}, ${2:group})"},{"desc":"returns a rating\n    * Deprecated: An alias for the former.","prefix":"minetest.get_node_group","body":"minetest.get_node_group(${1:name}, ${2:group})"},{"desc":"returns a rating\n    * Returns rating of the connect_to_raillike group corresponding to name\n    * If name is not yet the name of a connect_to_raillike group, a new group\n      id is created, with that name.","prefix":"minetest.raillike_group","body":"minetest.raillike_group(${1:name})"},{"desc":"returns an integer\n    * Gets the internal content ID of `name`","prefix":"minetest.get_content_id","body":"minetest.get_content_id(${1:name})"},{"desc":"returns a string\n    * Gets the name of the content with that content ID","prefix":"minetest.get_name_from_content_id","body":"minetest.get_name_from_content_id(${1:content}_${2:id})"},{"desc":"returns something\n    * Convert a string containing JSON data into the Lua equivalent\n    * `nullvalue`: returned in place of the JSON null; defaults to `nil`\n    * On success returns a table, a string, a number, a boolean or `nullvalue`\n    * On failure outputs an error message and returns `nil`\n    * Example: `parse_json(\"[10, {\\\"a\\\":false}]\")`, returns `{10, {a = false}}`","prefix":"minetest.parse_json","body":"minetest.parse_json(${1:string}[, ${2:nullvalue}])"},{"desc":"returns a string or `nil` and an error\n  message.\n    * Convert a Lua table into a JSON string\n    * styled: Outputs in a human-readable format if this is set, defaults to\n      false.\n    * Unserializable things like functions and userdata will cause an error.\n    * **Warning**: JSON is more strict than the Lua table format.\n        1. You can only use strings and positive integers of at least one as\n           keys.\n        2. You can not mix string and integer keys.\n           This is due to the fact that JSON has two distinct array and object\n           values.\n    * Example: `write_json({10, {a = false}})`,\n      returns `\"[10, {\\\"a\\\": false}]\"`","prefix":"minetest.write_json","body":"minetest.write_json(${1:data}[, ${2:styled}])"},{"desc":"returns a string\n    * Convert a table containing tables, strings, numbers, booleans and `nil`s\n      into string form readable by `minetest.deserialize`\n    * Example: `serialize({foo='bar'})`, returns `'return { [\"foo\"] = \"bar\" }'`","prefix":"minetest.serialize","body":"minetest.serialize(${1:table})"},{"desc":"returns a table\n    * Convert a string returned by `minetest.deserialize` into a table\n    * `string` is loaded in an empty sandbox environment.\n    * Will load functions, but they cannot access the global environment.\n    * Example: `deserialize('return { [\"foo\"] = \"bar\" }')`,\n      returns `{foo='bar'}`\n    * Example: `deserialize('print(\"foo\")')`, returns `nil`\n      (function call fails), returns\n      `error:[string \"print(\"foo\")\"]:1: attempt to call global 'print' (a nil value)`","prefix":"minetest.deserialize","body":"minetest.deserialize(${1:string})"},{"desc":"returns `compressed_data`\n    * Compress a string of data.\n    * `method` is a string identifying the compression method to be used.\n    * Supported compression methods:\n        * Deflate (zlib): `\"deflate\"`\n    * `...` indicates method-specific arguments. Currently defined arguments\n      are:\n        * Deflate: `level` - Compression level, `0`-`9` or `nil`.","prefix":"minetest.compress","body":"minetest.compress(${1:data}, ${2:method}, ${3:}...)"},{"desc":"returns data\n    * Decompress a string of data (using ZLib).\n    * See documentation on `minetest.compress()` for supported compression\n      methods.\n    * `...` indicates method-specific arguments. Currently, no methods use this","prefix":"minetest.decompress","body":"minetest.decompress(${1:compressed}_${2:data}, ${3:method}, ${4:}...)"},{"desc":"returns a string\n    * Each argument is a 8 Bit unsigned integer\n    * Returns the ColorString from rgb or rgba values\n    * Example: `minetest.rgba(10, 20, 30, 40)`, returns `\"#0A141E28\"`","prefix":"minetest.rgba","body":"minetest.rgba(${1:red}, ${2:green}, ${3:blue}[, ${4:alpha}])"},{"desc":"returns string encoded in base64\n    * Encodes a string in base64.","prefix":"minetest.encode_base64","body":"minetest.encode_base64(${1:string})"},{"desc":"returns string\n    * Decodes a string encoded in base64.","prefix":"minetest.decode_base64","body":"minetest.decode_base64(${1:string})"},{"desc":"returns boolean\n    * Returning `true` restricts the player `name` from modifying (i.e. digging,\n       placing) the node at position `pos`.\n    * `name` will be `\"\"` for non-players or unknown players.\n    * This function should be overridden by protection mods. It is highly\n      recommended to grant access to players with the `protection_bypass` privilege.\n    * Cache and call the old version of this function if the position is\n      not protected by the mod. This will allow using multiple protection mods.\n    * Example:\n\n          local old_is_protected = minetest.is_protected\n          function minetest.is_protected(pos, name)\n              if mymod:position_protected_from(pos, name) then\n                  return true\n              end\n              return old_is_protected(pos, name)\n          end","prefix":"minetest.is_protected","body":"minetest.is_protected(${1:pos}, ${2:name})"},{"desc":"    * This function calls functions registered with\n      `minetest.register_on_protection_violation`.","prefix":"minetest.record_protection_violation","body":"minetest.record_protection_violation(${1:pos}, ${2:name})"},{"desc":"    * Returns the position of the first node that `player_name` may not modify\n      in the specified cuboid between `pos1` and `pos2`.\n    * Returns `false` if no protections were found.\n    * Applies `is_protected()` to a 3D lattice of points in the defined volume.\n      The points are spaced evenly throughout the volume and have a spacing\n      similar to, but no larger than, `interval`.\n    * All corners and edges of the defined volume are checked.\n    * `interval` defaults to 4.\n    * `interval` should be carefully chosen and maximised to avoid an excessive\n      number of points being checked.\n    * Like `minetest.is_protected`, this function may be extended or\n      overwritten by mods to provide a faster implementation to check the\n      cuboid for intersections.\n* `minetest.rotate_and_place(itemstack, placer, pointed_thing[, infinitestacks,\n  orient_flags, prevent_after_place])`\n    * Attempt to predict the desired orientation of the facedir-capable node\n      defined by `itemstack`, and place it accordingly (on-wall, on the floor,\n      or hanging from the ceiling).\n    * `infinitestacks`: if `true`, the itemstack is not changed. Otherwise the\n      stacks are handled normally.\n    * `orient_flags`: Optional table containing extra tweaks to the placement code:\n        * `invert_wall`:   if `true`, place wall-orientation on the ground and\n          ground-orientation on the wall.\n        * `force_wall` :   if `true`, always place the node in wall orientation.\n        * `force_ceiling`: if `true`, always place on the ceiling.\n        * `force_floor`:   if `true`, always place the node on the floor.\n        * `force_facedir`: if `true`, forcefully reset the facedir to north\n          when placing on the floor or ceiling.\n        * The first four options are mutually-exclusive; the last in the list\n          takes precedence over the first.\n    * `prevent_after_place` is directly passed to `minetest.item_place_node`\n    * Returns the new itemstack after placement","prefix":"minetest.is_area_protected","body":"minetest.is_area_protected(${1:pos1}, ${2:pos2}, ${3:player}_${4:name}, ${5:interval})"},{"desc":"    * calls `rotate_and_place()` with `infinitestacks` set according to the state\n      of the creative mode setting, checks for \"sneak\" to set the `invert_wall`\n      parameter and `prevent_after_place` set to `true`.\n\n* `minetest.calculate_knockback(player, hitter, time_from_last_punch,\n  tool_capabilities, dir, distance, damage)`\n    * Returns the amount of knockback applied on the punched player.\n    * Arguments are equivalent to `register_on_punchplayer`, except the following:\n        * `distance`: distance between puncher and punched player\n    * This function can be overriden by mods that wish to modify this behaviour.\n    * You may want to cache and call the old function to allow multiple mods to\n      change knockback behaviour.\n","prefix":"minetest.rotate_node","body":"minetest.rotate_node(${1:itemstack}, ${2:placer}, ${3:pointed}_${4:thing})"},{"desc":"    * forceloads the position `pos`.\n    * returns `true` if area could be forceloaded\n    * If `transient` is `false` or absent, the forceload will be persistent\n      (saved between server runs). If `true`, the forceload will be transient\n      (not saved between server runs).\n","prefix":"minetest.forceload_block","body":"minetest.forceload_block(${1:pos}[, ${2:transient}])"},{"desc":"    * stops forceloading the position `pos`\n    * If `transient` is `false` or absent, frees a persistent forceload.\n      If `true`, frees a transient forceload.\n","prefix":"minetest.forceload_free_block","body":"minetest.forceload_free_block(${1:pos}[, ${2:transient}])"},{"desc":"returns an environment containing\n  insecure functions if the calling mod has been listed as trusted in the\n  `secure.trusted_mods` setting or security is disabled, otherwise returns\n  `nil`.\n    * Only works at init time and must be called from the mod's main scope (not\n      from a function).\n    * **DO NOT ALLOW ANY OTHER MODS TO ACCESS THE RETURNED ENVIRONMENT, STORE\n      IT IN A LOCAL VARIABLE!**\n","prefix":"minetest.request_insecure_environment","body":"minetest.request_insecure_environment()"},{"desc":"    * Checks if a global variable has been set, without triggering a warning.\n\nGlobal objects\n--------------\n\n* `minetest.env`: `EnvRef` of the server environment and world.\n    * Any function in the minetest namespace can be called using the syntax\n      `minetest.env:somefunction(somearguments)`\n      instead of `minetest.somefunction(somearguments)`\n    * Deprecated, but support is not to be dropped soon\n\nGlobal tables\n-------------\n\n### Registered definition tables\n\n* `minetest.registered_items`\n    * Map of registered items, indexed by name\n* `minetest.registered_nodes`\n    * Map of registered node definitions, indexed by name\n* `minetest.registered_craftitems`\n    * Map of registered craft item definitions, indexed by name\n* `minetest.registered_tools`\n    * Map of registered tool definitions, indexed by name\n* `minetest.registered_entities`\n    * Map of registered entity prototypes, indexed by name\n* `minetest.object_refs`\n    * Map of object references, indexed by active object id\n* `minetest.luaentities`\n    * Map of Lua entities, indexed by active object id\n* `minetest.registered_abms`\n    * List of ABM definitions\n* `minetest.registered_lbms`\n    * List of LBM definitions\n* `minetest.registered_aliases`\n    * Map of registered aliases, indexed by name\n* `minetest.registered_ores`\n    * Map of registered ore definitions, indexed by the `name` field.\n    * If `name` is nil, the key is the object handle returned by\n      `minetest.register_ore`.\n* `minetest.registered_biomes`\n    * Map of registered biome definitions, indexed by the `name` field.\n    * If `name` is nil, the key is the object handle returned by\n      `minetest.register_biome`.\n* `minetest.registered_decorations`\n    * Map of registered decoration definitions, indexed by the `name` field.\n    * If `name` is nil, the key is the object handle returned by\n      `minetest.register_decoration`.\n* `minetest.registered_schematics`\n    * Map of registered schematic definitions, indexed by the `name` field.\n    * If `name` is nil, the key is the object handle returned by\n      `minetest.register_schematic`.\n* `minetest.registered_chatcommands`\n    * Map of registered chat command definitions, indexed by name\n* `minetest.registered_privileges`\n    * Map of registered privilege definitions, indexed by name\n\n### Registered callback tables\n\nAll callbacks registered with [Global callback registration functions] are added\nto corresponding `minetest.registered_*` tables.\n\n\n\n\nClass reference\n===============\n\nSorted alphabetically.\n\n`AreaStore`\n-----------\n\nA fast access data structure to store areas, and find areas near a given\nposition or area.\nEvery area has a `data` string attribute to store additional information.\nYou can create an empty `AreaStore` by calling `AreaStore()`, or\n`AreaStore(type_name)`. The mod decides where to save and load AreaStore.\nIf you chose the parameter-less constructor, a fast implementation will be\nautomatically chosen for you.\n\n### Methods\n","prefix":"minetest.global_exists","body":"minetest.global_exists(${1:name})"},{"desc":"    * Returns the area information about the specified ID.\n    * Returned values are either of these:\n\n            nil  -- Area not found\n            true -- Without `include_borders` and `include_data`\n            {\n                min = pos, max = pos -- `include_borders == true`\n                data = string        -- `include_data == true`\n            }\n","prefix":"get_area","body":"get_area(${1:id}, ${2:include}_${3:borders}, ${4:include}_${5:data})"},{"desc":"    * Returns all areas as table, indexed by the area ID.\n    * Table values: see `get_area`.","prefix":"get_areas_for_pos","body":"get_areas_for_pos(${1:pos}, ${2:include}_${3:borders}, ${4:include}_${5:data})"},{"desc":"    * Returns all areas that contain all nodes inside the area specified by `edge1`\n      and `edge2` (inclusive).\n    * `accept_overlap`: if `true`, areas are returned that have nodes in\n      common (intersect) with the specified area.\n    * Returns the same values as `get_areas_for_pos`.","prefix":"get_areas_in_area","body":"get_areas_in_area(${1:edge1}, ${2:edge2}, ${3:accept}_${4:overlap}, ${5:include}_${6:borders}, ${7:include}_${8:data})"},{"desc":"inserts an area into the store.\n    * Returns the new area's ID, or nil if the insertion failed.\n    * The (inclusive) positions `edge1` and `edge2` describe the area.\n    * `data` is a string stored with the area.\n    * `id` (optional): will be used as the internal area ID if it is an unique\n      number between 0 and 2^32-2.","prefix":"insert_area","body":"insert_area(${1:edge1}, ${2:edge2}, ${3:data}, ${4:}[${5:id}])"},{"desc":"reserves resources for at most `count` many contained\n  areas.\n  Only needed for efficiency, and only some implementations profit.","prefix":"reserve","body":"reserve(${1:count})"},{"desc":"removes the area with the given id from the store, returns\n  success.","prefix":"remove_area","body":"remove_area(${1:id})"},{"desc":"sets params for the included prefiltering cache.\n  Calling invalidates the cache, so that its elements have to be newly\n  generated.\n    * `params` is a table with the following fields:\n\n          enabled = boolean,   -- Whether to enable, default true\n          block_radius = int,  -- The radius (in nodes) of the areas the cache\n                               -- generates prefiltered lists for, minimum 16,\n                               -- default 64\n          limit = int,         -- The cache size, minimum 20, default 1000","prefix":"set_cache_params","body":"set_cache_params(${1:params})"},{"desc":"Experimental. Returns area store serialized as a (binary)\n  string.","prefix":"to_string","body":"to_string()"},{"desc":"Experimental. Like `to_string()`, but writes the data to\n  a file.","prefix":"to_file","body":"to_file(${1:filename})"},{"desc":"Experimental. Deserializes string and loads it into the\n  AreaStore.\n  Returns success and, optionally, an error message.","prefix":"from_string","body":"from_string(${1:str})"},{"desc":"Experimental. Like `from_string()`, but reads the data\n  from a file.\n\n`InvRef`\n--------\n\nAn `InvRef` is a reference to an inventory.\n\n### Methods\n","prefix":"from_file","body":"from_file(${1:filename})"},{"desc":"return `true` if list is empty","prefix":"is_empty","body":"is_empty(${1:listname})"},{"desc":"get size of a list","prefix":"get_size","body":"get_size(${1:listname})"},{"desc":"set size of a list\n    * returns `false` on error (e.g. invalid `listname` or `size`)","prefix":"set_size","body":"set_size(${1:listname}, ${2:size})"},{"desc":"get width of a list","prefix":"get_width","body":"get_width(${1:listname})"},{"desc":"set width of list; currently used for crafting","prefix":"set_width","body":"set_width(${1:listname}, ${2:width})"},{"desc":"get a copy of stack index `i` in list","prefix":"get_stack","body":"get_stack(${1:listname}, ${2:i})"},{"desc":"copy `stack` to index `i` in list","prefix":"set_stack","body":"set_stack(${1:listname}, ${2:i}, ${3:stack})"},{"desc":"return full list","prefix":"get_list","body":"get_list(${1:listname})"},{"desc":"set full list (size will not change)","prefix":"set_list","body":"set_list(${1:listname}, ${2:list})"},{"desc":"returns list of inventory lists","prefix":"get_lists","body":"get_lists()"},{"desc":"sets inventory lists (size will not change)","prefix":"set_lists","body":"set_lists(${1:lists})"},{"desc":"add item somewhere in list, returns leftover\n  `ItemStack`.\n* `room_for_item(listname, stack):` returns `true` if the stack of items\n  can be fully added to the list","prefix":"add_item","body":"add_item(${1:listname}, ${2:stack})"},{"desc":"returns `true` if\n  the stack of items can be fully taken from the list.\n  If `match_meta` is false, only the items' names are compared\n  (default: `false`).","prefix":"contains_item","body":"contains_item(${1:listname}, ${2:stack}, ${3:}[${4:match}_${5:meta}])"},{"desc":"take as many items as specified from the\n  list, returns the items that were actually removed (as an `ItemStack`)\n  -- note that any item metadata is ignored, so attempting to remove a specific\n  unique item this way will likely remove the wrong one -- to do that use\n  `set_stack` with an empty `ItemStack`.","prefix":"remove_item","body":"remove_item(${1:listname}, ${2:stack})"},{"desc":"returns a location compatible to\n  `minetest.get_inventory(location)`.\n    * returns `{type=\"undefined\"}` in case location is not known\n\n`ItemStack`\n-----------\n\nAn `ItemStack` is a stack of items.\n\nIt can be created via `ItemStack(x)`, where x is an `ItemStack`,\nan itemstring, a table or `nil`.\n\n### Methods\n","prefix":"get_location","body":"get_location()"},{"desc":"returns `true` if stack is empty.","prefix":"is_empty","body":"is_empty()"},{"desc":"returns item name (e.g. `\\\"default:stone\\\"`).","prefix":"get_name","body":"get_name()"},{"desc":"returns a boolean indicating whether the item was\n  cleared.","prefix":"set_name","body":"set_name(${1:item}_${2:name})"},{"desc":"Returns number of items on the stack.","prefix":"get_count","body":"get_count()"},{"desc":"returns a boolean indicating whether the item was cleared\n    * `count`: number, unsigned 16 bit integer","prefix":"set_count","body":"set_count(${1:count})"},{"desc":"returns tool wear (`0`-`65535`), `0` for non-tools.","prefix":"get_wear","body":"get_wear()"},{"desc":"returns boolean indicating whether item was cleared\n    * `wear`: number, unsigned 16 bit integer","prefix":"set_wear","body":"set_wear(${1:wear})"},{"desc":"returns ItemStackMetaRef. See section for more details","prefix":"get_meta","body":"get_meta()"},{"desc":"(DEPRECATED) Returns metadata (a string attached to an item\n  stack).","prefix":"get_metadata","body":"get_metadata()"},{"desc":"(DEPRECATED) Returns true.","prefix":"set_metadata","body":"set_metadata(${1:metadata})"},{"desc":"returns the description shown in inventory list tooltips.","prefix":"get_description","body":"get_description()"},{"desc":"removes all items from the stack, making it empty.","prefix":"clear","body":"clear()"},{"desc":"replace the contents of this stack.\n    * `item` can also be an itemstring or table.","prefix":"replace","body":"replace(${1:item})"},{"desc":"returns the stack in itemstring form.","prefix":"to_string","body":"to_string()"},{"desc":"returns the stack in Lua table form.","prefix":"to_table","body":"to_table()"},{"desc":"returns the maximum size of the stack (depends on the\n  item).","prefix":"get_stack_max","body":"get_stack_max()"},{"desc":"returns `get_stack_max() - get_count()`.","prefix":"get_free_space","body":"get_free_space()"},{"desc":"returns `true` if the item name refers to a defined item type.","prefix":"is_known","body":"is_known()"},{"desc":"returns the item definition table.","prefix":"get_definition","body":"get_definition()"},{"desc":"returns the digging properties of the item,\n  or those of the hand if none are defined for this item type","prefix":"get_tool_capabilities","body":"get_tool_capabilities()"},{"desc":"    * Increases wear by `amount` if the item is a tool\n    * `amount`: number, integer","prefix":"add_wear","body":"add_wear(${1:amount})"},{"desc":"returns leftover `ItemStack`\n    * Put some item or stack onto this stack","prefix":"add_item","body":"add_item(${1:item})"},{"desc":"returns `true` if item or stack can be fully added to\n  this one.","prefix":"item_fits","body":"item_fits(${1:item})"},{"desc":"returns taken `ItemStack`\n    * Take (and remove) up to `n` items from this stack\n    * `n`: number, default: `1`","prefix":"take_item","body":"take_item(${1:n})"},{"desc":"returns taken `ItemStack`\n    * Copy (don't remove) up to `n` items from this stack\n    * `n`: number, default: `1`\n\n`ItemStackMetaRef`\n------------------\n\nItemStack metadata: reference extra data and functionality stored in a stack.\nCan be obtained via `item:get_meta()`.\n\n### Methods\n\n* All methods in MetaDataRef","prefix":"peek_item","body":"peek_item(${1:n})"},{"desc":"    * Overrides the item's tool capabilities\n    * A nil value will clear the override data and restore the original\n      behavior.\n\n`MetaDataRef`\n-------------\n\nBase class used by [`StorageRef`], [`NodeMetaRef`], [`ItemStackMetaRef`],\nand [`PlayerMetaRef`].\n\n### Methods\n","prefix":"set_tool_capabilities","body":"set_tool_capabilities([${1:tool}_${2:capabilities}])"},{"desc":"Returns true if key present, otherwise false.\n    * Returns `nil` when the MetaData is inexistent.","prefix":"contains","body":"contains(${1:key})"},{"desc":"Returns `nil` if key not present, else the stored string.","prefix":"get","body":"get(${1:key})"},{"desc":"Value of `\\\"\\\"` will delete the key.","prefix":"set_string","body":"set_string(${1:key}, ${2:value})"},{"desc":"Returns `\\\"\\\"` if key not present.","prefix":"get_string","body":"get_string(${1:key})"},{"desc":"","prefix":"set_int","body":"set_int(${1:key}, ${2:value})"},{"desc":"Returns `0` if key not present.","prefix":"get_int","body":"get_int(${1:key})"},{"desc":"","prefix":"set_float","body":"set_float(${1:key}, ${2:value})"},{"desc":"Returns `0` if key not present.","prefix":"get_float","body":"get_float(${1:key})"},{"desc":"returns `nil` or a table with keys:\n    * `fields`: key-value storage\n    * `inventory`: `{list1 = {}, ...}}` (NodeMetaRef only)","prefix":"to_table","body":"to_table()"},{"desc":"    * Any non-table value will clear the metadata\n    * See [Node Metadata] for an example\n    * returns `true` on success","prefix":"from_table","body":"from_table(${1:nil or }{})"},{"desc":"    * returns `true` if this metadata has the same key-value pairs as `other`\n\n`ModChannel`\n------------\n\nAn interface to use mod channels on client and server\n\n### Methods\n","prefix":"equals","body":"equals(${1:other})"},{"desc":"leave the mod channel.\n    * Server leaves channel `channel_name`.\n    * No more incoming or outgoing messages can be sent to this channel from\n      server mods.\n    * This invalidate all future object usage.\n    * Ensure you set mod_channel to nil after that to free Lua resources.","prefix":"leave","body":"leave()"},{"desc":"returns true if channel is writeable and mod can send over\n  it.","prefix":"is_writeable","body":"is_writeable()"},{"desc":"Send `message` though the mod channel.\n    * If mod channel is not writeable or invalid, message will be dropped.\n    * Message size is limited to 65535 characters by protocol.\n\n`NodeMetaRef`\n-------------\n\nNode metadata: reference extra data and functionality stored in a node.\nCan be obtained via `minetest.get_meta(pos)`.\n\n### Methods\n\n* All methods in MetaDataRef","prefix":"send_all","body":"send_all(${1:message})"},{"desc":"returns `InvRef`","prefix":"get_inventory","body":"get_inventory()"},{"desc":"Mark specific vars as private\n  This will prevent them from being sent to the client. Note that the \"private\"\n  status will only be remembered if an associated key-value pair exists,\n  meaning it's best to call this when initializing all other meta (e.g.\n  `on_construct`).\n\n`NodeTimerRef`\n--------------\n\nNode Timers: a high resolution persistent per-node timer.\nCan be gotten via `minetest.get_node_timer(pos)`.\n\n### Methods\n","prefix":"mark_as_private","body":"mark_as_private(${1:name or }{${2:name1}, ${3:name2}, ${4:}...})"},{"desc":"    * set a timer's state\n    * `timeout` is in seconds, and supports fractional values (0.1 etc)\n    * `elapsed` is in seconds, and supports fractional values (0.1 etc)\n    * will trigger the node's `on_timer` function after `(timeout - elapsed)`\n      seconds.","prefix":"set","body":"set(${1:timeout}, ${2:elapsed})"},{"desc":"    * start a timer\n    * equivalent to `set(timeout,0)`","prefix":"start","body":"start(${1:timeout})"},{"desc":"    * stops the timer","prefix":"stop","body":"stop()"},{"desc":"returns current timeout in seconds\n    * if `timeout` equals `0`, timer is inactive","prefix":"get_timeout","body":"get_timeout()"},{"desc":"returns current elapsed time in seconds\n    * the node's `on_timer` function will be called after `(timeout - elapsed)`\n      seconds.","prefix":"get_elapsed","body":"get_elapsed()"},{"desc":"returns boolean state of timer\n    * returns `true` if timer is started, otherwise `false`\n\n`ObjectRef`\n-----------\n\nMoving things in the game are generally these.\n\nThis is basically a reference to a C++ `ServerActiveObject`\n\n### Methods\n","prefix":"is_started","body":"is_started()"},{"desc":"returns `{x=num, y=num, z=num}`","prefix":"get_pos","body":"get_pos()"},{"desc":"`pos`=`{x=num, y=num, z=num}`","prefix":"set_pos","body":"set_pos(${1:pos})"},{"desc":"    * Does an interpolated move for Lua entities for visually smooth transitions.\n    * If `continuous` is true, the Lua entity will not be moved to the current\n      position before starting the interpolated move.\n    * For players this does the same as `set_pos`,`continuous` is ignored.","prefix":"move_to","body":"move_to(${1:pos}, ${2:continuous}=${3:false})"},{"desc":"    * `puncher` = another `ObjectRef`,\n    * `time_from_last_punch` = time since last punch action of the puncher\n    * `direction`: can be `nil`","prefix":"punch","body":"punch(${1:puncher}, ${2:time}_${3:from}_${4:last}_${5:punch}, ${6:tool}_${7:capabilities}, ${8:direction})"},{"desc":"is another `ObjectRef`","prefix":"right_click","body":"right_click(${1:clicker})"},{"desc":"returns number of hitpoints (2 * number of hearts)","prefix":"get_hp","body":"get_hp()"},{"desc":"set number of hitpoints (2 * number of hearts).\n    * See reason in register_on_player_hpchange","prefix":"set_hp","body":"set_hp(${1:hp}, ${2:reason})"},{"desc":"returns an `InvRef` for players, otherwise returns `nil`","prefix":"get_inventory","body":"get_inventory()"},{"desc":"returns the name of the inventory list the wielded item\n   is in.","prefix":"get_wield_list","body":"get_wield_list()"},{"desc":"returns the index of the wielded item","prefix":"get_wield_index","body":"get_wield_index()"},{"desc":"returns an `ItemStack`","prefix":"get_wielded_item","body":"get_wielded_item()"},{"desc":"replaces the wielded item, returns `true` if\n  successful.","prefix":"set_wielded_item","body":"set_wielded_item(${1:item})"},{"desc":"","prefix":"set_armor_groups","body":"set_armor_groups({${1:group1}=${2:rating}, ${3:group2}=${4:rating}, ${5:}...})"},{"desc":"returns a table with the armor group ratings","prefix":"get_armor_groups","body":"get_armor_groups()"},{"desc":"    * `frame_range`: table {x=num, y=num}, default: `{x=1, y=1}`\n    * `frame_speed`: number, default: `15.0`\n    * `frame_blend`: number, default: `0.0`\n    * `frame_loop`: boolean, default: `true`","prefix":"set_animation","body":"set_animation(${1:frame}_${2:range}, ${3:frame}_${4:speed}, ${5:frame}_${6:blend}, ${7:frame}_${8:loop})"},{"desc":"returns `range`, `frame_speed`, `frame_blend` and\n  `frame_loop`.","prefix":"get_animation","body":"get_animation()"},{"desc":"    * `frame_speed`: number, default: `15.0`","prefix":"set_animation_frame_speed","body":"set_animation_frame_speed(${1:frame}_${2:speed})"},{"desc":"    * `bone`: string\n    * `position`: `{x=num, y=num, z=num}` (relative)\n    * `rotation`: `{x=num, y=num, z=num}` = Rotation on each axis, in degrees","prefix":"set_attach","body":"set_attach(${1:parent}, ${2:bone}, ${3:position}, ${4:rotation})"},{"desc":"returns parent, bone, position, rotation or nil if it isn't\n  attached.","prefix":"get_attach","body":"get_attach()"},{"desc":"","prefix":"set_detach","body":"set_detach()"},{"desc":"    * `bone`: string\n    * `position`: `{x=num, y=num, z=num}` (relative)\n    * `rotation`: `{x=num, y=num, z=num}`","prefix":"set_bone_position","body":"set_bone_position(${1:bone}, ${2:position}, ${3:rotation})"},{"desc":"returns position and rotation of the bone","prefix":"get_bone_position","body":"get_bone_position(${1:bone})"},{"desc":"","prefix":"set_properties","body":"set_properties(${1:object property table})"},{"desc":"returns object property table","prefix":"get_properties","body":"get_properties()"},{"desc":"returns true for players, false otherwise","prefix":"is_player","body":"is_player()"},{"desc":"    * returns a table with the attributes of the nametag of an object\n    * {\n        color = {a=0..255, r=0..255, g=0..255, b=0..255},\n        text = \"\",\n      }","prefix":"get_nametag_attributes","body":"get_nametag_attributes()"},{"desc":"    * sets the attributes of the nametag of an object\n    * `attributes`:\n      {\n        color = ColorSpec,\n        text = \"My Nametag\",\n      }\n\n#### Lua entity only (no-op for other objects)\n","prefix":"set_nametag_attributes","body":"set_nametag_attributes(${1:attributes})"},{"desc":"remove object (after returning from Lua)","prefix":"remove","body":"remove()"},{"desc":"    * `vel` is a vector, e.g. `{x=0.0, y=2.3, z=1.0}`","prefix":"set_velocity","body":"set_velocity(${1:vel})"},{"desc":"    * `vel` is a vector, e.g. `{x=0.0, y=2.3, z=1.0}`\n    * In comparison to using get_velocity, adding the velocity and then using\n      set_velocity, add_velocity is supposed to avoid synchronization problems.","prefix":"add_velocity","body":"add_velocity(${1:vel})"},{"desc":"returns the velocity, a vector","prefix":"get_velocity","body":"get_velocity()"},{"desc":"    * `acc` is a vector","prefix":"set_acceleration","body":"set_acceleration(${1:acc})"},{"desc":"returns the acceleration, a vector","prefix":"get_acceleration","body":"get_acceleration()"},{"desc":"    * `rot` is a vector (radians). X is pitch (elevation), Y is yaw (heading)\n      and Z is roll (bank).","prefix":"set_rotation","body":"set_rotation(${1:rot})"},{"desc":"returns the rotation, a vector (radians)","prefix":"get_rotation","body":"get_rotation()"},{"desc":"sets the yaw (heading).","prefix":"set_yaw","body":"set_yaw(${1:radians})"},{"desc":"returns number in radians","prefix":"get_yaw","body":"get_yaw()"},{"desc":"","prefix":"set_texture_mod","body":"set_texture_mod(${1:mod})"},{"desc":"returns current texture modifier","prefix":"get_texture_mod","body":"get_texture_mod()"},{"desc":"    * Select sprite from spritesheet with optional animation and Dungeon Master\n      style texture selection based on yaw relative to camera\n    * `p`: {x=number, y=number}, the coordinate of the first frame\n      (x: column, y: row), default: `{x=0, y=0}`\n    * `num_frames`: number, default: `1`\n    * `framelength`: number, default: `0.2`\n    * `select_horiz_by_yawpitch`: boolean, this was once used for the Dungeon\n      Master mob, default: `false`","prefix":"set_sprite","body":"set_sprite(${1:p}, ${2:num}_${3:frames}, ${4:framelength}, ${5:select}_${6:horiz}_${7:by}_${8:yawpitch})"},{"desc":"(**Deprecated**: Will be removed in a future version)","prefix":"get_entity_name","body":"get_entity_name()"},{"desc":"#### Player only (no-op for other objects)\n","prefix":"get_luaentity","body":"get_luaentity()"},{"desc":"returns `\\\"\\\"` if is not a player","prefix":"get_player_name","body":"get_player_name()"},{"desc":"returns `nil` if is not a player, otherwise a\n  table {x, y, z} representing the player's instantaneous velocity in nodes/s","prefix":"get_player_velocity","body":"get_player_velocity()"},{"desc":"    * Adds to player velocity, this happens client-side and only once.\n    * Does not apply during free_move.\n    * Note that since the player speed is normalized at each move step,\n      increasing e.g. Y velocity beyond what would usually be achieved\n      (see: physics overrides) will cause existing X/Z velocity to be reduced.\n    * Example: `add_player_velocity({x=0, y=6.5, z=0})` is equivalent to\n      pressing the jump key (assuming default settings)","prefix":"add_player_velocity","body":"add_player_velocity(${1:vel})"},{"desc":"get camera direction as a unit vector","prefix":"get_look_dir","body":"get_look_dir()"},{"desc":"pitch in radians\n    * Angle ranges between -pi/2 and pi/2, which are straight up and down\n      respectively.","prefix":"get_look_vertical","body":"get_look_vertical()"},{"desc":"yaw in radians\n    * Angle is counter-clockwise from the +z direction.","prefix":"get_look_horizontal","body":"get_look_horizontal()"},{"desc":"sets look pitch\n    * radians: Angle from looking forward, where positive is downwards.","prefix":"set_look_vertical","body":"set_look_vertical(${1:radians})"},{"desc":"sets look yaw\n    * radians: Angle from the +z direction, where positive is counter-clockwise.","prefix":"set_look_horizontal","body":"set_look_horizontal(${1:radians})"},{"desc":"pitch in radians - Deprecated as broken. Use\n  `get_look_vertical`.\n    * Angle ranges between -pi/2 and pi/2, which are straight down and up\n      respectively.","prefix":"get_look_pitch","body":"get_look_pitch()"},{"desc":"yaw in radians - Deprecated as broken. Use\n  `get_look_horizontal`.\n    * Angle is counter-clockwise from the +x direction.","prefix":"get_look_yaw","body":"get_look_yaw()"},{"desc":"sets look pitch - Deprecated. Use\n  `set_look_vertical`.","prefix":"set_look_pitch","body":"set_look_pitch(${1:radians})"},{"desc":"sets look yaw - Deprecated. Use\n  `set_look_horizontal`.","prefix":"set_look_yaw","body":"set_look_yaw(${1:radians})"},{"desc":"returns player's breath","prefix":"get_breath","body":"get_breath()"},{"desc":"sets player's breath\n    * values:\n        * `0`: player is drowning\n        * max: bubbles bar is not shown\n        * See [Object properties] for more information","prefix":"set_breath","body":"set_breath(${1:value})"},{"desc":"Sets player's FOV\n    * `fov`: FOV value.\n    * `is_multiplier`: Set to `true` if the FOV value is a multiplier.\n      Defaults to `false`.\n    * Set to 0 to clear FOV override.","prefix":"set_fov","body":"set_fov(${1:fov}, ${2:is}_${3:multiplier})"},{"desc":"    * Returns player's FOV override in degrees, and a boolean depending on whether\n      the value is a multiplier.\n    * Returns 0 as first value if player's FOV hasn't been overridden.","prefix":"get_fov","body":"get_fov()"},{"desc":" DEPRECATED, use get_meta() instead\n    * Sets an extra attribute with value on player.\n    * `value` must be a string, or a number which will be converted to a\n      string.\n    * If `value` is `nil`, remove attribute from player.","prefix":"set_attribute","body":"set_attribute(${1:attribute}, ${2:value})"},{"desc":" DEPRECATED, use get_meta() instead\n    * Returns value (a string) for extra attribute.\n    * Returns `nil` if no attribute found.","prefix":"get_attribute","body":"get_attribute(${1:attribute})"},{"desc":"Returns a PlayerMetaRef.","prefix":"get_meta","body":"get_meta()"},{"desc":"    * Redefine player's inventory form\n    * Should usually be called in `on_joinplayer`","prefix":"set_inventory_formspec","body":"set_inventory_formspec(${1:formspec})"},{"desc":"returns a formspec string","prefix":"get_inventory_formspec","body":"get_inventory_formspec()"},{"desc":"    * the formspec string will be added to every formspec shown to the user,\n      except for those with a no_prepend[] tag.\n    * This should be used to set style elements such as background[] and\n      bgcolor[], any non-style elements (eg: label) may result in weird behaviour.\n    * Only affects formspecs shown after this is called.","prefix":"set_formspec_prepend","body":"set_formspec_prepend(${1:formspec})"},{"desc":"returns a formspec string.","prefix":"get_formspec_prepend","body":"get_formspec_prepend(${1:formspec})"},{"desc":"returns table with player pressed keys\n    * The table consists of fields with boolean value representing the pressed\n      keys, the fields are jump, right, left, LMB, RMB, sneak, aux1, down, up.\n    * example: `{jump=false, right=true, left=false, LMB=false, RMB=false,\n      sneak=true, aux1=false, down=false, up=false}`","prefix":"get_player_control","body":"get_player_control()"},{"desc":"returns integer with bit packed player pressed\n  keys.\n    * bit nr/meaning: 0/up, 1/down, 2/left, 3/right, 4/jump, 5/aux1, 6/sneak,\n      7/LMB, 8/RMB","prefix":"get_player_control_bits","body":"get_player_control_bits()"},{"desc":"    * `override_table` is a table with the following fields:\n        * `speed`: multiplier to default walking speed value (default: `1`)\n        * `jump`: multiplier to default jump value (default: `1`)\n        * `gravity`: multiplier to default gravity value (default: `1`)\n        * `sneak`: whether player can sneak (default: `true`)\n        * `sneak_glitch`: whether player can use the new move code replications\n          of the old sneak side-effects: sneak ladders and 2 node sneak jump\n          (default: `false`)\n        * `new_move`: use new move/sneak code. When `false` the exact old code\n          is used for the specific old sneak behaviour (default: `true`)","prefix":"set_physics_override","body":"set_physics_override(${1:override}_${2:table})"},{"desc":"returns the table given to `set_physics_override`","prefix":"get_physics_override","body":"get_physics_override()"},{"desc":"add a HUD element described by HUD def, returns ID\n   number on success","prefix":"hud_add","body":"hud_add(${1:hud definition})"},{"desc":"remove the HUD element of the specified id","prefix":"hud_remove","body":"hud_remove(${1:id})"},{"desc":"change a value of a previously added HUD\n  element.\n    * element `stat` values:\n      `position`, `name`, `scale`, `text`, `number`, `item`, `dir`","prefix":"hud_change","body":"hud_change(${1:id}, ${2:stat}, ${3:value})"},{"desc":"gets the HUD element definition structure of the specified ID","prefix":"hud_get","body":"hud_get(${1:id})"},{"desc":"sets specified HUD flags of player.\n    * `flags`: A table with the following fields set to boolean values\n        * hotbar\n        * healthbar\n        * crosshair\n        * wielditem\n        * breathbar\n        * minimap\n        * minimap_radar\n    * If a flag equals `nil`, the flag is not modified\n    * `minimap`: Modifies the client's permission to view the minimap.\n      The client may locally elect to not view the minimap.\n    * `minimap_radar` is only usable when `minimap` is true","prefix":"hud_set_flags","body":"hud_set_flags(${1:flags})"},{"desc":"returns a table of player HUD flags with boolean values.\n    * See `hud_set_flags` for a list of flags that can be toggled.","prefix":"hud_get_flags","body":"hud_get_flags()"},{"desc":"sets number of items in builtin hotbar\n    * `count`: number of items, must be between `1` and `32`\n* `hud_get_hotbar_itemcount`: returns number of visible items","prefix":"hud_set_hotbar_itemcount","body":"hud_set_hotbar_itemcount(${1:count})"},{"desc":"    * sets background image for hotbar\n* `hud_get_hotbar_image`: returns texturename","prefix":"hud_set_hotbar_image","body":"hud_set_hotbar_image(${1:texturename})"},{"desc":"    * sets image for selected item of hotbar\n* `hud_get_hotbar_selected_image`: returns texturename","prefix":"hud_set_hotbar_selected_image","body":"hud_set_hotbar_selected_image(${1:texturename})"},{"desc":"    * `bgcolor`: ColorSpec, defaults to white\n    * `type`: Available types:\n        * `\"regular\"`: Uses 0 textures, `bgcolor` ignored\n        * `\"skybox\"`: Uses 6 textures, `bgcolor` used\n        * `\"plain\"`: Uses 0 textures, `bgcolor` used\n    * `clouds`: Boolean for whether clouds appear in front of `\"skybox\"` or\n      `\"plain\"` custom skyboxes (default: `true`)","prefix":"set_sky","body":"set_sky(${1:bgcolor}, ${2:type}, ${3:}{${4:texture names}}, ${5:clouds})"},{"desc":"returns bgcolor, type, table of textures, clouds","prefix":"get_sky","body":"get_sky()"},{"desc":"set cloud parameters\n    * `parameters` is a table with the following optional fields:\n        * `density`: from `0` (no clouds) to `1` (full clouds) (default `0.4`)\n        * `color`: basic cloud color with alpha channel, ColorSpec\n          (default `#fff0f0e5`).\n        * `ambient`: cloud color lower bound, use for a \"glow at night\" effect.\n          ColorSpec (alpha ignored, default `#000000`)\n        * `height`: cloud height, i.e. y of cloud base (default per conf,\n          usually `120`)\n        * `thickness`: cloud thickness in nodes (default `16`)\n        * `speed`: 2D cloud speed + direction in nodes per second\n          (default `{x=0, z=-2}`).","prefix":"set_clouds","body":"set_clouds(${1:parameters})"},{"desc":"returns a table with the current cloud parameters as in\n  `set_clouds`.","prefix":"get_clouds","body":"get_clouds()"},{"desc":"    * `0`...`1`: Overrides day-night ratio, controlling sunlight to a specific\n      amount.\n    * `nil`: Disables override, defaulting to sunlight based on day-night cycle","prefix":"override_day_night_ratio","body":"override_day_night_ratio(${1:ratio or nil})"},{"desc":"returns the ratio or nil if it isn't overridden","prefix":"get_day_night_ratio","body":"get_day_night_ratio()"},{"desc":"  set animation for player model in third person view\n\n      set_local_animation({x=0, y=79},  -- stand/idle animation key frames\n          {x=168, y=187},  -- walk animation key frames\n          {x=189, y=198},  -- dig animation key frames\n          {x=200, y=219},  -- walk+dig animation key frames\n          frame_speed=30)  -- animation frame speed","prefix":"set_local_animation","body":"set_local_animation(${1:stand}/${2:idle}, ${3:walk}, ${4:dig}, ${5:walk}+${6:dig}, ${7:frame}_${8:speed}=${9:frame}_${10:speed})"},{"desc":"returns stand, walk, dig, dig+walk tables and\n  `frame_speed`.","prefix":"get_local_animation","body":"get_local_animation()"},{"desc":"defines offset value for\n  camera per player.\n    * in first person view\n    * in third person view (max. values `{x=-10/10,y=-10,15,z=-5/5}`)","prefix":"set_eye_offset","body":"set_eye_offset({${1:x}=${2:0}, ${3:y}=${4:0}, ${5:z}=${6:0}}, {${7:x}=${8:0}, ${9:y}=${10:0}, ${11:z}=${12:0}})"},{"desc":"returns `offset_first` and `offset_third`","prefix":"get_eye_offset","body":"get_eye_offset()"},{"desc":"    * Sends a server-side loaded mapblock to the player.\n    * Returns `false` if failed.\n    * Resource intensive - use sparsely\n    * To get blockpos, integer divide pos by 16\n\n`PcgRandom`\n-----------\n\nA 32-bit pseudorandom number generator.\nUses PCG32, an algorithm of the permuted congruential generator family,\noffering very strong randomness.\n\nIt can be created via `PcgRandom(seed)` or `PcgRandom(seed, sequence)`.\n\n### Methods\n","prefix":"send_mapblock","body":"send_mapblock(${1:blockpos})"},{"desc":"return next integer random number [`-2147483648`...`2147483647`]","prefix":"next","body":"next()"},{"desc":"return next integer random number [`min`...`max`]","prefix":"next","body":"next(${1:min}, ${2:max})"},{"desc":"return normally distributed\n  random number [`min`...`max`].\n    * This is only a rough approximation of a normal distribution with:\n    * `mean = (max - min) / 2`, and","prefix":"rand_normal_dist","body":"rand_normal_dist(${1:min}, ${2:max}, ${3:num}_${4:trials}=${5:6})"},{"desc":"    * Increasing `num_trials` improves accuracy of the approximation\n\n`PerlinNoise`\n-------------\n\nA perlin noise generator.\nIt can be created via `PerlinNoise(seed, octaves, persistence, spread)`\nor `PerlinNoise(noiseparams)`.\nAlternatively with `minetest.get_perlin(seeddiff, octaves, persistence, spread)`\nor `minetest.get_perlin(noiseparams)`.\n\n### Methods\n","prefix":"variance = ","body":"variance = (((${1:max }-${2:min }+${3:1})${4:}^${5:2})${6:}-${7:1})${8:}/${9:}(${10:12 }*${11:num}_${12:trials})"},{"desc":"returns 2D noise value at `pos={x=,y=}`","prefix":"get_2d","body":"get_2d(${1:pos})"},{"desc":"returns 3D noise value at `pos={x=,y=,z=}`\n\n`PerlinNoiseMap`\n----------------\n\nA fast, bulk perlin noise generator.\n\nIt can be created via `PerlinNoiseMap(noiseparams, size)` or\n`minetest.get_perlin_map(noiseparams, size)`.\n\nFormat of `size` is `{x=dimx, y=dimy, z=dimz}`. The `z` component is omitted\nfor 2D noise, and it must be must be larger than 1 for 3D noise (otherwise\n`nil` is returned).\n\nFor each of the functions with an optional `buffer` parameter: If `buffer` is\nnot nil, this table will be used to store the result instead of creating a new\ntable.\n\n### Methods\n","prefix":"get_3d","body":"get_3d(${1:pos})"},{"desc":"returns a `<size.x>` times `<size.y>` 2D array of 2D noise\n  with values starting at `pos={x=,y=}`","prefix":"get_2d_map","body":"get_2d_map(${1:pos})"},{"desc":"returns a `<size.x>` times `<size.y>` times `<size.z>`\n  3D array of 3D noise with values starting at `pos={x=,y=,z=}`.","prefix":"get_3d_map","body":"get_3d_map(${1:pos})"},{"desc":"returns a flat `<size.x * size.y>` element\n  array of 2D noise with values starting at `pos={x=,y=}`","prefix":"get_2d_map_flat","body":"get_2d_map_flat(${1:pos}, ${2:buffer})"},{"desc":"Same as `get2dMap_flat`, but 3D noise","prefix":"get_3d_map_flat","body":"get_3d_map_flat(${1:pos}, ${2:buffer})"},{"desc":"Calculates the 2d noise map starting at `pos`. The result\n  is stored internally.","prefix":"calc_2d_map","body":"calc_2d_map(${1:pos})"},{"desc":"Calculates the 3d noise map starting at `pos`. The result\n  is stored internally.","prefix":"calc_3d_map","body":"calc_3d_map(${1:pos})"},{"desc":"In the form of an array,\n  returns a slice of the most recently computed noise results. The result slice\n  begins at coordinates `slice_offset` and takes a chunk of `slice_size`.\n  E.g. to grab a 2-slice high horizontal 2d plane of noise starting at buffer\n  offset y = 20:\n  `noisevals = noise:get_map_slice({y=20}, {y=2})`\n  It is important to note that `slice_offset` offset coordinates begin at 1,\n  and are relative to the starting position of the most recently calculated\n  noise.\n  To grab a single vertical column of noise starting at map coordinates\n  x = 1023, y=1000, z = 1000:\n  `noise:calc_3d_map({x=1000, y=1000, z=1000})`\n  `noisevals = noise:get_map_slice({x=24, z=1}, {x=1, z=1})`\n\n`PlayerMetaRef`\n---------------\n\nPlayer metadata.\nUses the same method of storage as the deprecated player attribute API, so\ndata there will also be in player meta.\nCan be obtained using `player:get_meta()`.\n\n### Methods\n\n* All methods in MetaDataRef\n\n`PseudoRandom`\n--------------\n\nA 16-bit pseudorandom number generator.\nUses a well-known LCG algorithm introduced by K&R.\n\nIt can be created via `PseudoRandom(seed)`.\n\n### Methods\n","prefix":"get_map_slice","body":"get_map_slice(${1:slice}_${2:offset}, ${3:slice}_${4:size}, ${5:buffer})"},{"desc":"return next integer random number [`0`...`32767`]","prefix":"next","body":"next()"},{"desc":"return next integer random number [`min`...`max`]","prefix":"next","body":"next(${1:min}, ${2:max})"},{"desc":"must be true\n      due to the simple implementation making bad distribution otherwise.\n\n`Raycast`\n---------\n\nA raycast on the map. It works with selection boxes.\nCan be used as an iterator in a for loop as:\n\n    local ray = Raycast(...)\n    for pointed_thing in ray do\n        ...\n    end\n\nThe map is loaded as the ray advances. If the map is modified after the\n`Raycast` is created, the changes may or may not have an effect on the object.\n\nIt can be created via `Raycast(pos1, pos2, objects, liquids)` or\n`minetest.raycast(pos1, pos2, objects, liquids)` where:\n\n* `pos1`: start of the ray\n* `pos2`: end of the ray\n* `objects`: if false, only nodes will be returned. Default is true.\n* `liquids`: if false, liquid nodes won't be returned. Default is false.\n\n### Methods\n","prefix":"","body":"((${1:max }-${2:min})${3:}==${4:32767})${5:or }((${6:max}-${7:min})${8:}<=${9:6553}))"},{"desc":"returns a `pointed_thing` with exact pointing location\n    * Returns the next thing pointed by the ray or nil.\n\n`SecureRandom`\n--------------\n\nInterface for the operating system's crypto-secure PRNG.\n\nIt can be created via `SecureRandom()`.  The constructor returns nil if a\nsecure random device cannot be found on the system.\n\n### Methods\n","prefix":"next","body":"next()"},{"desc":"return next `count` (default 1, capped at 2048) many\n  random bytes, as a string.\n\n`Settings`\n----------\n\nAn interface to read config files in the format of `minetest.conf`.\n\nIt can be created via `Settings(filename)`.\n\n### Methods\n","prefix":"next_bytes","body":"next_bytes([${1:count}])"},{"desc":"returns a value","prefix":"get","body":"get(${1:key})"},{"desc":"returns a boolean\n    * `default` is the value returned if `key` is not found.\n    * Returns `nil` if `key` is not found and `default` not specified.","prefix":"get_bool","body":"get_bool(${1:key}, ${2:}[${3:default}])"},{"desc":"returns a NoiseParams table","prefix":"get_np_group","body":"get_np_group(${1:key})"},{"desc":"    * Setting names can't contain whitespace or any of `=\"{}#`.\n    * Setting values can't contain the sequence `\\n\"\"\"`.\n    * Setting names starting with \"secure.\" can't be set on the main settings\n      object (`minetest.settings`).","prefix":"set","body":"set(${1:key}, ${2:value})"},{"desc":"    * See documentation for set() above.","prefix":"set_bool","body":"set_bool(${1:key}, ${2:value})"},{"desc":"    * `value` is a NoiseParams table.\n    * Also, see documentation for set() above.","prefix":"set_np_group","body":"set_np_group(${1:key}, ${2:value})"},{"desc":"returns a boolean (`true` for success)","prefix":"remove","body":"remove(${1:key})"},{"desc":"returns `{key1,...}`","prefix":"get_names","body":"get_names()"},{"desc":"returns a boolean (`true` for success)\n    * Writes changes to file.","prefix":"write","body":"write()"},{"desc":"returns `{[key1]=value1,...}`\n\n### Format\n\nThe settings have the format `key = value`. Example:\n\n    foo = example text\n    bar = \"\"\"\n    Multiline\n    value\n    \"\"\"\n\n\n`StorageRef`\n------------\n\nMod metadata: per mod metadata, saved automatically.\nCan be obtained via `minetest.get_mod_storage()` during load time.\n\nWARNING: This storage backend is incaptable to save raw binary data due\nto restrictions of JSON.\n\n### Methods\n\n* All methods in MetaDataRef\n\n\n\n\nDefinition tables\n=================\n\nObject properties\n-----------------\n\nUsed by `ObjectRef` methods. Part of an Entity definition.\nThese properties are not persistent, but are applied automatically to the\ncorresponding Lua entity using the given registration fields.\nPlayer properties need to be saved manually.\n\n    {\n        hp_max = 1,\n        -- For players only. Defaults to `minetest.PLAYER_MAX_HP_DEFAULT`.\n\n        breath_max = 0,\n        -- For players only. Defaults to `minetest.PLAYER_MAX_BREATH_DEFAULT`.\n\n        zoom_fov = 0.0,\n        -- For players only. Zoom FOV in degrees.\n        -- Note that zoom loads and/or generates world beyond the server's\n        -- maximum send and generate distances, so acts like a telescope.\n        -- Smaller zoom_fov values increase the distance loaded/generated.\n        -- Defaults to 15 in creative mode, 0 in survival mode.\n        -- zoom_fov = 0 disables zooming for the player.\n\n        eye_height = 1.625,\n        -- For players only. Camera height above feet position in nodes.\n        -- Defaults to 1.625.\n\n        physical = true,\n\n        collide_with_objects = true,\n        -- Collide with other objects if physical = true\n\n        weight = 5,\n\n        collisionbox = {-0.5, 0.0, -0.5, 0.5, 1.0, 0.5},  -- Default\n        selectionbox = {-0.5, 0.0, -0.5, 0.5, 1.0, 0.5},\n        -- Selection box uses collision box dimensions when not set.\n        -- For both boxes: {xmin, ymin, zmin, xmax, ymax, zmax} in nodes from\n        -- object position.\n\n        pointable = true,\n        -- Overrides selection box when false\n\n        visual = \"cube\" / \"sprite\" / \"upright_sprite\" / \"mesh\" / \"wielditem\" / \"item\",\n        -- \"cube\" is a node-sized cube.\n        -- \"sprite\" is a flat texture always facing the player.\n        -- \"upright_sprite\" is a vertical flat texture.\n        -- \"mesh\" uses the defined mesh model.\n        -- \"wielditem\" is used for dropped items.\n        --   (see builtin/game/item_entity.lua).\n        --   For this use 'wield_item = itemname' (Deprecated: 'textures = {itemname}').\n        --   If the item has a 'wield_image' the object will be an extrusion of\n        --   that, otherwise:\n        --   If 'itemname' is a cubic node or nodebox the object will appear\n        --   identical to 'itemname'.\n        --   If 'itemname' is a plantlike node the object will be an extrusion\n        --   of its texture.\n        --   Otherwise for non-node items, the object will be an extrusion of\n        --   'inventory_image'.\n        --   If 'itemname' contains a ColorString or palette index (e.g. from\n        --   `minetest.itemstring_with_palette()`), the entity will inherit the color.\n        -- \"item\" is similar to \"wielditem\" but ignores the 'wield_image' parameter.\n\n        visual_size = {x = 1, y = 1, z = 1},\n        -- Multipliers for the visual size. If `z` is not specified, `x` will be used\n        -- to scale the entity along both horizontal axes.\n\n        mesh = \"model\",\n\n        textures = {},\n        -- Number of required textures depends on visual.\n        -- \"cube\" uses 6 textures just like a node, but all 6 must be defined.\n        -- \"sprite\" uses 1 texture.\n        -- \"upright_sprite\" uses 2 textures: {front, back}.\n        -- \"wielditem\" expects 'textures = {itemname}' (see 'visual' above).\n\n        colors = {},\n        -- Number of required colors depends on visual\n\n        use_texture_alpha = false,\n        -- Use texture's alpha channel.\n        -- Excludes \"upright_sprite\" and \"wielditem\".\n        -- Note: currently causes visual issues when viewed through other\n        -- semi-transparent materials such as water.\n\n        spritediv = {x = 1, y = 1},\n        -- Used with spritesheet textures for animation and/or frame selection\n        -- according to position relative to player.\n        -- Defines the number of columns and rows in the spritesheet:\n        -- {columns, rows}.\n\n        initial_sprite_basepos = {x = 0, y = 0},\n        -- Used with spritesheet textures.\n        -- Defines the {column, row} position of the initially used frame in the\n        -- spritesheet.\n\n        is_visible = true,\n\n        makes_footstep_sound = false,\n\n        automatic_rotate = 0,\n        -- Set constant rotation in radians per second, positive or negative.\n        -- Set to 0 to disable constant rotation.\n\n        stepheight = 0,\n\n        automatic_face_movement_dir = 0.0,\n        -- Automatically set yaw to movement direction, offset in degrees.\n        -- 'false' to disable.\n\n        automatic_face_movement_max_rotation_per_sec = -1,\n        -- Limit automatic rotation to this value in degrees per second.\n        -- No limit if value <= 0.\n\n        backface_culling = true,\n        -- Set to false to disable backface_culling for model\n\n        glow = 0,\n        -- Add this much extra lighting when calculating texture color.\n        -- Value < 0 disables light's effect on texture color.\n        -- For faking self-lighting, UI style entities, or programmatic coloring\n        -- in mods.\n\n        nametag = \"\",\n        -- By default empty, for players their name is shown if empty\n\n        nametag_color = <ColorSpec>,\n        -- Sets color of nametag\n\n        infotext = \"\",\n        -- By default empty, text to be shown when pointed at object\n\n        static_save = true,\n        -- If false, never save this object statically. It will simply be\n        -- deleted when the block gets unloaded.\n        -- The get_staticdata() callback is never called then.\n        -- Defaults to 'true'.\n    }\n\nEntity definition\n-----------------\n\nUsed by `minetest.register_entity`.\n\n    {\n        initial_properties = {\n            visual = \"mesh\",\n            mesh = \"boats_boat.obj\",\n            ...,\n        },\n        -- A table of object properties, see the `Object properties` section.\n        -- Object properties being read directly from the entity definition\n        -- table is deprecated. Define object properties in this\n        -- `initial_properties` table instead.\n\n        on_activate = function(self, staticdata, dtime_s),\n\n        on_step = function(self, dtime),\n\n        on_punch = function(self, puncher, time_from_last_punch, tool_capabilities, dir),\n\n        on_rightclick = function(self, clicker),\n\n        get_staticdata = function(self),\n        -- Called sometimes; the string returned is passed to on_activate when\n        -- the entity is re-activated from static state\n\n        _custom_field = whatever,\n        -- You can define arbitrary member variables here (see Item definition\n        -- for more info) by using a '_' prefix\n    }\n\nABM (ActiveBlockModifier) definition\n------------------------------------\n\nUsed by `minetest.register_abm`.\n\n    {\n        label = \"Lava cooling\",\n        -- Descriptive label for profiling purposes (optional).\n        -- Definitions with identical labels will be listed as one.\n\n        nodenames = {\"default:lava_source\"},\n        -- Apply `action` function to these nodes.\n        -- `group:groupname` can also be used here.\n\n        neighbors = {\"default:water_source\", \"default:water_flowing\"},\n        -- Only apply `action` to nodes that have one of, or any\n        -- combination of, these neighbors.\n        -- If left out or empty, any neighbor will do.\n        -- `group:groupname` can also be used here.\n\n        interval = 1.0,\n        -- Operation interval in seconds\n\n        chance = 1,\n        -- Chance of triggering `action` per-node per-interval is 1.0 / this\n        -- value\n\n        catch_up = true,\n        -- If true, catch-up behaviour is enabled: The `chance` value is\n        -- temporarily reduced when returning to an area to simulate time lost\n        -- by the area being unattended. Note that the `chance` value can often\n        -- be reduced to 1.\n\n        action = function(pos, node, active_object_count, active_object_count_wider),\n        -- Function triggered for each qualifying node.\n        -- `active_object_count` is number of active objects in the node's\n        -- mapblock.\n        -- `active_object_count_wider` is number of active objects in the node's\n        -- mapblock plus all 26 neighboring mapblocks. If any neighboring\n        -- mapblocks are unloaded an estmate is calculated for them based on\n        -- loaded mapblocks.\n    }\n\nLBM (LoadingBlockModifier) definition\n-------------------------------------\n\nUsed by `minetest.register_lbm`.\n\nA loading block modifier (LBM) is used to define a function that is called for\nspecific nodes (defined by `nodenames`) when a mapblock which contains such nodes\ngets loaded.\n\n    {\n        label = \"Upgrade legacy doors\",\n        -- Descriptive label for profiling purposes (optional).\n        -- Definitions with identical labels will be listed as one.\n\n        name = \"modname:replace_legacy_door\",\n\n        nodenames = {\"default:lava_source\"},\n        -- List of node names to trigger the LBM on.\n        -- Also non-registered nodes will work.\n        -- Groups (as of group:groupname) will work as well.\n\n        run_at_every_load = false,\n        -- Whether to run the LBM's action every time a block gets loaded,\n        -- and not only the first time the block gets loaded after the LBM\n        -- was introduced.\n\n        action = function(pos, node),\n    }\n\nTile definition\n---------------\n\n* `\"image.png\"`\n* `{name=\"image.png\", animation={Tile Animation definition}}`\n* `{name=\"image.png\", backface_culling=bool, tileable_vertical=bool,\n  tileable_horizontal=bool, align_style=\"node\"/\"world\"/\"user\", scale=int}`\n    * backface culling enabled by default for most nodes\n    * tileable flags are info for shaders, how they should treat texture\n      when displacement mapping is used.\n      Directions are from the point of view of the tile texture,\n      not the node it's on.\n    * align style determines whether the texture will be rotated with the node\n      or kept aligned with its surroundings. \"user\" means that client\n      setting will be used, similar to `glasslike_framed_optional`.\n      Note: supported by solid nodes and nodeboxes only.\n    * scale is used to make texture span several (exactly `scale`) nodes,\n      instead of just one, in each direction. Works for world-aligned\n      textures only.\n      Note that as the effect is applied on per-mapblock basis, `16` should\n      be equally divisible by `scale` or you may get wrong results.\n* `{name=\"image.png\", color=ColorSpec}`\n    * the texture's color will be multiplied with this color.\n    * the tile's color overrides the owning node's color in all cases.\n* deprecated, yet still supported field names:\n    * `image` (name)\n\nTile animation definition\n-------------------------\n\n    {\n        type = \"vertical_frames\",\n\n        aspect_w = 16,\n        -- Width of a frame in pixels\n\n        aspect_h = 16,\n        -- Height of a frame in pixels\n\n        length = 3.0,\n        -- Full loop length\n    }\n\n    {\n        type = \"sheet_2d\",\n\n        frames_w = 5,\n        -- Width in number of frames\n\n        frames_h = 3,\n        -- Height in number of frames\n\n        frame_length = 0.5,\n        -- Length of a single frame\n    }\n\nItem definition\n---------------\n\nUsed by `minetest.register_node`, `minetest.register_craftitem`, and\n`minetest.register_tool`.\n\n    {\n        description = \"Steel Axe\",\n\n        groups = {},\n        -- key = name, value = rating; rating = 1..3.\n        -- If rating not applicable, use 1.\n        -- e.g. {wool = 1, fluffy = 3}\n        --      {soil = 2, outerspace = 1, crumbly = 1}\n        --      {bendy = 2, snappy = 1},\n        --      {hard = 1, metal = 1, spikes = 1}\n\n        inventory_image = \"default_tool_steelaxe.png\",\n\n        inventory_overlay = \"overlay.png\",\n        -- An overlay which does not get colorized\n\n        wield_image = \"\",\n\n        wield_overlay = \"\",\n\n        palette = \"\",\n        -- An image file containing the palette of a node.\n        -- You can set the currently used color as the \"palette_index\" field of\n        -- the item stack metadata.\n        -- The palette is always stretched to fit indices between 0 and 255, to\n        -- ensure compatibility with \"colorfacedir\" and \"colorwallmounted\" nodes.\n\n        color = \"0xFFFFFFFF\",\n        -- The color of the item. The palette overrides this.\n\n        wield_scale = {x = 1, y = 1, z = 1},\n\n        stack_max = 99,\n\n        range = 4.0,\n\n        liquids_pointable = false,\n\n        -- See \"Tools\" section for an example including explanation\n        tool_capabilities = {\n            full_punch_interval = 1.0,\n            max_drop_level = 0,\n            groupcaps = {\n                -- For example:\n                choppy = {times = {[1] = 2.50, [2] = 1.40, [3] = 1.00},\n                         uses = 20, maxlevel = 2},\n            },\n            damage_groups = {groupname = damage},\n\n            punch_attack_uses = nil,\n            -- Amount of uses this tool has for attacking players and entities\n            -- by punching them (0 = infinite uses).\n            -- For compatibility, this is automatically set from the first\n            -- suitable groupcap using the forumla \"uses * 3^(maxlevel - 1)\".\n            -- It is recommend to set this explicitly instead of relying on the\n            -- fallback behavior.\n        },\n\n        node_placement_prediction = nil,\n        -- If nil and item is node, prediction is made automatically.\n        -- If nil and item is not a node, no prediction is made.\n        -- If \"\" and item is anything, no prediction is made.\n        -- Otherwise should be name of node which the client immediately places\n        -- on ground when the player places the item. Server will always update\n        -- actual result to client in a short moment.\n\n        node_dig_prediction = \"air\",\n        -- if \"\", no prediction is made.\n        -- if \"air\", node is removed.\n        -- Otherwise should be name of node which the client immediately places\n        -- upon digging. Server will always update actual result shortly.\n\n        sound = {\n            breaks = \"default_tool_break\",  -- tools only\n            place = <SimpleSoundSpec>,\n            eat = <SimpleSoundSpec>,\n        },\n\n        on_place = function(itemstack, placer, pointed_thing),\n        -- Shall place item and return the leftover itemstack.\n        -- The placer may be any ObjectRef or nil.\n        -- default: minetest.item_place\n\n        on_secondary_use = function(itemstack, user, pointed_thing),\n        -- Same as on_place but called when pointing at nothing.\n        -- The user may be any ObjectRef or nil.\n        -- pointed_thing: always { type = \"nothing\" }\n\n        on_drop = function(itemstack, dropper, pos),\n        -- Shall drop item and return the leftover itemstack.\n        -- The dropper may be any ObjectRef or nil.\n        -- default: minetest.item_drop\n\n        on_use = function(itemstack, user, pointed_thing),\n        -- default: nil\n        -- Function must return either nil if no item shall be removed from\n        -- inventory, or an itemstack to replace the original itemstack.\n        -- e.g. itemstack:take_item(); return itemstack\n        -- Otherwise, the function is free to do what it wants.\n        -- The user may be any ObjectRef or nil.\n        -- The default functions handle regular use cases.\n\n        after_use = function(itemstack, user, node, digparams),\n        -- default: nil\n        -- If defined, should return an itemstack and will be called instead of\n        -- wearing out the tool. If returns nil, does nothing.\n        -- If after_use doesn't exist, it is the same as:\n        --   function(itemstack, user, node, digparams)\n        --     itemstack:add_wear(digparams.wear)\n        --     return itemstack\n        --   end\n        -- The user may be any ObjectRef or nil.\n\n        _custom_field = whatever,\n        -- Add your own custom fields. By convention, all custom field names\n        -- should start with `_` to avoid naming collisions with future engine\n        -- usage.\n    }\n\nNode definition\n---------------\n\nUsed by `minetest.register_node`.\n\n    {\n        -- <all fields allowed in item definitions>,\n\n        drawtype = \"normal\",  -- See \"Node drawtypes\"\n\n        visual_scale = 1.0,\n        -- Supported for drawtypes \"plantlike\", \"signlike\", \"torchlike\",\n        -- \"firelike\", \"mesh\".\n        -- For plantlike and firelike, the image will start at the bottom of the\n        -- node, for the other drawtypes the image will be centered on the node.\n        -- Note that positioning for \"torchlike\" may still change.\n\n        tiles = {tile definition 1, def2, def3, def4, def5, def6},\n        -- Textures of node; +Y, -Y, +X, -X, +Z, -Z\n        -- Old field name was 'tile_images'.\n        -- List can be shortened to needed length.\n\n        overlay_tiles = {tile definition 1, def2, def3, def4, def5, def6},\n        -- Same as `tiles`, but these textures are drawn on top of the base\n        -- tiles. You can use this to colorize only specific parts of your\n        -- texture. If the texture name is an empty string, that overlay is not\n        -- drawn. Since such tiles are drawn twice, it is not recommended to use\n        -- overlays on very common nodes.\n\n        special_tiles = {tile definition 1, Tile definition 2},\n        -- Special textures of node; used rarely.\n        -- Old field name was 'special_materials'.\n        -- List can be shortened to needed length.\n\n        color = ColorSpec,\n        -- The node's original color will be multiplied with this color.\n        -- If the node has a palette, then this setting only has an effect in\n        -- the inventory and on the wield item.\n\n        use_texture_alpha = false,\n        -- Use texture's alpha channel\n\n        palette = \"palette.png\",\n        -- The node's `param2` is used to select a pixel from the image.\n        -- Pixels are arranged from left to right and from top to bottom.\n        -- The node's color will be multiplied with the selected pixel's color.\n        -- Tiles can override this behavior.\n        -- Only when `paramtype2` supports palettes.\n\n        post_effect_color = \"green#0F\",\n        -- Screen tint if player is inside node, see \"ColorSpec\"\n\n        paramtype = \"none\",  -- See \"Nodes\"\n\n        paramtype2 = \"none\",  -- See \"Nodes\"\n\n        place_param2 = nil,  -- Force value for param2 when player places node\n\n        is_ground_content = true,\n        -- If false, the cave generator and dungeon generator will not carve\n        -- through this node.\n        -- Specifically, this stops mod-added nodes being removed by caves and\n        -- dungeons when those generate in a neighbor mapchunk and extend out\n        -- beyond the edge of that mapchunk.\n\n        sunlight_propagates = false,\n        -- If true, sunlight will go infinitely through this node\n\n        walkable = true,  -- If true, objects collide with node\n\n        pointable = true,  -- If true, can be pointed at\n\n        diggable = true,  -- If false, can never be dug\n\n        climbable = false,  -- If true, can be climbed on (ladder)\n\n        buildable_to = false,  -- If true, placed nodes can replace this node\n\n        floodable = false,\n        -- If true, liquids flow into and replace this node.\n        -- Warning: making a liquid node 'floodable' will cause problems.\n\n        liquidtype = \"none\",  -- \"none\" / \"source\" / \"flowing\"\n\n        liquid_alternative_flowing = \"\",  -- Flowing version of source liquid\n\n        liquid_alternative_source = \"\",  -- Source version of flowing liquid\n\n        liquid_viscosity = 0,  -- Higher viscosity = slower flow (max. 7)\n\n        liquid_renewable = true,\n        -- If true, a new liquid source can be created by placing two or more\n        -- sources nearby\n\n        leveled = 16,\n        -- Only valid for \"nodebox\" drawtype with 'type = \"leveled\"'.\n        -- Allows defining the nodebox height without using param2.\n        -- The nodebox height is 'leveled' / 64 nodes.\n        -- The maximum value of 'leveled' is 127.\n\n        liquid_range = 8,  -- Number of flowing nodes around source (max. 8)\n\n        drowning = 0,\n        -- Player will take this amount of damage if no bubbles are left\n\n        light_source = 0,\n        -- Amount of light emitted by node.\n        -- To set the maximum (14), use the value 'minetest.LIGHT_MAX'.\n        -- A value outside the range 0 to minetest.LIGHT_MAX causes undefined\n        -- behavior.\n\n        damage_per_second = 0,\n        -- If player is inside node, this damage is caused\n\n        node_box = {type=\"regular\"},  -- See \"Node boxes\"\n\n        connects_to = nodenames,\n        -- Used for nodebox nodes with the type == \"connected\".\n        -- Specifies to what neighboring nodes connections will be drawn.\n        -- e.g. `{\"group:fence\", \"default:wood\"}` or `\"default:stone\"`\n\n        connect_sides = { \"top\", \"bottom\", \"front\", \"left\", \"back\", \"right\" },\n        -- Tells connected nodebox nodes to connect only to these sides of this\n        -- node\n\n        mesh = \"model\",\n\n        selection_box = {\n            type = \"fixed\",\n            fixed = {\n                {-2 / 16, -0.5, -2 / 16, 2 / 16, 3 / 16, 2 / 16},\n            },\n        },\n        -- Custom selection box definition. Multiple boxes can be defined.\n        -- If \"nodebox\" drawtype is used and selection_box is nil, then node_box\n        -- definition is used for the selection box.\n\n        collision_box = {\n            type = \"fixed\",\n            fixed = {\n                {-2 / 16, -0.5, -2 / 16, 2 / 16, 3 / 16, 2 / 16},\n            },\n        },\n        -- Custom collision box definition. Multiple boxes can be defined.\n        -- If \"nodebox\" drawtype is used and collision_box is nil, then node_box\n        -- definition is used for the collision box.\n        -- Both of the boxes above are defined as:\n        -- {xmin, ymin, zmin, xmax, ymax, zmax} in nodes from node center.\n\n        -- Support maps made in and before January 2012\n        legacy_facedir_simple = false,\n        legacy_wallmounted = false,\n\n        waving = 0,\n        -- Valid for drawtypes:\n        -- mesh, nodebox, plantlike, allfaces_optional, liquid, flowingliquid.\n        -- 1 - wave node like plants (node top moves side-to-side, bottom is fixed)\n        -- 2 - wave node like leaves (whole node moves side-to-side)\n        -- 3 - wave node like liquids (whole node moves up and down)\n        -- Not all models will properly wave.\n        -- plantlike drawtype can only wave like plants.\n        -- allfaces_optional drawtype can only wave like leaves.\n        -- liquid, flowingliquid drawtypes can only wave like liquids.\n\n        sounds = {\n            footstep = <SimpleSoundSpec>,\n            dig = <SimpleSoundSpec>,  -- \"__group\" = group-based sound (default)\n            dug = <SimpleSoundSpec>,\n            place = <SimpleSoundSpec>,\n            place_failed = <SimpleSoundSpec>,\n            fall = <SimpleSoundSpec>,\n        },\n\n        drop = \"\",\n        -- Name of dropped item when dug.\n        -- Default dropped item is the node itself.\n        -- Using a table allows multiple items, drop chances and tool filtering.\n        -- Tool filtering was undocumented until recently, tool filtering by string\n        -- matching is deprecated.\n        drop = {\n            max_items = 1,\n            -- Maximum number of item lists to drop.\n            -- The entries in 'items' are processed in order. For each:\n            -- Tool filtering is applied, chance of drop is applied, if both are\n            -- successful the entire item list is dropped.\n            -- Entry processing continues until the number of dropped item lists\n            -- equals 'max_items'.\n            -- Therefore, entries should progress from low to high drop chance.\n            items = {\n                -- Entry examples.\n                {\n                    -- 1 in 1000 chance of dropping a diamond.\n                    -- Default rarity is '1'.\n                    rarity = 1000,\n                    items = {\"default:diamond\"},\n                },\n                {\n                    -- Only drop if using a tool whose name is identical to one\n                    -- of these.\n                    tools = {\"default:shovel_mese\", \"default:shovel_diamond\"},\n                    rarity = 5,\n                    items = {\"default:dirt\"},\n                    -- Whether all items in the dropped item list inherit the\n                    -- hardware coloring palette color from the dug node.\n                    -- Default is 'false'.\n                    inherit_color = true,\n                },\n                {\n                    -- Only drop if using a tool whose name contains\n                    -- \"default:shovel_\" (this tool filtering by string matching\n                    -- is deprecated).\n                    tools = {\"~default:shovel_\"},\n                    rarity = 2,\n                    -- The item list dropped.\n                    items = {\"default:sand\", \"default:desert_sand\"},\n                },\n            },\n        },\n\n        on_construct = function(pos),\n        -- Node constructor; called after adding node.\n        -- Can set up metadata and stuff like that.\n        -- Not called for bulk node placement (i.e. schematics and VoxelManip).\n        -- default: nil\n\n        on_destruct = function(pos),\n        -- Node destructor; called before removing node.\n        -- Not called for bulk node placement.\n        -- default: nil\n\n        after_destruct = function(pos, oldnode),\n        -- Node destructor; called after removing node.\n        -- Not called for bulk node placement.\n        -- default: nil\n\n        on_flood = function(pos, oldnode, newnode),\n        -- Called when a liquid (newnode) is about to flood oldnode, if it has\n        -- `floodable = true` in the nodedef. Not called for bulk node placement\n        -- (i.e. schematics and VoxelManip) or air nodes. If return true the\n        -- node is not flooded, but on_flood callback will most likely be called\n        -- over and over again every liquid update interval.\n        -- Default: nil\n        -- Warning: making a liquid node 'floodable' will cause problems.\n\n        preserve_metadata = function(pos, oldnode, oldmeta, drops),\n        -- Called when oldnode is about be converted to an item, but before the\n        -- node is deleted from the world or the drops are added. This is\n        -- generally the result of either the node being dug or an attached node\n        -- becoming detached.\n        -- drops is a table of ItemStacks, so any metadata to be preserved can\n        -- be added directly to one or more of the dropped items. See\n        -- \"ItemStackMetaRef\".\n        -- default: nil\n\n        after_place_node = function(pos, placer, itemstack, pointed_thing),\n        -- Called after constructing node when node was placed using\n        -- minetest.item_place_node / minetest.place_node.\n        -- If return true no item is taken from itemstack.\n        -- `placer` may be any valid ObjectRef or nil.\n        -- default: nil\n\n        after_dig_node = function(pos, oldnode, oldmetadata, digger),\n        -- oldmetadata is in table format.\n        -- Called after destructing node when node was dug using\n        -- minetest.node_dig / minetest.dig_node.\n        -- default: nil\n\n        can_dig = function(pos, [player]),\n        -- Returns true if node can be dug, or false if not.\n        -- default: nil\n\n        on_punch = function(pos, node, puncher, pointed_thing),\n        -- default: minetest.node_punch\n        -- By default calls minetest.register_on_punchnode callbacks.\n\n        on_rightclick = function(pos, node, clicker, itemstack, pointed_thing),\n        -- default: nil\n        -- itemstack will hold clicker's wielded item.\n        -- Shall return the leftover itemstack.\n        -- Note: pointed_thing can be nil, if a mod calls this function.\n        -- This function does not get triggered by clients <=0.4.16 if the\n        -- \"formspec\" node metadata field is set.\n\n        on_dig = function(pos, node, digger),\n        -- default: minetest.node_dig\n        -- By default checks privileges, wears out tool and removes node.\n\n        on_timer = function(pos, elapsed),\n        -- default: nil\n        -- called by NodeTimers, see minetest.get_node_timer and NodeTimerRef.\n        -- elapsed is the total time passed since the timer was started.\n        -- return true to run the timer for another cycle with the same timeout\n        -- value.\n\n        on_receive_fields = function(pos, formname, fields, sender),\n        -- fields = {name1 = value1, name2 = value2, ...}\n        -- Called when an UI form (e.g. sign text input) returns data.\n        -- See minetest.register_on_player_receive_fields for more info.\n        -- default: nil\n\n        allow_metadata_inventory_move = function(pos, from_list, from_index, to_list, to_index, count, player),\n        -- Called when a player wants to move items inside the inventory.\n        -- Return value: number of items allowed to move.\n\n        allow_metadata_inventory_put = function(pos, listname, index, stack, player),\n        -- Called when a player wants to put something into the inventory.\n        -- Return value: number of items allowed to put.\n        -- Return value -1: Allow and don't modify item count in inventory.\n\n        allow_metadata_inventory_take = function(pos, listname, index, stack, player),\n        -- Called when a player wants to take something out of the inventory.\n        -- Return value: number of items allowed to take.\n        -- Return value -1: Allow and don't modify item count in inventory.\n\n        on_metadata_inventory_move = function(pos, from_list, from_index, to_list, to_index, count, player),\n        on_metadata_inventory_put = function(pos, listname, index, stack, player),\n        on_metadata_inventory_take = function(pos, listname, index, stack, player),\n        -- Called after the actual action has happened, according to what was\n        -- allowed.\n        -- No return value.\n\n        on_blast = function(pos, intensity),\n        -- intensity: 1.0 = mid range of regular TNT.\n        -- If defined, called when an explosion touches the node, instead of\n        -- removing the node.\n    }\n\nCrafting recipes\n----------------\n\nUsed by `minetest.register_craft`.\n\n### Shaped\n\n    {\n        output = 'default:pick_stone',\n        recipe = {\n            {'default:cobble', 'default:cobble', 'default:cobble'},\n            {'', 'default:stick', ''},\n            {'', 'default:stick', ''},  -- Also groups; e.g. 'group:crumbly'\n        },\n        replacements = <list of item pairs>,\n        -- replacements: replace one input item with another item on crafting\n        -- (optional).\n    }\n\n### Shapeless\n\n    {\n        type = \"shapeless\",\n        output = 'mushrooms:mushroom_stew',\n        recipe = {\n            \"mushrooms:bowl\",\n            \"mushrooms:mushroom_brown\",\n            \"mushrooms:mushroom_red\",\n        },\n        replacements = <list of item pairs>,\n    }\n\n### Tool repair\n\n    {\n        type = \"toolrepair\",\n        additional_wear = -0.02,\n    }\n\nNote: Tools with group `disable_repair=1` will not repairable by this recipe.\n\n### Cooking\n\n    {\n        type = \"cooking\",\n        output = \"default:glass\",\n        recipe = \"default:sand\",\n        cooktime = 3,\n    }\n\n### Furnace fuel\n\n    {\n        type = \"fuel\",\n        recipe = \"bucket:bucket_lava\",\n        burntime = 60,\n        replacements = {{\"bucket:bucket_lava\", \"bucket:bucket_empty\"}},\n    }\n\nOre definition\n--------------\n\nUsed by `minetest.register_ore`.\n\nSee [Ores] section above for essential information.\n\n    {\n        ore_type = \"scatter\",\n\n        ore = \"default:stone_with_coal\",\n\n        ore_param2 = 3,\n        -- Facedir rotation. Default is 0 (unchanged rotation)\n\n        wherein = \"default:stone\",\n        -- A list of nodenames is supported too\n\n        clust_scarcity = 8 * 8 * 8,\n        -- Ore has a 1 out of clust_scarcity chance of spawning in a node.\n        -- If the desired average distance between ores is 'd', set this to\n        -- d * d * d.\n\n        clust_num_ores = 8,\n        -- Number of ores in a cluster\n\n        clust_size = 3,\n        -- Size of the bounding box of the cluster.\n        -- In this example, there is a 3 * 3 * 3 cluster where 8 out of the 27\n        -- nodes are coal ore.\n\n        y_min = -31000,\n        y_max = 64,\n        -- Lower and upper limits for ore\n\n        flags = \"\",\n        -- Attributes for the ore generation, see 'Ore attributes' section above\n\n        noise_threshold = 0.5,\n        -- If noise is above this threshold, ore is placed. Not needed for a\n        -- uniform distribution.\n\n        noise_params = {\n            offset = 0,\n            scale = 1,\n            spread = {x = 100, y = 100, z = 100},\n            seed = 23,\n            octaves = 3,\n            persist = 0.7\n        },\n        -- NoiseParams structure describing one of the perlin noises used for\n        -- ore distribution.\n        -- Needed by \"sheet\", \"puff\", \"blob\" and \"vein\" ores.\n        -- Omit from \"scatter\" ore for a uniform ore distribution.\n        -- Omit from \"stratum\" ore for a simple horizontal strata from y_min to\n        -- y_max.\n\n        biomes = {\"desert\", \"rainforest\"},\n        -- List of biomes in which this ore occurs.\n        -- Occurs in all biomes if this is omitted, and ignored if the Mapgen\n        -- being used does not support biomes.\n        -- Can be a list of (or a single) biome names, IDs, or definitions.\n\n        -- Type-specific parameters\n\n        -- sheet\n        column_height_min = 1,\n        column_height_max = 16,\n        column_midpoint_factor = 0.5,\n\n        -- puff\n        np_puff_top = {\n            offset = 4,\n            scale = 2,\n            spread = {x = 100, y = 100, z = 100},\n            seed = 47,\n            octaves = 3,\n            persist = 0.7\n        },\n        np_puff_bottom = {\n            offset = 4,\n            scale = 2,\n            spread = {x = 100, y = 100, z = 100},\n            seed = 11,\n            octaves = 3,\n            persist = 0.7\n        },\n\n        -- vein\n        random_factor = 1.0,\n\n        -- stratum\n        np_stratum_thickness = {\n            offset = 8,\n            scale = 4,\n            spread = {x = 100, y = 100, z = 100},\n            seed = 17,\n            octaves = 3,\n            persist = 0.7\n        },\n        stratum_thickness = 8,\n    }\n\nBiome definition\n----------------\n\nUsed by `minetest.register_biome`.\n\n    {\n        name = \"tundra\",\n\n        node_dust = \"default:snow\",\n        -- Node dropped onto upper surface after all else is generated\n\n        node_top = \"default:dirt_with_snow\",\n        depth_top = 1,\n        -- Node forming surface layer of biome and thickness of this layer\n\n        node_filler = \"default:permafrost\",\n        depth_filler = 3,\n        -- Node forming lower layer of biome and thickness of this layer\n\n        node_stone = \"default:bluestone\",\n        -- Node that replaces all stone nodes between roughly y_min and y_max.\n\n        node_water_top = \"default:ice\",\n        depth_water_top = 10,\n        -- Node forming a surface layer in seawater with the defined thickness\n\n        node_water = \"\",\n        -- Node that replaces all seawater nodes not in the surface layer\n\n        node_river_water = \"default:ice\",\n        -- Node that replaces river water in mapgens that use\n        -- default:river_water\n\n        node_riverbed = \"default:gravel\",\n        depth_riverbed = 2,\n        -- Node placed under river water and thickness of this layer\n\n        node_cave_liquid = \"default:lava_source\",\n        node_cave_liquid = {\"default:water_source\", \"default:lava_source\"},\n        -- Nodes placed inside 50% of the medium size caves.\n        -- Multiple nodes can be specified, each cave will use a randomly\n        -- chosen node from the list.\n        -- If this field is left out or 'nil', cave liquids fall back to\n        -- classic behaviour of lava and water distributed using 3D noise.\n        -- For no cave liquid, specify \"air\".\n\n        node_dungeon = \"default:cobble\",\n        -- Node used for primary dungeon structure.\n        -- If absent, dungeon nodes fall back to the 'mapgen_cobble' mapgen\n        -- alias, if that is also absent, dungeon nodes fall back to the biome\n        -- 'node_stone'.\n        -- If present, the following two nodes are also used.\n\n        node_dungeon_alt = \"default:mossycobble\",\n        -- Node used for randomly-distributed alternative structure nodes.\n        -- If alternative structure nodes are not wanted leave this absent for\n        -- performance reasons.\n\n        node_dungeon_stair = \"stairs:stair_cobble\",\n        -- Node used for dungeon stairs.\n        -- If absent, stairs fall back to 'node_dungeon'.\n\n        y_max = 31000,\n        y_min = 1,\n        -- Upper and lower limits for biome.\n        -- Alternatively you can use xyz limits as shown below.\n\n        max_pos = {x = 31000, y = 128, z = 31000},\n        min_pos = {x = -31000, y = 9, z = -31000},\n        -- xyz limits for biome, an alternative to using 'y_min' and 'y_max'.\n        -- Biome is limited to a cuboid defined by these positions.\n        -- Any x, y or z field left undefined defaults to -31000 in 'min_pos' or\n        -- 31000 in 'max_pos'.\n\n        vertical_blend = 8,\n        -- Vertical distance in nodes above 'y_max' over which the biome will\n        -- blend with the biome above.\n        -- Set to 0 for no vertical blend. Defaults to 0.\n\n        heat_point = 0,\n        humidity_point = 50,\n        -- Characteristic temperature and humidity for the biome.\n        -- These values create 'biome points' on a voronoi diagram with heat and\n        -- humidity as axes. The resulting voronoi cells determine the\n        -- distribution of the biomes.\n        -- Heat and humidity have average values of 50, vary mostly between\n        -- 0 and 100 but can exceed these values.\n    }\n\nDecoration definition\n---------------------\n\nSee [Decoration types]. Used by `minetest.register_decoration`.\n\n    {\n        deco_type = \"simple\",\n\n        place_on = \"default:dirt_with_grass\",\n        -- Node (or list of nodes) that the decoration can be placed on\n\n        sidelen = 8,\n        -- Size of the square divisions of the mapchunk being generated.\n        -- Determines the resolution of noise variation if used.\n        -- If the chunk size is not evenly divisible by sidelen, sidelen is made\n        -- equal to the chunk size.\n\n        fill_ratio = 0.02,\n        -- The value determines 'decorations per surface node'.\n        -- Used only if noise_params is not specified.\n        -- If >= 10.0 complete coverage is enabled and decoration placement uses\n        -- a different and much faster method.\n\n        noise_params = {\n            offset = 0,\n            scale = 0.45,\n            spread = {x = 100, y = 100, z = 100},\n            seed = 354,\n            octaves = 3,\n            persist = 0.7,\n            lacunarity = 2.0,\n            flags = \"absvalue\"\n        },\n        -- NoiseParams structure describing the perlin noise used for decoration\n        -- distribution.\n        -- A noise value is calculated for each square division and determines\n        -- 'decorations per surface node' within each division.\n        -- If the noise value >= 10.0 complete coverage is enabled and\n        -- decoration placement uses a different and much faster method.\n\n        biomes = {\"Oceanside\", \"Hills\", \"Plains\"},\n        -- List of biomes in which this decoration occurs. Occurs in all biomes\n        -- if this is omitted, and ignored if the Mapgen being used does not\n        -- support biomes.\n        -- Can be a list of (or a single) biome names, IDs, or definitions.\n\n        y_min = -31000,\n        y_max = 31000,\n        -- Lower and upper limits for decoration.\n        -- These parameters refer to the Y co-ordinate of the 'place_on' node.\n\n        spawn_by = \"default:water\",\n        -- Node (or list of nodes) that the decoration only spawns next to.\n        -- Checks two horizontal planes of 8 neighbouring nodes (including\n        -- diagonal neighbours), one plane level with the 'place_on' node and a\n        -- plane one node above that.\n\n        num_spawn_by = 1,\n        -- Number of spawn_by nodes that must be surrounding the decoration\n        -- position to occur.\n        -- If absent or -1, decorations occur next to any nodes.\n\n        flags = \"liquid_surface, force_placement, all_floors, all_ceilings\",\n        -- Flags for all decoration types.\n        -- \"liquid_surface\": Instead of placement on the highest solid surface\n        --   in a mapchunk column, placement is on the highest liquid surface.\n        --   Placement is disabled if solid nodes are found above the liquid\n        --   surface.\n        -- \"force_placement\": Nodes other than \"air\" and \"ignore\" are replaced\n        --   by the decoration.\n        -- \"all_floors\", \"all_ceilings\": Instead of placement on the highest\n        --   surface in a mapchunk the decoration is placed on all floor and/or\n        --   ceiling surfaces, for example in caves and dungeons.\n        --   Ceiling decorations act as an inversion of floor decorations so the\n        --   effect of 'place_offset_y' is inverted.\n        --   Y-slice probabilities do not function correctly for ceiling\n        --   schematic decorations as the behaviour is unchanged.\n        --   If a single decoration registration has both flags the floor and\n        --   ceiling decorations will be aligned vertically.\n\n        ----- Simple-type parameters\n\n        decoration = \"default:grass\",\n        -- The node name used as the decoration.\n        -- If instead a list of strings, a randomly selected node from the list\n        -- is placed as the decoration.\n\n        height = 1,\n        -- Decoration height in nodes.\n        -- If height_max is not 0, this is the lower limit of a randomly\n        -- selected height.\n\n        height_max = 0,\n        -- Upper limit of the randomly selected height.\n        -- If absent, the parameter 'height' is used as a constant.\n\n        param2 = 0,\n        -- Param2 value of decoration nodes.\n        -- If param2_max is not 0, this is the lower limit of a randomly\n        -- selected param2.\n\n        param2_max = 0,\n        -- Upper limit of the randomly selected param2.\n        -- If absent, the parameter 'param2' is used as a constant.\n\n        place_offset_y = 0,\n        -- Y offset of the decoration base node relative to the standard base\n        -- node position.\n        -- Can be positive or negative. Default is 0.\n        -- Effect is inverted for \"all_ceilings\" decorations.\n        -- Ignored by 'y_min', 'y_max' and 'spawn_by' checks, which always refer\n        -- to the 'place_on' node.\n\n        ----- Schematic-type parameters\n\n        schematic = \"foobar.mts\",\n        -- If schematic is a string, it is the filepath relative to the current\n        -- working directory of the specified Minetest schematic file.\n        -- Could also be the ID of a previously registered schematic.\n\n        schematic = {\n            size = {x = 4, y = 6, z = 4},\n            data = {\n                {name = \"default:cobble\", param1 = 255, param2 = 0},\n                {name = \"default:dirt_with_grass\", param1 = 255, param2 = 0},\n                {name = \"air\", param1 = 255, param2 = 0},\n                 ...\n            },\n            yslice_prob = {\n                {ypos = 2, prob = 128},\n                {ypos = 5, prob = 64},\n                 ...\n            },\n        },\n        -- Alternative schematic specification by supplying a table. The fields\n        -- size and data are mandatory whereas yslice_prob is optional.\n        -- See 'Schematic specifier' for details.\n\n        replacements = {[\"oldname\"] = \"convert_to\", ...},\n\n        flags = \"place_center_x, place_center_y, place_center_z\",\n        -- Flags for schematic decorations. See 'Schematic attributes'.\n\n        rotation = \"90\",\n        -- Rotation can be \"0\", \"90\", \"180\", \"270\", or \"random\"\n\n        place_offset_y = 0,\n        -- If the flag 'place_center_y' is set this parameter is ignored.\n        -- Y offset of the schematic base node layer relative to the 'place_on'\n        -- node.\n        -- Can be positive or negative. Default is 0.\n        -- Effect is inverted for \"all_ceilings\" decorations.\n        -- Ignored by 'y_min', 'y_max' and 'spawn_by' checks, which always refer\n        -- to the 'place_on' node.\n    }\n\nChat command definition\n-----------------------\n\nUsed by `minetest.register_chatcommand`.\n\n    {\n        params = \"<name> <privilege>\",  -- Short parameter description\n\n        description = \"Remove privilege from player\",  -- Full description\n\n        privs = {privs=true},  -- Require the \"privs\" privilege to run\n\n        func = function(name, param),\n        -- Called when command is run. Returns boolean success and text output.\n    }\n\nNote that in params, use of symbols is as follows:\n\n* `<>` signifies a placeholder to be replaced when the command is used. For\n  example, when a player name is needed: `<name>`\n* `[]` signifies param is optional and not required when the command is used.\n  For example, if you require param1 but param2 is optional:\n  `<param1> [<param2>]`\n* `|` signifies exclusive or. The command requires one param from the options\n  provided. For example: `<param1> | <param2>`","prefix":"to_table","body":"to_table()"},{"desc":"signifies grouping. For example, when param1 and param2 are both\n  required, or only param3 is required: `(<param1> <param2>) | <param3>`\n\nPrivilege definition\n--------------------\n\nUsed by `minetest.register_privilege`.\n\n    {\n        description = \"\",\n        -- Privilege description\n\n        give_to_singleplayer = true,\n        -- Whether to grant the privilege to singleplayer.\n\n        give_to_admin = true,\n        -- Whether to grant the privilege to the server admin.\n        -- Uses value of 'give_to_singleplayer' by default.\n\n        on_grant = function(name, granter_name),\n        -- Called when given to player 'name' by 'granter_name'.\n        -- 'granter_name' will be nil if the priv was granted by a mod.\n\n        on_revoke = function(name, revoker_name),\n        -- Called when taken from player 'name' by 'revoker_name'.\n        -- 'revoker_name' will be nil if the priv was revoked by a mod.\n\n        -- Note that the above two callbacks will be called twice if a player is\n        -- responsible, once with the player name, and then with a nil player\n        -- name.\n        -- Return true in the above callbacks to stop register_on_priv_grant or\n        -- revoke being called.\n    }\n\nDetached inventory callbacks\n----------------------------\n\nUsed by `minetest.create_detached_inventory`.\n\n    {\n        allow_move = function(inv, from_list, from_index, to_list, to_index, count, player),\n        -- Called when a player wants to move items inside the inventory.\n        -- Return value: number of items allowed to move.\n\n        allow_put = function(inv, listname, index, stack, player),\n        -- Called when a player wants to put something into the inventory.\n        -- Return value: number of items allowed to put.\n        -- Return value -1: Allow and don't modify item count in inventory.\n\n        allow_take = function(inv, listname, index, stack, player),\n        -- Called when a player wants to take something out of the inventory.\n        -- Return value: number of items allowed to take.\n        -- Return value -1: Allow and don't modify item count in inventory.\n\n        on_move = function(inv, from_list, from_index, to_list, to_index, count, player),\n        on_put = function(inv, listname, index, stack, player),\n        on_take = function(inv, listname, index, stack, player),\n        -- Called after the actual action has happened, according to what was\n        -- allowed.\n        -- No return value.\n    }\n\nHUD Definition\n--------------\n\nSee [HUD] section.\n\nUsed by `Player:hud_add`. Returned by `Player:hud_get`.\n\n    {\n        hud_elem_type = \"image\",  -- See HUD element types\n        -- Type of element, can be \"image\", \"text\", \"statbar\", or \"inventory\"\n\n        position = {x=0.5, y=0.5},\n        -- Left corner position of element\n\n        name = \"<name>\",\n\n        scale = {x = 2, y = 2},\n\n        text = \"<text>\",\n\n        number = 2,\n\n        item = 3,\n        -- Selected item in inventory. 0 for no item selected.\n\n        direction = 0,\n        -- Direction: 0: left-right, 1: right-left, 2: top-bottom, 3: bottom-top\n\n        alignment = {x=0, y=0},\n\n        offset = {x=0, y=0},\n\n        size = { x=100, y=100 },\n        -- Size of element in pixels\n    }\n\nParticle definition\n-------------------\n\nUsed by `minetest.add_particle`.\n\n    {\n        pos = {x=0, y=0, z=0},\n        velocity = {x=0, y=0, z=0},\n        acceleration = {x=0, y=0, z=0},\n        -- Spawn particle at pos with velocity and acceleration\n\n        expirationtime = 1,\n        -- Disappears after expirationtime seconds\n\n        size = 1,\n        -- Scales the visual size of the particle texture.\n\n        collisiondetection = false,\n        -- If true collides with `walkable` nodes and, depending on the\n        -- `object_collision` field, objects too.\n\n        collision_removal = false,\n        -- If true particle is removed when it collides.\n        -- Requires collisiondetection = true to have any effect.\n\n        object_collision = false,\n        -- If true particle collides with objects that are defined as\n        -- `physical = true,` and `collide_with_objects = true,`.\n        -- Requires collisiondetection = true to have any effect.\n\n        vertical = false,\n        -- If true faces player using y axis only\n\n        texture = \"image.png\",\n\n        playername = \"singleplayer\",\n        -- Optional, if specified spawns particle only on the player's client\n\n        animation = {Tile Animation definition},\n        -- Optional, specifies how to animate the particle texture\n\n        glow = 0\n        -- Optional, specify particle self-luminescence in darkness.\n        -- Values 0-14.\n    }\n\n\n`ParticleSpawner` definition\n----------------------------\n\nUsed by `minetest.add_particlespawner`.\n\n    {\n        amount = 1,\n        -- Number of particles spawned over the time period `time`.\n\n        time = 1,\n        -- Lifespan of spawner in seconds.\n        -- If time is 0 spawner has infinite lifespan and spawns the `amount` on\n        -- a per-second basis.\n\n        minpos = {x=0, y=0, z=0},\n        maxpos = {x=0, y=0, z=0},\n        minvel = {x=0, y=0, z=0},\n        maxvel = {x=0, y=0, z=0},\n        minacc = {x=0, y=0, z=0},\n        maxacc = {x=0, y=0, z=0},\n        minexptime = 1,\n        maxexptime = 1,\n        minsize = 1,\n        maxsize = 1,\n        -- The particles' properties are random values between the min and max\n        -- values.\n        -- pos, velocity, acceleration, expirationtime, size\n\n        collisiondetection = false,\n        -- If true collide with `walkable` nodes and, depending on the\n        -- `object_collision` field, objects too.\n\n        collision_removal = false,\n        -- If true particles are removed when they collide.\n        -- Requires collisiondetection = true to have any effect.\n\n        object_collision = false,\n        -- If true particles collide with objects that are defined as\n        -- `physical = true,` and `collide_with_objects = true,`.\n        -- Requires collisiondetection = true to have any effect.\n\n        attached = ObjectRef,\n        -- If defined, particle positions, velocities and accelerations are\n        -- relative to this object's position and yaw\n\n        vertical = false,\n        -- If true face player using y axis only\n\n        texture = \"image.png\",\n\n        playername = \"singleplayer\",\n        -- Optional, if specified spawns particles only on the player's client\n\n        animation = {Tile Animation definition},\n        -- Optional, specifies how to animate the particles' texture\n\n        glow = 0\n        -- Optional, specify particle self-luminescence in darkness.\n        -- Values 0-14.\n    }\n\n`HTTPRequest` definition\n------------------------\n\nUsed by `HTTPApiTable.fetch` and `HTTPApiTable.fetch_async`.\n\n    {\n        url = \"http://example.org\",\n\n        timeout = 10,\n        -- Timeout for connection in seconds. Default is 3 seconds.\n\n        post_data = \"Raw POST request data string\" OR {field1 = \"data1\", field2 = \"data2\"},\n        -- Optional, if specified a POST request with post_data is performed.\n        -- Accepts both a string and a table. If a table is specified, encodes\n        -- table as x-www-form-urlencoded key-value pairs.\n        -- If post_data is not specified, a GET request is performed instead.\n\n        user_agent = \"ExampleUserAgent\",\n        -- Optional, if specified replaces the default minetest user agent with\n        -- given string\n\n        extra_headers = { \"Accept-Language: en-us\", \"Accept-Charset: utf-8\" },\n        -- Optional, if specified adds additional headers to the HTTP request.\n        -- You must make sure that the header strings follow HTTP specification\n        -- (\"Key: Value\").\n\n        multipart = boolean\n        -- Optional, if true performs a multipart HTTP request.\n        -- Default is false.\n    }\n\n`HTTPRequestResult` definition\n------------------------------\n\nPassed to `HTTPApiTable.fetch` callback. Returned by\n`HTTPApiTable.fetch_async_get`.\n\n    {\n        completed = true,\n        -- If true, the request has finished (either succeeded, failed or timed\n        -- out)\n\n        succeeded = true,\n        -- If true, the request was successful\n\n        timeout = false,\n        -- If true, the request timed out\n\n        code = 200,\n        -- HTTP status code\n\n        data = \"response\"\n    }\n\nAuthentication handler definition\n---------------------------------\n\nUsed by `minetest.register_authentication_handler`.\n\n    {\n        get_auth = function(name),\n        -- Get authentication data for existing player `name` (`nil` if player\n        -- doesn't exist).\n        -- Returns following structure:\n        -- `{password=<string>, privileges=<table>, last_login=<number or nil>}`\n\n        create_auth = function(name, password),\n        -- Create new auth data for player `name`.\n        -- Note that `password` is not plain-text but an arbitrary\n        -- representation decided by the engine.\n\n        delete_auth = function(name),\n        -- Delete auth data of player `name`.\n        -- Returns boolean indicating success (false if player is nonexistent).\n\n        set_password = function(name, password),\n        -- Set password of player `name` to `password`.\n        -- Auth data should be created if not present.\n\n        set_privileges = function(name, privileges),\n        -- Set privileges of player `name`.\n        -- `privileges` is in table form, auth data should be created if not\n        -- present.\n\n        reload = function(),\n        -- Reload authentication data from the storage location.\n        -- Returns boolean indicating success.\n\n        record_login = function(name),\n        -- Called when player joins, used for keeping track of last_login\n\n        iterate = function(),\n        -- Returns an iterator (use with `for` loops) for all player names\n        -- currently in the auth database\n    }","prefix":"","body":"()"}]
